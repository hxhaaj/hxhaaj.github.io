<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>whoAyou&#39;s Blogs</title>
  
  <subtitle>没有人天生倔强，只因梦想寸土不让</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-12T11:56:21.127Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胡啊呦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE回顾-多线程</title>
    <link href="http://yoursite.com/2018/06/20/JavaSE%E5%9B%9E%E9%A1%BE-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/06/20/JavaSE回顾-多线程/</id>
    <published>2018-06-19T16:00:00.000Z</published>
    <updated>2018-07-12T11:56:21.127Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaSE回顾"><a href="#JavaSE回顾" class="headerlink" title="JavaSE回顾"></a>JavaSE回顾</h1><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="程序-program"><a href="#程序-program" class="headerlink" title="程序(program)"></a>程序(program)</h4><ul><li>为了完成特定任务、用某种语言编写的一组<code>指令的集合</code>。即<code>一段静态的代码</code>，<code>静态对象</code>。</li></ul><h4 id="进程-process"><a href="#进程-process" class="headerlink" title="进程(process)"></a>进程(process)</h4><ul><li><p><code>程序</code>的一次<code>执行过程</code>，或者是<code>正在运行的一个程序</code>，是动态过程。</p></li><li><p>动态过程：有自身的产生、存在和消亡的过程。</p></li><li><code>程序是静态的，而进程是动态的</code>。</li></ul><h4 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h4><ul><li><p><code>进程</code>可以进一步<code>细化为线程</code>，是<code>一个程序</code>内部的<code>一条执行路径</code>。</p></li><li><p>若一个程序可<code>同一时间</code>执行多个线程，那么这个程序就支持多线程。</p></li></ul><h4 id="Java中的线程"><a href="#Java中的线程" class="headerlink" title="Java中的线程"></a>Java中的线程</h4><ul><li>Java线程是依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码，只有本地线程才是真正的线程实体。</li><li>Java代码中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体 </li></ul><h4 id="多线程的用处"><a href="#多线程的用处" class="headerlink" title="多线程的用处"></a>多线程的用处</h4><ul><li>发挥多核CPU的优势，大大提高效率</li><li>防止多余的阻塞<ul><li>单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率 ，但是单核CPU我们还是要应用多线程，就是为了防止阻塞 。</li><li>多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行 </li></ul></li><li>方便进行业务拆分，提升应用性能</li></ul><h4 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h4><ul><li>时间片是CPU调度给各个线程的时间。</li></ul><h4 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h4><ul><li>并行：多个任务<code>同时进行</code>，必须有<code>多核CPU</code>的支持</li><li>并发：指多个任务都请求运行，而处理器只能接受一个任务，就是把多个任务<code>轮流进行</code>，由于轮转时间<code>间隔过短</code>，让人<code>感觉</code>是多个任务都在同时运行。</li></ul><h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><ul><li>同步和异步通常用来形容一次方法调用。</li><li>同步方法调用一开始，调用者必须等待被调用的方法执行结束后，才能执行后面的代码。</li><li>异步方法调用后，调用者不用理会调用方法是否执行完毕，都会继续执行后面的代码，当被调用的方法完成之后会通知调用者。</li></ul><h4 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h4><ul><li>临界区表示一种<code>公共资源，共享数据</code>，可以被多个线程使用。</li><li>一旦临界区资源<code>被一个线程占用时</code>，<code>其他线程必须等待其使用完毕</code>后才能使用。</li></ul><h4 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h4><ul><li>阻塞和非阻塞通常用来形容<code>多线程之间</code>的相互影响。</li><li>当一个线程<code>占用了临界区资源</code>，那么<code>其他线程</code>需要这个资源就必须<code>等待</code>该<code>资源</code>被那个线程<code>释放</code>，这就会导致<code>等待的线程挂起</code>，这种情况就是阻塞。</li><li>非阻塞强调没有一个线程可以阻塞到其他线程，所有的线程都会尝试地往前运行。和阻塞正好相反。</li></ul><h2 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h2><ol><li><p>Java程序的运行原理？</p><ul><li>Java命令会启动Java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。这个进程会自动的启动一个<code>主线程</code>，然后<code>主线程调用类中的main方法</code>。</li><li>实际上java程序天生就是一个多线程程序，包含了：<ul><li>（1）分发处理发送给给JVM信号的线程</li><li>（2）调用对象的finalize方法的线程</li><li>（3）清除Reference的线程；</li><li>（4）main线程，用户程序的入口 </li></ul></li></ul></li><li><p>JVM的启动是多线程吗？</p><p>JVM的启动<code>至少启动</code>了<code>主线程</code>和<code>垃圾回收线程</code>，所以是多线程的。</p></li></ol><h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><h3 id="方式一：-继承Thread类"><a href="#方式一：-继承Thread类" class="headerlink" title="方式一： 继承Thread类"></a>方式一： 继承Thread类</h3><ul><li><p>Thread类实现了<code>Runnable接口</code>，在<code>java.long</code>包下。</p></li><li><p>创建执行线程方法一：将类继承<code>Thread</code>类，重写<code>Thread</code>类的<code>run</code>方法。接下来就可以分配并启动该子类的实例。</p></li><li><p>具体步骤：</p><ol><li>继承Thread类</li><li>重写run方法</li><li>将执行的代码写在run方法中</li><li>创建Thread类的子类对象</li><li>使用start方法开启线程。</li></ol></li><li><p>注意：<strong>调用run方法不能开启多线程</strong>。</p></li><li><p><code>只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行</code>。如果<code>只是调用run()方法</code>，那么代码<code>还是同步执行的</code>，<code>必须等待一个线程的run()方法</code>里面的代码<code>全部执行完毕之后</code>，<code>另外一个线程才可以执行</code>其run()方法里面的代码。 </p></li><li><p><strong>一个线程不能多次开启是非法的</strong></p></li><li><p>代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//4，创建Thread类的子类对象</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.start();<span class="comment">//5，使用start方法开启线程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">MyThread</span> <span class="keyword">extends</span>  <span class="title">Thread</span></span>&#123; <span class="comment">//1.继承Thread类</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2，重写run方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//3，将执行的代码写在run方法中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">10000</span> ; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"mt"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方式二：实现Runnable接口（常用，优点多）"><a href="#方式二：实现Runnable接口（常用，优点多）" class="headerlink" title="方式二：实现Runnable接口（常用，优点多）"></a>方式二：实现Runnable接口（常用，优点多）</h3><ul><li><p>声明实现Runnable接口的类，实现Runnable接口中仅有的run方法，然后分配实例对象，在创建Thread时作为一个参数来传递并启动。</p></li><li><p>具体步骤</p><ul><li>1，定义类实现Runnable接口</li><li>2，在该类中实现Runnable接口中的<code>run()</code>方法</li><li>3，线程中具体要执行的东西写在<code>run()</code>方法中</li><li>4，创建Thread类的对象，并在该对象中传入该<code>实现Runnable</code>接口的对象作参数</li><li>5，Thread类的对象调用<code>start()</code>方法开启新线程，其内部会自动的调用run方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable  mr =  <span class="keyword">new</span> MyRunnable(); <span class="comment">//4、创建自己定义的Runnable实现类的对象</span></span><br><span class="line">        Thread  thread = <span class="keyword">new</span> Thread(mr); <span class="comment">//5、创建Thread类的对象，并将自定义Runnable实现类的对象作为参数传递给Thread的构造函数</span></span><br><span class="line">        thread.start(); <span class="comment">//使用thread类的start方法开启线程。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main+"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1、定义一个Runnable实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="comment">//2、实现Runnable接口中的抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3、在run方法中写入要使用多线程的具体方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"mr"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Runnable接口方式的实现原理</p><ul><li><p>1、查看Thread 类的<code>构造函数</code>，传递了Runnable接口的引用，直接调用了<code>init</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">       init(<span class="keyword">null</span>, target, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>2、追踪<code>init</code>方法，在init方法体中找到了传递的<code>target</code>参数，赋值给了Thread类的Runnable接口的<code>成员变量的target</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.target = target;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* What will be run. */</span></span><br><span class="line">   <span class="keyword">private</span> Runnable target;</span><br></pre></td></tr></table></figure></li><li><p>3、查看run方法时，发现run方法中有判断，如果target不为null就会调用实现Runnable接口子类对象的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="为什么实例效果不明显？"><a href="#为什么实例效果不明显？" class="headerlink" title="为什么实例效果不明显？"></a>为什么实例效果不明显？</h3><ul><li>多线程指的是多个线程的代码块可以同时运行，而不必一个线程去等待另一个线程执行完才可以进行。</li><li>对于单核CPU来说，无法做到真正意义上的多线程特性。只能会让用户看起来像是同时执行的，因为每个时间点上，CPU都会执行特定的代码，由于CPU执行代码时间非常快，多个线程代码块就会轮询执行，速度很快，但是同一个线程进行的轮询操作。</li><li>具体执行某段代码多长时间和分时机制系统密切相关。</li><li><code>分时系统</code>把<code>CPU时间</code>划分为多个<code>时间片</code>，操作系统以时间片为单位执行各个线程的代码，时间片越小，执行效率越高。</li></ul><h3 id="多线程的两种实现方式的区别"><a href="#多线程的两种实现方式的区别" class="headerlink" title="多线程的两种实现方式的区别"></a>多线程的两种实现方式的区别</h3><ul><li>源码中的区别<ul><li>继承Thread类方式：由于子类重写了Thread类的run()，当调用start()时，直接找子类的run()方法(Java虚拟机自动完成)</li><li>实现Runnable方式：构造函数中传入了Runnable的引用，传给了Thread类中的成员变量，start()调用了run()方法时的内部判断成员变量Runnable的引用是否为空，若不为空，编译时看的是Runnable的run()，运行时执行的是具体实现类中的run()</li></ul></li><li>优缺点：<ul><li>继承Thread类方式<ul><li>好处：可以直接使用Thread类中的方法，代码简单</li><li>弊端：同样也是面向对象中的继承的缺点：<code>如果该具体类已经有了其他的父类，那么就不能多重继承Thread类</code>，就不能使用这种方法。此时<code>面向接口编程</code>的优势脱颖而出。</li></ul></li><li>实现Runnable接口方式<ul><li>好处：即继承的弊端：即使自己定义的<code>线程类有了其他父类也可以实现该Runnable接口</code>。Java中的接口是<code>多实现</code>的，继承是<code>单继承</code>，比较有局限性。</li><li>弊端：<code>不能直接使用Thread类中的方法</code>，需要先把Runnable具体实现类对象传递给Thread类并获取到<code>线程对象</code>后，才能得到Thread类的方法，代码相对复杂</li></ul></li></ul></li></ul><h3 id="匿名内部类实现线程的两种方式"><a href="#匿名内部类实现线程的两种方式" class="headerlink" title="匿名内部类实现线程的两种方式"></a>匿名内部类实现线程的两种方式</h3><p>即直接使用匿名内部类的方式简化代码：</p><ul><li><p>继承Thread类方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"t+"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>实现Runnable接口方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"mr"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p><code>Runnable</code>接口是一个<code>函数式接口</code>，可以直接用<code>Lambda表达式</code>代替:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lambda表达式</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">1000</span>; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">"mr"</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li><li><p>还有一种方式，在Java并发包中实现Callable接口方式，此处先不作表述</p></li></ul><h2 id="线程相关实例方法"><a href="#线程相关实例方法" class="headerlink" title="线程相关实例方法"></a>线程相关实例方法</h2><h3 id="获取线程ID-getId"><a href="#获取线程ID-getId" class="headerlink" title="获取线程ID- getId"></a>获取线程ID- getId</h3><ul><li>在一个Java应用程序中，有一个long型的全局唯一的线程ID生成器<code>threadSeqNumber</code>，每new出来一个线程就会自增一次，从0开始，并且赋值给线程的tid属性。</li><li>用户只能获取ID，不能执行一个线程的ID，这是Thread类内部自己完成的。</li></ul><h3 id="获取和设置线程的名字"><a href="#获取和设置线程的名字" class="headerlink" title="获取和设置线程的名字"></a>获取和设置线程的名字</h3><ul><li><p>获取线程名</p><ul><li><p>通过<code>getName()</code>方法获取线程对象名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName());<span class="comment">//Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>设置线程名</p><ul><li><p>通过<code>构造函数</code>传入String类型名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="string">"线程1"</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName());<span class="comment">//线程1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="string">"线程2"</span>)&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName());<span class="comment">//线程2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Lambda表达式的Runnable方式，Thread的构造函数</span></span><br><span class="line">Thread  t2 = <span class="keyword">new</span> Thread(() -&gt;</span><br><span class="line">                        System.out.println(<span class="string">"线程5的执行方法体"</span>),<span class="string">"线程5"</span>);</span><br><span class="line">t2.start();</span><br><span class="line">System.out.println(t2.getName());<span class="comment">//线程5</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>通过<code>setName(String name)</code>方法设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setName(<span class="string">"线程3"</span>);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName());<span class="comment">//线程3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName());<span class="comment">//线程4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">t1.setName(<span class="string">"线程4"</span>);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread t1 = <span class="keyword">new</span> Thread(()-&gt; System.out.println(<span class="string">"线程4的执行方法体"</span>));</span><br><span class="line">t1.setName(<span class="string">"线程4"</span>);</span><br><span class="line">t1.start();</span><br><span class="line">System.out.println(t1.getName());<span class="comment">//线程4</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        线程4</span></span><br><span class="line"><span class="comment">        线程4的执行方法体</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure></code></pre><h3 id="线程对象是否处于活动状态-isAlive"><a href="#线程对象是否处于活动状态-isAlive" class="headerlink" title="线程对象是否处于活动状态 - isAlive"></a>线程对象是否处于活动状态 - isAlive</h3><ul><li><code>t.isAlive()</code> 测试线程t是否处于活动状态，只要<code>线程启动并且没有终止</code>，方法返回值就是<code>true</code>。</li><li><code>start()</code>之前，线程不处于活动状态，之后就处于了活动状态。</li></ul><h3 id="获取当前线程的对象"><a href="#获取当前线程的对象" class="headerlink" title="获取当前线程的对象"></a>获取当前线程的对象</h3><ul><li><p><code>Thread.currentThread() 静态方法，获取当前执行线程</code>， 主线程也可以获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Runnable接口方式</span></span><br><span class="line"><span class="comment">//new Thread(Runnable target,String threadName) 构造方法</span></span><br><span class="line"><span class="keyword">new</span> Thread(()-&gt; System.out.println(Thread.currentThread().getName()),<span class="string">"线程6"</span>)</span><br><span class="line">                .start();<span class="comment">//线程6</span></span><br></pre></td></tr></table></figure><p>在main方法中可以获取主线程对象并设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().setName(<span class="string">"我是主线程"</span>);</span><br><span class="line">System.out.println(Thread.currentThread().getName());<span class="comment">//我是主线程</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="休眠线程-sleep"><a href="#休眠线程-sleep" class="headerlink" title="休眠线程-sleep"></a>休眠线程-sleep</h3><ul><li><p><code>Thread.sleep(毫秒) / Thread.sleep(毫秒，纳秒)</code> 控制当前线程休眠若干毫秒</p><ul><li>1秒 = 1000毫秒</li><li>1秒 = 1000 <em> 1000 </em> 1000 纳秒 （100,000,000）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ;i++)&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>); <span class="comment">//每个线程休眠1秒（1000毫秒)</span></span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">"测试线程1"</span>).start();</span><br></pre></td></tr></table></figure></li><li><p><code>sleep方法不会释放锁，wait方法会释放锁</code></p></li></ul><h3 id="加入线程-join"><a href="#加入线程-join" class="headerlink" title="加入线程-join"></a>加入线程-join</h3><ul><li><code>join()</code> <code>当前</code>线程<code>暂停</code>，等待<code>指定的线程执行结束</code>后，<code>当前线程</code>才能再<code>继续</code>。即把指定的线程插队处理。</li><li><code>join(int ms)</code>  可以等待指定的<code>毫秒</code>后再继续。</li><li>join()方法会使<code>调用该方法的线程</code>处于<code>运行状态</code>，让<code>一开始所在的线程</code>处于无限<code>阻塞状态</code>，直到调用了join方法的线程执行完毕，线程销毁为止。</li><li>下面这个例子中，t2线程处于了阻塞状态，直到t1线程的run()方法执行完，线程死亡状态，t2线程才可以运行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Java8中 匿名内部类调用外接方法和变量时，外接变量可以不用final修饰，但是其值还是不能改变</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread() &#123; <span class="comment">//此时的t1在Java8之前必须用final修饰，是不可变的</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"aaa"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//Java8中 匿名内部类调用外接方法和变量时，外接变量可以不用final修饰，但是其值还是不能改变</span></span><br><span class="line">                        t1.join();<span class="comment">//t1线程对象来插队了，t1执行完之后t2才能继续执行</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"bbb"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">1</span>bbb</span><br><span class="line">Thread-<span class="number">1</span>bbb</span><br><span class="line">Thread-<span class="number">0</span>aaa</span><br><span class="line">Thread-<span class="number">0</span>aaa</span><br><span class="line">Thread-<span class="number">0</span>aaa</span><br><span class="line">Thread-<span class="number">0</span>aaa</span><br><span class="line">Thread-<span class="number">0</span>aaa</span><br><span class="line">Thread-<span class="number">0</span>aaa</span><br><span class="line">Thread-<span class="number">0</span>aaa</span><br><span class="line">Thread-<span class="number">0</span>aaa</span><br><span class="line">Thread-<span class="number">0</span>aaa</span><br><span class="line">Thread-<span class="number">0</span>aaa</span><br><span class="line">Thread-<span class="number">1</span>bbb</span><br><span class="line">Thread-<span class="number">1</span>bbb</span><br><span class="line">Thread-<span class="number">1</span>bbb</span><br><span class="line">Thread-<span class="number">1</span>bbb</span><br><span class="line">Thread-<span class="number">1</span>bbb</span><br><span class="line">Thread-<span class="number">1</span>bbb</span><br><span class="line">Thread-<span class="number">1</span>bbb</span><br><span class="line">Thread-<span class="number">1</span>bbb</span><br></pre></td></tr></table></figure><p>结果显示：当t2线程执行两个后，t1使用join方法来插队，t1执行完之后，t2才继续执行完。</p><h3 id="让出线程-yield"><a href="#让出线程-yield" class="headerlink" title="让出线程-yield"></a>让出线程-yield</h3><ul><li><code>Thread.yield()</code>  使<code>该线程让出cpu</code>，给其他线程使用cpu执行</li><li>yield只会把时间片让给<code>同优先级的线程</code></li><li>使<code>CPU调度到其他线程</code>，让该线程从<code>运行状态</code>回到<code>可运行状态</code></li></ul><h3 id="设置线程优先级"><a href="#设置线程优先级" class="headerlink" title="设置线程优先级"></a>设置线程优先级</h3><ul><li><p><code>thread.setPriority(int priority)</code>  设置线程的优先级</p><ul><li><p>Thread类源码中有三种优先级：(1,5,10)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The minimum priority that a thread can have.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The default priority that is assigned to a thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum priority that a thread can have.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>优先级值：默认为5，最大为10，最小为1；</p></li><li><p>不能超过1~10这个范围。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1.setPriority(Thread.MIN_PRIORITY);<span class="comment">//最小</span></span><br><span class="line">t1.setPriority(Thread.MAX_PRIORITY);<span class="comment">//最大</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="中断线程-Interrupt"><a href="#中断线程-Interrupt" class="headerlink" title="中断线程-Interrupt"></a>中断线程-Interrupt</h3><ul><li>中断可以理解为线程的一个<code>标志位</code>，它表示了一个运行中的线程<code>是否</code>被其他线程进行了<code>中断操作</code>。</li><li>其他线程可以调用该线程的<code>interrupt()</code>方法对其进行中断操作，同时该线程可以调用<code>isInterrupted()</code>来感知其他线程对其是否进行了中断操作，从而做出相应。</li><li>也可以调用<code>Thread</code>中的静态方法<code>interrupted()</code>对当前线程<code>进行中断</code>操作，<code>该方法会清除中断标志位</code>。</li><li>当抛出<code>InterruptedException</code>时，会<code>清除中断标志位</code>，也就是说在调用isInterrupted会返回false。</li><li>如果线程调用了 <code>wait()、sleep()、join()</code>方法而导致的<code>阻塞</code>，可以<code>中断线程</code>，并抛出<code>InterruptedException</code>来唤醒</li></ul><table><thead><tr><th>方法名</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>public void  interrupt()</td><td>中断该线程对象</td><td>如果线程调用了 <code>wait()、sleep()、join()</code>方法而导致的<code>阻塞</code>，可以<code>中断线程</code>，并抛出<code>InterruptedException</code>来唤醒，并且中断标志位会被清除</td></tr><tr><td>public boolean isInterrupted()</td><td>测试该线程对象是否被中断</td><td>中断标志位不会被清除</td></tr><tr><td>public static  boolean interrupted()</td><td>测试当前线程是否被中断</td><td>中断标志位会被清除</td></tr></tbody></table><h3 id="守护线程-Deamon"><a href="#守护线程-Deamon" class="headerlink" title="守护线程-Deamon"></a>守护线程-Deamon</h3><ul><li><p><code>setDaemon(boolean on)</code>  设置一个线程<code>作为守护线程</code>。</p></li><li><p>守护线程<code>为其他线程</code>的运行<code>提供便利的服务</code>，最典型的应用便是GC线程 。</p></li><li><p>该线程<code>不会单独执行</code>，当其他<code>非守护</code>线程都执行<code>结束</code>后，守护线程就没有可服务的对象了，就会<code>自动退出</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"非守护线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"守护线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    t2.setDaemon(<span class="keyword">true</span>);<span class="comment">//将t2设置成守护线程</span></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第一次执行结果：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread-0非守护线程</span><br><span class="line">Thread-0非守护线程</span><br><span class="line">Thread-0非守护线程</span><br></pre></td></tr></table></figure><ul><li><p>说明：非守护线程直接执行完毕后，<code>守护线程还未开启执行</code>，就<code>自动退出</code>了。</p></li><li><p>第二次执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0非守护线程</span><br><span class="line">Thread-1守护线程</span><br><span class="line">Thread-1守护线程</span><br><span class="line">Thread-0非守护线程</span><br><span class="line">Thread-0非守护线程</span><br><span class="line">Thread-1守护线程</span><br><span class="line">Thread-1守护线程</span><br><span class="line">Thread-1守护线程</span><br><span class="line">Thread-1守护线程</span><br><span class="line">Thread-1守护线程</span><br></pre></td></tr></table></figure></li><li><p>根据结果发现，守护线程和非守护线程穿插执行，非守护线程执行完之后，守护线程继续执行了，<code>没有立即停止</code>，该现象为<code>线程缓冲</code>，即守护线程正在执行，需要等到非守护线程的<code>执行完毕信号</code>后，<code>才能停止</code>下来，自动退出。</p></li></ul></li></ul><h3 id="wait-和notify-notifyAll"><a href="#wait-和notify-notifyAll" class="headerlink" title="wait()和notify()/notifyAll()"></a>wait()和notify()/notifyAll()</h3><p>Object类中的wait()、notify()、notifyAll()三个方法，每个对象都是有的，结合多线程后可以起到很大的效果。</p><h4 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h4><ul><li><code>wait()</code>方法作用是使当前执行的代码的<code>线程进行等待</code>，当前线程会<code>进入等待队列</code>中。</li><li><code>wait()</code>代码处会<code>停止执行</code>，直到<code>接到通知</code>（notify()）或者<code>被中断</code>（Interrupt()）。</li><li>在<code>调用wait()之前</code>，<code>线程必须获取该对象的锁</code>，因此wait()方法只能在<code>同步代码中</code>调用执行。</li><li>wait()方法可以使调用该线程的方法<code>释放共享资源的锁</code>，然后从运行状态退出，进入<code>等待队列</code>，直到再次被唤醒。</li></ul><h4 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h4><ul><li><code>唤醒等待的线程</code>，如果有<code>多个线程在等待队列</code>中，那么会<code>随机</code>挑选一个等待的线程，对其发出唤醒通知，并且<code>使它等待获取该对象的对象锁</code>。</li><li><code>等待获取对象锁</code>说明了<code>即使收到了通知，wait 的线程也不会马上获取对象锁</code>，会在<code>锁池</code>中进行<code>等待notify方法的线程释放锁</code>才可以，<code>获取了对象锁之后</code>才能<code>从锁池中出去</code>进入<code>可运行状态</code>。</li><li>在调用notify()之前，和wait()一样，<code>必须在同步代码中调用</code>。因为有锁的操作。</li><li>notify()不释放锁</li></ul><h4 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h4><ul><li>notifyAll()方法可以使所有正在等待队列中等待同一共享资源的<strong>全部线程</strong>从等待状态退出，随机进入锁池，等待拿到对象锁，进入可运行状态。  </li></ul><p>如果wait()方法和notify()/notifyAll()方法不在同步方法/同步代码块中被调用，那么虚拟机会抛出java.lang.IllegalMonitorStateException </p><h3 id="☆-sleep-和wait-的区别"><a href="#☆-sleep-和wait-的区别" class="headerlink" title="☆ sleep()和wait()的区别"></a>☆ sleep()和wait()的区别</h3><ol><li><p>方法本质上：</p><ul><li>wait()方法时<code>Object</code>类中的<code>实例方法</code>。可以传入参数，也可以不传入参数。</li><li>而sleep()方法时<code>Thread</code>类中的<code>静态方法</code>。必须传入参数ms值。</li></ul></li><li><p>使用环境上：</p><ul><li><code>wait()</code>方法必须要在<code>同步方法或同步代码块中</code>使用，因为它必须已经获得对象锁。</li><li>而<code>sleep()</code>方法没有这个限制，它可以在<code>任何地方</code>使用。</li></ul></li><li><p>是否释放锁：</p><ul><li><code>wait()</code>方法会<code>释放</code>占有的对象锁，使该线程<code>进入等待池</code>中。</li><li>而<code>sleep()</code>方法<code>不会释放</code>对象锁，<code>只会让出CPU</code>。</li></ul></li><li><p>使其继续执行方式上：</p><ul><li><p><code>wait()</code>方法必须等待 <code>notify()/notifyAll()方法的唤醒通知</code>后，才会离开等待池并且如果<code>再次获得CPU时间片</code>才会继续执行。</p></li><li><p>而<code>sleep()</code>方法在<code>休眠时间到达后</code>，如果<code>再次获得CPU时间片</code>就会继续执行。</p></li></ul></li></ol><h3 id="Java中用到的线程调度算法"><a href="#Java中用到的线程调度算法" class="headerlink" title="Java中用到的线程调度算法"></a>Java中用到的线程调度算法</h3><ul><li>Java中用到的是抢占式的线程调度算法。一个线程用完CPU后，操作系统会根据线程优先级、线程饥饿程度等数据算出一个总的优先级并分配下一个时间片给某个线程。</li></ul><h3 id="Thread-sleep-0-的作用？"><a href="#Thread-sleep-0-的作用？" class="headerlink" title="Thread.sleep(0)的作用？"></a>Thread.sleep(0)的作用？</h3><ul><li>平衡CPU控制权的一种操作：<ul><li>由于Java采用的是抢占式线程调度算法，因此可能就会<code>出现某条线程综合来看常常会获取到CPU的控制权</code>的情况，<code>为了让某些优先级较低的线程也能获得到CPU控制权</code>，可以<code>使用Thread.sleep(0)手动出发一次操作系统分配时间片的操作</code>，来平衡控制权。 </li></ul></li></ul><h2 id="线程六大状态"><a href="#线程六大状态" class="headerlink" title="线程六大状态"></a>线程六大状态</h2><p>根据Thread类中定义的枚举类型<code>State</code>值，可以看出有6中状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>新建</code>状态 NEW</p><p>新建了Thread类对象，但是没有启动的线程。<code>new Thread()</code> </p></li><li><p><code>可运行</code>状态 RUNNABLE</p><p>线程对象新建后，调用<code>start()</code>方法即处于了<code>RUNNABLE</code>状态。</p><ul><li>此状态线程可能在Java虚拟机中运行；</li><li>可能在等待CPU处理器分配资源。</li><li>一个线程只有获取到CPU的资源后，才可以运行其<code>run()</code>方法执行代码，否则就会处于排队等待</li></ul></li><li><p><code>阻塞</code>状态 BLOCKED</p><p>该线程正在等待同步锁来进入一个同步代码块中来使用CPU资源，此时该线程就处于阻塞状态。</p></li><li><p><code>等待</code>状态  WAITING</p><p>线程调用以下方法时，会自己进入等待状态：</p><ul><li>不带超时的<code>Object类</code>中的<code>wait()</code>方法</li><li>不带超时的<code>Thread</code>类中的<code>join()</code>方法</li><li><code>LockSupport</code>类中的<code>park()</code>方法</li></ul><p>一直等待，直到手动唤醒</p></li><li><p><code>超时等待</code>状态  TIMED_WAITING</p><p>线程调用带有正的等待时间参数的下列各方法时，会处于超时等待状态：</p><ul><li><code>Object</code>中的<code>wait()</code></li><li><code>Thread</code>中的<code>join()</code></li><li><code>Thread</code>中的<code>sleep()</code></li><li><code>LockSupport</code>中的<code>parkNanos()</code></li><li><code>LockSupport</code>中的<code>parkUntil()</code></li></ul></li><li><p><code>终止</code>状态 TERMINATED</p><ul><li><code>线程执行完毕</code>，或<code>run()</code>方法<code>全部执行结束</code>后，线程进入终止状态。</li><li>终止状态的线程<code>不具备继续运行</code>的能力。</li></ul></li></ol><h3 id="线程状态图"><a href="#线程状态图" class="headerlink" title="线程状态图"></a>线程状态图</h3><p><img src="/JavaSE回顾_多线程_Media/线程状态图.jpg" alt=""></p><ul><li>锁池队列：当资源被一个线程访问时，上锁后，其他线程就会进入锁池队列，当锁释放后，其他线程获得了锁，就会变成可运行状态。</li><li><code>《Thinking in Java》</code>中线程被阻塞的五种可能原因：<ol><li>线程调用 <code>sleep(ms)</code> ，使线程睡眠，规定时间内，该线程不会运行。</li><li>使用<code>suspend()</code>暂停了线程的执行，除非收到<code>resume()</code>消息，否则不会进入可运行状态</li><li>线程正在等待一些IO操作完成</li><li>线程试图调用另一个对象的同步方法，但那个对象处于锁状态，暂时无法使用</li><li>调用<code>wait()</code>暂停了线程的执行，进入了等待队列。</li></ol></li></ul><h3 id="怎么唤醒一个阻塞的线程"><a href="#怎么唤醒一个阻塞的线程" class="headerlink" title="怎么唤醒一个阻塞的线程"></a>怎么唤醒一个阻塞的线程</h3><ul><li>如果线程调用了 <code>wait()、sleep()、join()</code>方法而导致的阻塞，可以中断线程，并抛出<code>InterruptedException</code>来唤醒</li><li>如果该线程遇到了IO阻塞，只能等系统IO操作结束后，才能唤醒，Java代码无能为力，无法直接接触到底层操作系统的调度。</li></ul><h3 id="怎么检测一个线程是否持有对象监视器"><a href="#怎么检测一个线程是否持有对象监视器" class="headerlink" title="怎么检测一个线程是否持有对象监视器"></a>怎么检测一个线程是否持有对象监视器</h3><ul><li>Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static boolean holdsLock(Object obj)</span><br></pre></td></tr></table></figure><h2 id="同步代码"><a href="#同步代码" class="headerlink" title="同步代码"></a>同步代码</h2><h3 id="需要同步的情况"><a href="#需要同步的情况" class="headerlink" title="需要同步的情况"></a>需要同步的情况</h3><ul><li>当<code>多线程并发</code>，有<code>多段</code>代码<code>同时执行</code>时，希望<code>某一段</code>代码<code>执行的过程中</code>，<code>CPU不要切换</code>到其他线程上，此时就需要同步。</li><li>如果有两段代码是同步进行的，那么<code>同一时间</code>只能<code>执行其中一段</code>，在一段代码<code>没执行结束之前</code>，<code>不会执行另外一段</code>代码。</li></ul><h3 id="同步代码块操作"><a href="#同步代码块操作" class="headerlink" title="同步代码块操作"></a>同步代码块操作</h3><ul><li><p>使用<code>synchronized</code>关键字加上一个<code>锁对象</code>来<code>定义一段代码</code>，这就称为<code>同步代码块</code>。</p></li><li><p>如果<code>多个同步代码块</code>使用<code>同一个锁对象</code>，那么<code>他们就是同步的</code></p></li><li><p>同步代码块是<code>锁机制</code>，同一个锁对象，同步代码块是同步的。</p></li><li><p>锁对象是<code>任意对象</code>，但<code>不能是匿名对象</code>，因为匿名对象不是同一个对象。</p></li><li><p>当多个代码块使用了<code>同一个锁对象</code>的 <code>synchronized 锁机制</code>，只有当一个线程把 synchronized 代码块的代码<code>全部执行完之后</code>，<code>才能</code>去<code>执行该同一锁对象的另一段代码</code>。</p><ul><li>即该多个代码块是<code>同步</code>的，<code>同一时间只能执行其中一段</code>，执行完之后，才能执行另一段。</li><li>若<code>锁对象不一致</code>，即<code>不是同步的</code>，会出现抢占线程执行的情况。</li></ul></li><li><p>具体操作： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Consumer con  = <span class="keyword">new</span> Consumer();</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                con.print1();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">                con.print2();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个Object对象，作为锁对象</span></span><br><span class="line">    Object  obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//锁机制使用同一个锁对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">            System.out.print(<span class="string">"同"</span>);</span><br><span class="line">            System.out.print(<span class="string">"步"</span>);</span><br><span class="line">            System.out.print(<span class="string">"代"</span>);</span><br><span class="line">            System.out.print(<span class="string">"码"</span>);</span><br><span class="line">            System.out.print(<span class="string">"块"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//锁机制使用同一个锁对象，作为同步代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">            System.out.print(<span class="string">"多"</span>);</span><br><span class="line">            System.out.print(<span class="string">"线"</span>);</span><br><span class="line">            System.out.print(<span class="string">"程"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h3><ul><li><p>使用<code>synchronized</code>关键字<code>修饰一个方法</code>时，该<code>方法中所有代码</code>都是同步的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方法只需在方法上加 synchronized </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//锁机制使用同一个锁对象</span></span><br><span class="line">    <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">        System.out.print(<span class="string">"同"</span>);</span><br><span class="line">        System.out.print(<span class="string">"步"</span>);</span><br><span class="line">        System.out.print(<span class="string">"代"</span>);</span><br><span class="line">        System.out.print(<span class="string">"码"</span>);</span><br><span class="line">        System.out.print(<span class="string">"块"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>非静态同步函数</code>的锁是<code>this</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步方法只需在方法上加 synchronized </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">        System.out.print(<span class="string">"同"</span>);</span><br><span class="line">        System.out.print(<span class="string">"步"</span>);</span><br><span class="line">        System.out.print(<span class="string">"代"</span>);</span><br><span class="line">        System.out.print(<span class="string">"码"</span>);</span><br><span class="line">        System.out.print(<span class="string">"块"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//非静态的同步方法的锁对象是this</span></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">        System.out.print(<span class="string">"多"</span>);</span><br><span class="line">        System.out.print(<span class="string">"线"</span>);</span><br><span class="line">        System.out.print(<span class="string">"程"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 这两个方法时 同步的</p></li></ul><ul><li><p><code>静态同步函数</code>的锁是<code>字节码对象</code></p><ul><li>静态域随着类的加载而加载，此时会产生该类的字节码对象，所以<code>静态</code>同步方法锁对象<code>不能是this</code>，而是产生的<code>字节码对象</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   </span><br><span class="line">        System.out.print(<span class="string">"同"</span>);</span><br><span class="line">        System.out.print(<span class="string">"步"</span>);</span><br><span class="line">        System.out.print(<span class="string">"代"</span>);</span><br><span class="line">        System.out.print(<span class="string">"码"</span>);</span><br><span class="line">        System.out.print(<span class="string">"块"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span>  <span class="title">print2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//静态的同步方法的锁对象是随着类加载而产生的类的字节码对象</span></span><br><span class="line">    <span class="keyword">synchronized</span>(Customer.class)&#123;</span><br><span class="line">        System.out.print(<span class="string">"多"</span>);</span><br><span class="line">        System.out.print(<span class="string">"线"</span>);</span><br><span class="line">        System.out.print(<span class="string">"程"</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="同步方法和同步块，哪个是更好的选择"><a href="#同步方法和同步块，哪个是更好的选择" class="headerlink" title="同步方法和同步块，哪个是更好的选择"></a><strong>同步方法和同步块，哪个是更好的选择</strong></h3><ul><li>基本原则：<code>同步的范围越小越好</code>。</li><li>同步块之外的代码是异步执行的，比同步整个方法更有效率。</li></ul><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><ul><li><strong>如果你的代码在<code>多线程下</code>执行和在<code>单线程下</code>执行永远都能<code>获得一样的结果</code>，那么你的代码就是线程安全的</strong></li></ul><h3 id="线程安全级别"><a href="#线程安全级别" class="headerlink" title="线程安全级别"></a>线程安全级别</h3><ul><li><p>1、<strong>不可变</strong></p><p>像<code>String、Integer、Long</code>这些，都是<code>final类型</code>的类，任何一个线程<code>都改变不了它们的值</code>，要改变<code>除非新创建一个</code>，因此这些<code>不可变对象不需要任何同步手段</code>就可以<code>直接在多线程环境下使用</code> </p></li><li><p>2、<code>绝对</code>线程安全</p><p>不管运行时环境如何，调用者<code>都不需要额外的同步措施</code>。要做到这一点通常需要付出许多额外的代价，<code>Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的</code>。不过绝对线程安全的类，Java中也有，比方说<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code></p></li><li><p>3、<code>相对</code>线程安全</p><p>相对线程安全也就是我们<code>通常意义上</code>所说的<code>线程安全</code>，像<code>Vector</code>这种，<code>add、remove</code>方法都是<code>原子操作</code>，<code>不会被打断</code>，但也仅限于此，<code>如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException</code>，也就是<code>fail-fast机制</code>。</p></li><li><p>4、 线程<code>非安全</code> </p><p><code>ArrayList、LinkedList、HashMap</code>等都是<code>线程非安全的类</code></p></li></ul><h3 id="常见的线程安全类"><a href="#常见的线程安全类" class="headerlink" title="常见的线程安全类"></a>常见的线程安全类</h3><table><thead><tr><th>线程安全类</th><th>线程不安全类</th></tr></thead><tbody><tr><td>Vector</td><td>ArrayList</td></tr><tr><td>StringBuffer</td><td>StringBuilder</td></tr><tr><td>Hashtable</td><td>HashMap</td></tr><tr><td>…</td><td>LinkedList</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><ul><li><code>StringBuffer</code> 线程安全（其append方法中加了synchronized修饰</li><li>vector <code>add、remove</code>方法都是<code>原子操作</code>,加了synchronized修饰</li><li>但是<code>Collections</code>集合工具类中提供了静态方法<code>synchronizedXXX(XXX)</code>，分别<code>对应着线程不安全的那些集合类</code>，可以让他们<code>转换成线程安全</code>的集合，所以Vector类淘汰了…</li></ul><table><thead><tr><th>方法摘要</th><th>方法说明</th></tr></thead><tbody><tr><td><code>static     &lt;T&gt; Collection&lt;T&gt;</code></td><td><code>synchronizedCollection(Collection&lt;T&gt; c)</code>             返回指定 collection 支持的同步（线程安全的）collection。</td></tr><tr><td><code>static     &lt;T&gt; List&lt;T&gt;</code></td><td><code>synchronizedList(List&lt;T&gt; list)</code>             返回指定列表支持的同步（线程安全的）列表。</td></tr><tr><td><code>static     &lt;K,V&gt; Map&lt;K,V&gt;</code></td><td><code>synchronizedMap(Map&lt;K,V&gt; m)</code>             返回由指定映射支持的同步（线程安全的）映射。</td></tr><tr><td><code>static     &lt;T&gt; Set&lt;T&gt;</code></td><td><code>synchronizedSet(Set&lt;T&gt; s)</code>            返回指定  set 支持的同步（线程安全的）set。</td></tr><tr><td><code>static     &lt;K,V&gt; SortedMap&lt;K,V&gt;</code></td><td><code>synchronizedSortedMap(SortedMap&lt;K,V&gt; m)</code>             返回指定有序映射支持的同步（线程安全的）有序映射。</td></tr><tr><td><code>static     &lt;T&gt; SortedSet&lt;T&gt;</code></td><td><code>synchronizedSortedSet(SortedSet&lt;T&gt; s)</code>             返回指定有序 set 支持的同步（线程安全的）有序 set。</td></tr></tbody></table><h2 id="多线程中的线程安全问题"><a href="#多线程中的线程安全问题" class="headerlink" title="多线程中的线程安全问题"></a>多线程中的线程安全问题</h2><ul><li><p>多线程<code>并发操作同一共享数据</code>时，就会可能出现线程安全问题。</p></li><li><p>使用<code>同步技术</code>可以解决这种问题, 把<code>操作数据的代码进行同步</code>, 就不会多个线程同时执行</p></li></ul><h3 id="多窗口卖票问题"><a href="#多窗口卖票问题" class="headerlink" title="多窗口卖票问题"></a>多窗口卖票问题</h3><ul><li>如果不开启锁同步 ，就会出现卖出票号为负数的现象</li><li>在循环中使用锁同步，让各个线程进入循环之后进行同步，一个线程把ticketNum–后，其他线程再执行</li><li><p>使用Runnable方式实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizeTicketTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TicketSeller()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TicketSeller()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TicketSeller()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> TicketSeller()).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TicketSeller</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tikcetNum = <span class="number">10000</span>;<span class="comment">//总共10000张票，放到静态池中共享</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//在循环中使用锁同步，让各个线程进入循环之后进行同步，一个线程把ticketNum--后，其他线程再执行</span></span><br><span class="line">            <span class="keyword">synchronized</span>(TicketSeller.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tikcetNum &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//让线程睡10ms 如果不开启锁同步 就会出现票号为负数的现象</span></span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"...这是第"</span> + tikcetNum-- + <span class="string">"号票"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><ul><li>线程A和线程B相互等待对方持有的锁导致程序无限死循环下去 </li><li>线程<code>A持有锁H</code>并且<code>想获取锁W</code>，此时线程<code>B持有锁W</code>并且<code>想获取锁H</code>，那么这两个线程AB就会永远等待下去，产生最简单的死锁。</li><li><p>一个类可能发生死锁，并不意味着每次都会发生，往往在高并发、高负载的情况下，死锁出现概率高很多。</p></li><li><p>多线程同步的时候, 如果<code>同步代码嵌套, 使用相同锁</code>, 就有可能出现死锁</p></li></ul><h3 id="写一个死锁程序"><a href="#写一个死锁程序" class="headerlink" title="写一个死锁程序"></a>写一个死锁程序</h3><ul><li><p><code>哲学家进餐</code>问题，使用<code>同步代码块嵌套</code>，互相<code>先持有对方需要的锁对象</code></p></li><li><p>写一个死锁程序步骤：</p><ol><li>定义两个对象分别代表两个线程一开始就持有的锁对象</li><li>在run方法中使用 synchronized 同步代码块嵌套</li><li><code>外层synchronized锁对象</code>是<code>对方所需求的</code>，<code>自己所持有的</code>，<code>内层synchronized锁对象</code>是<code>对方所持有</code>，<code>自己所需要的</code> 。</li><li>当一个线程中的锁对象是自己持有的，还未走出外层代码块，<code>需要对方所持有的锁对象时</code>，cpu<code>调度到了另一个线程</code>，另一个线程正好也是这种情况，此时双方都持有了对方所需要的锁对象，发生了死锁。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String left = <span class="string">"left one"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String right = <span class="string">"right one"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (right)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"--持有了right,想得到left"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span>(left)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"--得到了left,可以开吃了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (left)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"--持有了left,想得到right"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span>(right)&#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName()+<span class="string">"--得到了right,可以开吃了"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            Thread-1--持有了left,想得到right</span></span><br><span class="line"><span class="comment">            Thread-0--持有了right,想得到left</span></span><br><span class="line"><span class="comment">            执行到此时，就会发现这两个线程的锁对象谁都不想放，就会产生死锁。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上方结果省略....</span><br><span class="line">Thread-1--持有了left,想得到right</span><br><span class="line">Thread-0--持有了right,想得到left</span><br></pre></td></tr></table></figure><p>  执行到此时，就会发现这两个线程的锁对象谁都不想放，就会产生死锁。</p></li></ul><h3 id="避免死锁的方式"><a href="#避免死锁的方式" class="headerlink" title="避免死锁的方式"></a><strong>避免死锁的方式</strong></h3><ul><li>注意和减少同步代码块嵌套问题</li><li>设计时考虑清楚锁的顺序，尽量<code>减少嵌套加锁交互数量</code></li><li>由于死锁是因为两个或多个线程之间无限时间等待对方持有的锁对象而形成的，那么给同步代码块加个等待时间限制。<ul><li>synchronized 关键字 不具备这个功能，使用<code>Lock类中的tryLock方法</code>，指定一个<code>超时时限</code>，在等待时，若超过该时限，就返回一个失败信息结束阻塞。</li></ul></li></ul><h2 id="单例模式的线程安全问题"><a href="#单例模式的线程安全问题" class="headerlink" title="单例模式的线程安全问题"></a>单例模式的线程安全问题</h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><ul><li>单例设计模式：保证一个类在内存中只有一个对象，内存唯一。</li><li>保证类在内存中只有一个对象：<ul><li>1、控制类的创建，不让其他类来创建本类的对象，将本类的构造函数私有private</li><li>2、在本类中定义一个本类的对象，并且外界无法修改。</li><li>3、在本类中提供一个唯一的公共访问方法，可获取本类的对象。</li></ul></li></ul><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><ul><li>在类中直接创建一个不可修改的对象引用，<code>不管有没有调用，都创建，空间换时间</code>。</li><li>饿汉式在多线程环境下是<code>线程安全</code>的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.将本类的构造函数私有private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2. 在本类中定义一个本类的对象，并且外界无法修改。</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//3. 在本类中提供一个唯一的公共访问方法，可获取本类的对象</span></span><br><span class="line">    <span class="comment">//饿汉式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种饿汉式，利用<code>final</code>直接修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.将本类的构造函数私有private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2. 在本类中定义一个本类的对象，并且外界无法修改。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton s = <span class="keyword">new</span> Singleton() ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><ul><li>在类中获取对象时加以判断，为空时才创建，即<code>用到该类对象时才创建</code>，时间换空间。</li><li>懒汉式单例模式在多线程下是<code>非线程安全</code>的。<ul><li>当线程A判断为null时，正准备new，此时，被另一个线程B抢占了CPU资源，线程B也判断为null，new了之后，第一个线程A又抢回了CPU资源，此时线程A又new了。此时这两个线程就new了两次，就不是唯一的内存引用了。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.将本类的构造函数私有private</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//2. 在本类中定义一个本类的对象，并且外界无法修改。</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> Singleton s ;</span><br><span class="line">    <span class="comment">//3. 在本类中提供一个唯一的公共访问方法，可获取本类的对象</span></span><br><span class="line">    <span class="comment">//懒汉式 对象引用为空 才创建，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//用到时创建，用不到时不创建</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>)</span><br><span class="line">             s = <span class="keyword">new</span> Singleton() ;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="饿汉式和懒汉式的区别"><a href="#饿汉式和懒汉式的区别" class="headerlink" title="饿汉式和懒汉式的区别"></a>饿汉式和懒汉式的区别</h4><ul><li>线程安全上：<ul><li>饿汉式线程安全，多线程下也不会创建多个对象</li><li>懒汉式非线程安全，多线程下可能会创建多个对象</li></ul></li><li>执行效果：<ul><li>饿汉式是 空间换时间，执行速度快。</li><li>懒汉式是 时间换空间，延迟加载。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaSE回顾&quot;&gt;&lt;a href=&quot;#JavaSE回顾&quot; class=&quot;headerlink&quot; title=&quot;JavaSE回顾&quot;&gt;&lt;/a&gt;JavaSE回顾&lt;/h1&gt;&lt;h2 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="JavaSE回顾" scheme="http://yoursite.com/categories/JavaSE%E5%9B%9E%E9%A1%BE/"/>
    
    
      <category term="Java多线程" scheme="http://yoursite.com/tags/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程安全" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
      <category term="死锁问题" scheme="http://yoursite.com/tags/%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Java8-Lambda表达式-函数式接口</title>
    <link href="http://yoursite.com/2018/05/13/Java%E5%86%85%E7%BD%AE%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2018/05/13/Java内置的四大核心函数式接口/</id>
    <published>2018-05-12T16:00:00.000Z</published>
    <updated>2018-07-12T11:56:11.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java内置的四大核心函数式接口"><a href="#1-Java内置的四大核心函数式接口" class="headerlink" title="1. Java内置的四大核心函数式接口"></a>1. Java内置的四大核心函数式接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;T&gt;  消费型接口 消费对象</span><br><span class="line">    void accept(T t);</span><br><span class="line">Supplier&lt;T&gt;  供给型接口 生成对象</span><br><span class="line">    T get();</span><br><span class="line">Function&lt;R,T&gt;  函数型接口 指定特定功能</span><br><span class="line">    R apply(T t);</span><br><span class="line">Predicate&lt;T&gt;  断言型接口 进行条件判断</span><br><span class="line">    boolean test(T t);</span><br></pre></td></tr></table></figure><h4 id="1-1-消费型接口"><a href="#1-1-消费型接口" class="headerlink" title="1.1. 消费型接口"></a>1.1. 消费型接口</h4><blockquote><p>void accept(T t);<br>Consumer<t> 消费型接口</t></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Consumer&lt;T&gt; 消费型接口</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConsumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//此时的（d） 小括号里有参数 </span></span><br><span class="line">        <span class="comment">//原因是因为 Consumer接口有参数 </span></span><br><span class="line">        <span class="comment">//void accept(T t);</span></span><br><span class="line">        </span><br><span class="line">        consume(<span class="number">1000</span>,(d)-&gt; System.out.println(d));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">(Integer n , Consumer&lt;Integer&gt; con)</span></span>&#123;</span><br><span class="line">        <span class="comment">//函数接口接收 消费 形参n</span></span><br><span class="line">        con.accept(n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-供给型接口"><a href="#1-2-供给型接口" class="headerlink" title="1.2. 供给型接口"></a>1.2. 供给型接口</h4><blockquote><p>Supplier<t>  供给型接口</t></p></blockquote><blockquote><p>T get(); 小括号无参数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Supplier&lt;T&gt;  供给型接口</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSupplier</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//T get(); 小括号无参数</span></span><br><span class="line">      List&lt;Integer&gt; numList = getNumList(<span class="number">10</span>,() -&gt; (<span class="keyword">int</span>)(Math.random()*<span class="number">101</span>));</span><br><span class="line">       <span class="keyword">for</span> ( Integer i: numList</span><br><span class="line">            ) &#123;</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//调用此方法时，第二个参数提供一个数字集合</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> n, Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">       List&lt;Integer&gt; numList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">           numList.add(sup.get()); <span class="comment">//通过get方法得到数字 存到numList</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> numList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-函数型接口"><a href="#1-3-函数型接口" class="headerlink" title="1.3. 函数型接口"></a>1.3. 函数型接口</h4><blockquote><p>Function&lt;R,T&gt;  函数型接口 特定功能</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Function&lt;R,T&gt;  函数型接口 特定功能</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//将字符串转成大写</span></span><br><span class="line">     String str1 = strHandler(<span class="string">"ghslkajh"</span>, (s) -&gt; s.toUpperCase());</span><br><span class="line">     System.out.println(str1);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// Function&lt;R,T&gt; 函数型接口</span></span><br><span class="line"> <span class="comment">//定义一个处理字符串功能型接口函数</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span>  String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String,String&gt; fun)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> fun.apply(str);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-断言型接口"><a href="#1-4-断言型接口" class="headerlink" title="1.4. 断言型接口"></a>1.4. 断言型接口</h4><blockquote><p>Predicate<t></t></p></blockquote><blockquote><p>boolean test(T t);   返回boolean</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//断言型接口  Predicate&lt;T&gt;</span></span><br><span class="line">   <span class="comment">// boolean test(T t);  返回boolean</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPredicate</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="comment">//返回长度大于3的字符串</span></span><br><span class="line">       List&lt;String&gt; s1 = strFilter(Arrays.asList(<span class="string">"huzhiqi"</span>, <span class="string">"adaad"</span>, <span class="string">"1231"</span>, <span class="string">"414441"</span>, <span class="string">"gagsgasg"</span>), (s) -&gt; s.length() &gt; <span class="number">3</span>);</span><br><span class="line">       System.out.println(s1); <span class="comment">//[huzhiqi, adaad, 1231, 414441, gagsgasg]</span></span><br><span class="line">       <span class="comment">//返回包含d的字符串</span></span><br><span class="line">       List&lt;String&gt; s2 = strFilter(Arrays.asList(<span class="string">"huzhiqi"</span>, <span class="string">"adaad"</span>, <span class="string">"1231"</span>, <span class="string">"414441"</span>, <span class="string">"gagsgasg"</span>), (s) -&gt; s.contains(<span class="string">"d"</span>));</span><br><span class="line">       System.out.println(s2); <span class="comment">// [adaad]</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//使用断言型接口过滤字符串</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">strFilter</span><span class="params">(List&lt;String&gt; strs, Predicate&lt;String&gt; pred)</span></span>&#123;</span><br><span class="line">       List&lt;String&gt;  list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (String s:strs</span><br><span class="line">            ) &#123;</span><br><span class="line">           <span class="comment">//利用断言型接口进行指定功能判断  即一个功能性条件判断</span></span><br><span class="line">           <span class="keyword">if</span>(pred.test(s))&#123;</span><br><span class="line">               <span class="comment">//过滤功能</span></span><br><span class="line">               list.add(s);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> list;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Java内置的四大核心函数式接口&quot;&gt;&lt;a href=&quot;#1-Java内置的四大核心函数式接口&quot; class=&quot;headerlink&quot; title=&quot;1. Java内置的四大核心函数式接口&quot;&gt;&lt;/a&gt;1. Java内置的四大核心函数式接口&lt;/h3&gt;&lt;figure
      
    
    </summary>
    
      <category term="Java8" scheme="http://yoursite.com/categories/Java8/"/>
    
    
      <category term="Java8" scheme="http://yoursite.com/tags/Java8/"/>
    
      <category term="Lambda表达式" scheme="http://yoursite.com/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="函数式接口" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java8-方法引用和构造器引用</title>
    <link href="http://yoursite.com/2018/05/12/Java8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/12/Java8-方法引用和构造器引用/</id>
    <published>2018-05-11T16:00:00.000Z</published>
    <updated>2018-07-13T00:55:41.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-方法引用"><a href="#1-方法引用" class="headerlink" title="1. 方法引用"></a>1. 方法引用</h3><blockquote><p>若lambda体中的内容有方法已经实现了，我们可以使用‘方法引用’，<br>可以理解为方法引用是lambda表达式的另外一种表现形式。双冒号形式<br>主要有三种语法格式</p></blockquote><p>使用要求（注意点）：</p><ul><li>Lambda体中调用方法的<code>参数列表、返回值类型</code> ，必须要<code>和接口实现方法</code>的参数列表、返回值<code>保持一致</code></li></ul><h4 id="1-1-对象-实例方法名"><a href="#1-1-对象-实例方法名" class="headerlink" title="1.1. 对象::实例方法名"></a>1.1. 对象::实例方法名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1. 对象::实例方法名</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);</span><br><span class="line">    con.accept(<span class="string">"hxh"</span>);<span class="comment">//hxh</span></span><br><span class="line">    </span><br><span class="line">    Consumer&lt;String&gt; con1 = System.out::println;</span><br><span class="line">    con1.accept(<span class="string">"hxh"</span>);<span class="comment">//hxh  结果一致</span></span><br><span class="line">    <span class="comment">//Consumer&lt;T&gt; 接口中的方法为：  void accept(T t);</span></span><br><span class="line">    <span class="comment">// println()方法实现为： public void println(String x) </span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处可以使用方法引用是因为 引用的方法println()的参数列表和返回值的类型  void println(String x) </span></span><br><span class="line"><span class="comment">     * 与 Consumer&lt;String&gt; 接口实现的方法中的 void accept(String t) 的参数列表和返回值的类型 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-类-静态方法名"><a href="#1-2-类-静态方法名" class="headerlink" title="1.2. 类::静态方法名"></a>1.2. 类::静态方法名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Supplier&lt;String&gt; sup = () -&gt; <span class="keyword">new</span> Object().toString();</span><br><span class="line">    System.out.println(sup.get()); <span class="comment">//java.lang.Object@7d6f77cc</span></span><br><span class="line"></span><br><span class="line">    Supplier&lt;String&gt; sup1 = <span class="keyword">new</span> Object()::toString;</span><br><span class="line">    System.out.println(sup1.get()); <span class="comment">// java.lang.Object@6f75e721</span></span><br><span class="line"></span><br><span class="line">    Supplier&lt;Double&gt; sup2 = () -&gt; Math.random();</span><br><span class="line">    System.out.println(sup2.get()); <span class="comment">// 0.3782071825902372</span></span><br><span class="line"></span><br><span class="line">    Supplier&lt;Double&gt; sup3 = Math::random;</span><br><span class="line">    System.out.println(sup3.get()); <span class="comment">// 0.1516143754943341</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-类-实例方法名"><a href="#1-3-类-实例方法名" class="headerlink" title="1.3. 类::实例方法名"></a>1.3. 类::实例方法名</h4><p>该类型使用条件：</p><ul><li>第一个参数是实例方法的调用者，第二个参数是实例方法的参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类::实例方法名</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//BiPredicate&lt;T,U&gt;  俩参数的断言型接口</span></span><br><span class="line">    BiPredicate&lt;String,String&gt;  bp = (x,y) -&gt; x.equals(y);</span><br><span class="line">    System.out.println(bp.test(<span class="string">"hxh"</span>,<span class="string">"hxh"</span>)); <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//(x,y) 括号里俩参数 第一个参数是调用方法对象，第二个参数是方法参数</span></span><br><span class="line">    BiPredicate&lt;String,String&gt;  bp1 =  String::equals;</span><br><span class="line">    System.out.println(bp1.test(<span class="string">"hxh"</span>, <span class="string">"aaj"</span>));<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-构造器引用"><a href="#2-构造器引用" class="headerlink" title="2. 构造器引用"></a>2. 构造器引用</h3><ul><li>构造器，创建对象，<code>自动匹配类中对应的构造器(参数不定)</code></li><li>需要调用的<code>构造器的参数列表</code>要和<code>函数式接口中的抽象方法参数列表</code>保持一致</li></ul><blockquote><p>语法： <code>ClassName::new;</code></p></blockquote><p>实体类 Stu<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(Integer id, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stu&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试用例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    Supplier&lt;Stu&gt; stuSupplier = ()-&gt; <span class="keyword">new</span> Stu();</span><br><span class="line">    System.out.println(stuSupplier.get());</span><br><span class="line">    <span class="comment">//自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（无参构造器）</span></span><br><span class="line">    Supplier&lt;Stu&gt; stuSupplier1 = Stu::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(stuSupplier1.get());</span><br><span class="line">    <span class="comment">//Stu&#123;id=null, name='null', age=null&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有一个参数的构造</span></span><br><span class="line">    Function&lt;Integer,Stu&gt; s1 = (x) -&gt; <span class="keyword">new</span> Stu(x);</span><br><span class="line">    System.out.println(s1.apply(<span class="number">1</span>)); <span class="comment">//Stu&#123;id=1, name='null', age=null&#125;</span></span><br><span class="line">    <span class="comment">//自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（单个Integer的构造器）</span></span><br><span class="line">    Function&lt;Integer,Stu&gt; s2 = Stu::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(s2.apply(<span class="number">2</span>)); <span class="comment">//Stu&#123;id=2, name='null', age=null&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有两个参数的构造  BiFunction&lt;T, U, R&gt;   R apply(T t, U u);</span></span><br><span class="line">    BiFunction&lt;Integer,Integer,Stu&gt; bf = (x,y) -&gt; <span class="keyword">new</span> Stu(x,y);</span><br><span class="line">    System.out.println(bf.apply(<span class="number">3</span>,<span class="number">44</span>)); <span class="comment">//Stu&#123;id=3, name='null', age=44&#125;</span></span><br><span class="line">    <span class="comment">//自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（两个个Integer的构造器）</span></span><br><span class="line">    BiFunction&lt;Integer,Integer,Stu&gt; bf1 = Stu::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(bf1.apply(<span class="number">4</span>,<span class="number">55</span>));<span class="comment">//Stu&#123;id=4, name='null', age=55&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-数组引用"><a href="#3-数组引用" class="headerlink" title="3. 数组引用"></a>3. 数组引用</h3><blockquote><p>语法： <code>Type[]::new;</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组引用  Type[]::new</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建指定长度的字符串数组</span></span><br><span class="line">    Function&lt;Integer,String[]&gt; f1 = (x) -&gt; <span class="keyword">new</span> String[x];</span><br><span class="line">    System.out.println(f1.apply(<span class="number">10</span>).length); <span class="comment">//10</span></span><br><span class="line">    Function&lt;Integer,String[]&gt; f2 = String[]::<span class="keyword">new</span>;<span class="comment">//数组引用 可以直接代替</span></span><br><span class="line">    System.out.println(f2.apply(<span class="number">20</span>).length); <span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-方法引用&quot;&gt;&lt;a href=&quot;#1-方法引用&quot; class=&quot;headerlink&quot; title=&quot;1. 方法引用&quot;&gt;&lt;/a&gt;1. 方法引用&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;若lambda体中的内容有方法已经实现了，我们可以使用‘方法引用’，&lt;br&gt;可
      
    
    </summary>
    
      <category term="Java8" scheme="http://yoursite.com/categories/Java8/"/>
    
    
      <category term="Java8" scheme="http://yoursite.com/tags/Java8/"/>
    
      <category term="方法引用" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    
      <category term="构造器引用" scheme="http://yoursite.com/tags/%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java8-方法引用和构造器引用</title>
    <link href="http://yoursite.com/2018/05/12/Java8%E6%96%B0%E7%89%B9%E6%80%A7-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8/"/>
    <id>http://yoursite.com/2018/05/12/Java8新特性-方法引用和构造器引用/</id>
    <published>2018-05-11T16:00:00.000Z</published>
    <updated>2018-07-12T10:37:37.018Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="1-方法引用"><a href="#1-方法引用" class="headerlink" title="1. 方法引用"></a>1. 方法引用</h3><blockquote><p>若lambda体中的内容有方法已经实现了，我们可以使用‘方法引用’，<br>可以理解为方法引用是lambda表达式的另外一种表现形式。双冒号形式<br>主要有三种语法格式</p></blockquote><p>使用要求（注意点）：</p><ul><li>Lambda体中调用方法的<code>参数列表、返回值类型</code> ，必须要<code>和接口实现方法</code>的参数列表、返回值<code>保持一致</code></li></ul><h4 id="1-1-对象-实例方法名"><a href="#1-1-对象-实例方法名" class="headerlink" title="1.1. 对象::实例方法名"></a>1.1. 对象::实例方法名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.1. 对象::实例方法名</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x);</span><br><span class="line">    con.accept(<span class="string">"hxh"</span>);<span class="comment">//hxh</span></span><br><span class="line">    </span><br><span class="line">    Consumer&lt;String&gt; con1 = System.out::println;</span><br><span class="line">    con1.accept(<span class="string">"hxh"</span>);<span class="comment">//hxh  结果一致</span></span><br><span class="line">    <span class="comment">//Consumer&lt;T&gt; 接口中的方法为：  void accept(T t);</span></span><br><span class="line">    <span class="comment">// println()方法实现为： public void println(String x) </span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处可以使用方法引用是因为 引用的方法println()的参数列表和返回值的类型  void println(String x) </span></span><br><span class="line"><span class="comment">     * 与 Consumer&lt;String&gt; 接口实现的方法中的 void accept(String t) 的参数列表和返回值的类型 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-2-类-静态方法名"><a href="#1-2-类-静态方法名" class="headerlink" title="1.2. 类::静态方法名"></a>1.2. 类::静态方法名</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Supplier&lt;String&gt; sup = () -&gt; <span class="keyword">new</span> Object().toString();</span><br><span class="line">    System.out.println(sup.get()); <span class="comment">//java.lang.Object@7d6f77cc</span></span><br><span class="line"></span><br><span class="line">    Supplier&lt;String&gt; sup1 = <span class="keyword">new</span> Object()::toString;</span><br><span class="line">    System.out.println(sup1.get()); <span class="comment">// java.lang.Object@6f75e721</span></span><br><span class="line"></span><br><span class="line">    Supplier&lt;Double&gt; sup2 = () -&gt; Math.random();</span><br><span class="line">    System.out.println(sup2.get()); <span class="comment">// 0.3782071825902372</span></span><br><span class="line"></span><br><span class="line">    Supplier&lt;Double&gt; sup3 = Math::random;</span><br><span class="line">    System.out.println(sup3.get()); <span class="comment">// 0.1516143754943341</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-类-实例方法名"><a href="#1-3-类-实例方法名" class="headerlink" title="1.3. 类::实例方法名"></a>1.3. 类::实例方法名</h4><p>该类型使用条件：</p><ul><li>第一个参数是实例方法的调用者，第二个参数是实例方法的参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类::实例方法名</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//BiPredicate&lt;T,U&gt;  俩参数的断言型接口</span></span><br><span class="line">    BiPredicate&lt;String,String&gt;  bp = (x,y) -&gt; x.equals(y);</span><br><span class="line">    System.out.println(bp.test(<span class="string">"hxh"</span>,<span class="string">"hxh"</span>)); <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//(x,y) 括号里俩参数 第一个参数是调用方法对象，第二个参数是方法参数</span></span><br><span class="line">    BiPredicate&lt;String,String&gt;  bp1 =  String::equals;</span><br><span class="line">    System.out.println(bp1.test(<span class="string">"hxh"</span>, <span class="string">"aaj"</span>));<span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-构造器引用"><a href="#2-构造器引用" class="headerlink" title="2. 构造器引用"></a>2. 构造器引用</h3><ul><li>构造器，创建对象，<code>自动匹配类中对应的构造器(参数不定)</code></li><li>需要调用的<code>构造器的参数列表</code>要和<code>函数式接口中的抽象方法参数列表</code>保持一致</li></ul><blockquote><p>语法： <code>ClassName::new;</code></p></blockquote><p>实体类 Stu<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stu</span><span class="params">(Integer id, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Stu&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试用例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//无参构造</span></span><br><span class="line">    Supplier&lt;Stu&gt; stuSupplier = ()-&gt; <span class="keyword">new</span> Stu();</span><br><span class="line">    System.out.println(stuSupplier.get());</span><br><span class="line">    <span class="comment">//自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（无参构造器）</span></span><br><span class="line">    Supplier&lt;Stu&gt; stuSupplier1 = Stu::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(stuSupplier1.get());</span><br><span class="line">    <span class="comment">//Stu&#123;id=null, name='null', age=null&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有一个参数的构造</span></span><br><span class="line">    Function&lt;Integer,Stu&gt; s1 = (x) -&gt; <span class="keyword">new</span> Stu(x);</span><br><span class="line">    System.out.println(s1.apply(<span class="number">1</span>)); <span class="comment">//Stu&#123;id=1, name='null', age=null&#125;</span></span><br><span class="line">    <span class="comment">//自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（单个Integer的构造器）</span></span><br><span class="line">    Function&lt;Integer,Stu&gt; s2 = Stu::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(s2.apply(<span class="number">2</span>)); <span class="comment">//Stu&#123;id=2, name='null', age=null&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有两个参数的构造  BiFunction&lt;T, U, R&gt;   R apply(T t, U u);</span></span><br><span class="line">    BiFunction&lt;Integer,Integer,Stu&gt; bf = (x,y) -&gt; <span class="keyword">new</span> Stu(x,y);</span><br><span class="line">    System.out.println(bf.apply(<span class="number">3</span>,<span class="number">44</span>)); <span class="comment">//Stu&#123;id=3, name='null', age=44&#125;</span></span><br><span class="line">    <span class="comment">//自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（两个个Integer的构造器）</span></span><br><span class="line">    BiFunction&lt;Integer,Integer,Stu&gt; bf1 = Stu::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(bf1.apply(<span class="number">4</span>,<span class="number">55</span>));<span class="comment">//Stu&#123;id=4, name='null', age=55&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-数组引用"><a href="#3-数组引用" class="headerlink" title="3. 数组引用"></a>3. 数组引用</h3><blockquote><p>语法： <code>Type[]::new;</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组引用  Type[]::new</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建指定长度的字符串数组</span></span><br><span class="line">    Function&lt;Integer,String[]&gt; f1 = (x) -&gt; <span class="keyword">new</span> String[x];</span><br><span class="line">    System.out.println(f1.apply(<span class="number">10</span>).length); <span class="comment">//10</span></span><br><span class="line">    Function&lt;Integer,String[]&gt; f2 = String[]::<span class="keyword">new</span>;<span class="comment">//数组引用 可以直接代替</span></span><br><span class="line">    System.out.println(f2.apply(<span class="number">20</span>).length); <span class="comment">//20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;1-方法引用&quot;&gt;&lt;a href=&quot;#1-方法引用&quot; class=&quot;headerlink&quot; title=&quot;1. 方法引用&quot;&gt;&lt;/a&gt;1. 方法引用&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;若lambda体中的内容有方法已经实现了，我们可以使
      
    
    </summary>
    
    
      <category term="Java8" scheme="http://yoursite.com/tags/Java8/"/>
    
      <category term="方法引用" scheme="http://yoursite.com/tags/%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8/"/>
    
      <category term="构造器引用" scheme="http://yoursite.com/tags/%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java8-StreamAPI常用知识</title>
    <link href="http://yoursite.com/2018/05/11/Java8-StreamAPI/"/>
    <id>http://yoursite.com/2018/05/11/Java8-StreamAPI/</id>
    <published>2018-05-10T16:00:00.000Z</published>
    <updated>2018-07-12T11:56:30.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流（Stream）"><a href="#流（Stream）" class="headerlink" title="流（Stream）"></a>流（Stream）</h1><h2 id="1-流的概念"><a href="#1-流的概念" class="headerlink" title="1. 流的概念"></a>1. 流的概念</h2><blockquote><p>流是<code>数据渠道</code>，用于<code>操作数据源</code>，所生成一种<code>新的元素序列</code>。集合讲的是数据，流讲的是<code>计算</code>,是<code>操作</code>。</p></blockquote><p>Stream是Java8中<code>处理集合</code>的关键抽象概念，它可以指定希望<code>对集合的操作</code>，可以执行复杂的<code>查找</code>、<code>过滤和映射数据</code>等操作。</p><p>使用Stream API <code>对集合的数据进行操作</code>，类似于<code>SQL执行的数据库查询</code>，也可以用来<code>并行执行</code>操作，其提供了一种高效且易于使用的<code>处理数据方式</code>。</p><p>注意点：</p><ul><li>Stream自身<code>不会存储元素</code></li><li>Stream<code>不会改变数据源对象</code>，相反会返回<code>产生一个持有结果的新Stream</code></li><li>Steam操作是<code>延迟执行</code>的，这意味着他们会<code>等到需要结果的时候才执行</code>。</li></ul><h2 id="2-流的操作步骤"><a href="#2-流的操作步骤" class="headerlink" title="2. 流的操作步骤"></a>2. 流的操作步骤</h2><p>三步走</p><h3 id="2-1-创建Stream"><a href="#2-1-创建Stream" class="headerlink" title="2.1. 创建Stream"></a>2.1. 创建Stream</h3><p>获取一个数据源（集合，数组），从而获取一个流<br>产生方式：</p><h4 id="2-1-1-通过Collection-系列集合提供的串行流：stream-、并行流：-paralleStream"><a href="#2-1-1-通过Collection-系列集合提供的串行流：stream-、并行流：-paralleStream" class="headerlink" title="2.1.1 通过Collection 系列集合提供的串行流：stream()、并行流： paralleStream()"></a>2.1.1 通过<code>Collection 系列集合</code>提供的<code>串行流：stream()</code>、<code>并行流： paralleStream()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; stream1 = list.stream();</span><br></pre></td></tr></table></figure><h4 id="2-1-2-通过Arrays中的静态方法stream-T-array-获取数组流"><a href="#2-1-2-通过Arrays中的静态方法stream-T-array-获取数组流" class="headerlink" title="2.1.2 通过Arrays中的静态方法stream(T[] array) 获取数组流"></a>2.1.2 通过<code>Arrays</code>中的<code>静态方法stream(T[] array)</code> 获取<code>数组流</code></h4><p>Arrays.stream(T[] array)的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> stream(array, <span class="number">0</span>, array.length);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>用例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Stu[] stus = <span class="keyword">new</span> Stu[<span class="number">10</span>];</span><br><span class="line">Stream&lt;Stu&gt; stream2 = Arrays.stream(stus);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) &#123;</span></span><br><span class="line"><span class="comment">     return stream(array, 0, array.length);</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="2-1-3-通过Stream类中的静态方法-of"><a href="#2-1-3-通过Stream类中的静态方法-of" class="headerlink" title="2.1.3 通过Stream类中的静态方法 of()"></a>2.1.3 通过<code>Stream类</code>中的静态方法 <code>of()</code></h4><p>Stream.of() 源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.单参泛型of</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(<span class="keyword">new</span> Streams.StreamBuilderImpl&lt;&gt;(t), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.可变参数</span></span><br><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"varargs"</span>) <span class="comment">// Creating a stream from an array is safe</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(values);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream3 = Stream.of(<span class="string">"hxh"</span>, <span class="string">"aj"</span>, <span class="string">"hhh"</span>);</span><br></pre></td></tr></table></figure></p><h4 id="2-1-4-使用Stream类的静态方法-iterate-创建无限流"><a href="#2-1-4-使用Stream类的静态方法-iterate-创建无限流" class="headerlink" title="2.1.4 使用Stream类的静态方法 iterate 创建无限流"></a>2.1.4 使用<code>Stream</code>类的静态方法 <code>iterate</code> 创建<code>无限流</code></h4><p>iterate方法：</p><p><code>Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f)</code></p><p>参数 <code>seed 种子起始值</code>，<code>UnaryOperator</code> 函数式接口 <code>继承Function&lt;T,T&gt;</code> 此时参数类型符合返回值类型一致</p><p>用例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//4.使用Stream类的静态方法 iterate 创建无限流</span><br><span class="line">//Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) </span><br><span class="line">//参数 seed 种子起始值，</span><br><span class="line">// UnaryOperator 函数式接口 继承Function&lt;T,T&gt; 此时参数类型符合返回值类型一致</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream4 = Stream.iterate(0, (x) -&gt; x + 2);</span><br><span class="line">//中间操作和终止操作</span><br><span class="line">stream4.limit(5).forEach(System.out::println);</span><br><span class="line">//0</span><br><span class="line">//2</span><br><span class="line">//4</span><br><span class="line">//6</span><br><span class="line">//8</span><br></pre></td></tr></table></figure></p><h4 id="2-1-5-使用Stream类的静态方法-generate创建无限流"><a href="#2-1-5-使用Stream类的静态方法-generate创建无限流" class="headerlink" title="2.1.5 使用Stream类的静态方法 generate创建无限流"></a>2.1.5 使用<code>Stream</code>类的静态方法 <code>generate</code>创建<code>无限流</code></h4><p>generate方法参数为<code>Supplier&lt;T&gt;</code> <code>供给型接口</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.使用Stream类的静态方法 generate 创建无限流</span></span><br><span class="line"><span class="comment">//参数为Supplier&lt;T&gt; 供给型接口</span></span><br><span class="line">Stream&lt;Double&gt; generateStream = Stream.generate(() -&gt; Math.random());</span><br><span class="line">generateStream.limit(<span class="number">5</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//0.4762976596937549</span></span><br><span class="line"><span class="comment">//0.08577913333772513</span></span><br><span class="line"><span class="comment">//0.32149010682857515</span></span><br><span class="line"><span class="comment">//0.31059489250233197</span></span><br><span class="line"><span class="comment">//0.45181354173159927</span></span><br></pre></td></tr></table></figure><h3 id="2-2-用Stream中间操作"><a href="#2-2-用Stream中间操作" class="headerlink" title="2.2. 用Stream中间操作"></a>2.2. 用Stream中间操作</h3><p>一个中间操作链，用Stream API 对数据源数据进行操作处理</p><p><strong>注意点</strong>：</p><ul><li>若只有中间操作，则<code>不会执行</code></li><li>只有终止操作执行后，所有的中间操作<code>一次执行</code>，此时就称为<code>延迟加载</code>或者<code>惰性求值</code></li></ul><blockquote><p>验证是否是延迟加载：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public  void test2()&#123;</span><br><span class="line">    //取age&gt;30的Stu元素</span><br><span class="line">    //若只有中间操作，则不会执行</span><br><span class="line">    Stream&lt;Stu&gt; stuStream = stuList.stream().filter((i) -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;验证是否是延迟加载&quot;);</span><br><span class="line">        return  i.getAge() &gt; 40;</span><br><span class="line">    &#125;);</span><br><span class="line">    //此时只有中间操作，无终止操作，无结果，控制台无输出</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时<code>只有中间操作，无终止操作</code>，<code>无结果，控制台无输出</code>。</p><p>此时加上终止操作后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//取age&gt;30的Stu元素</span></span><br><span class="line">    <span class="comment">//若只有中间操作，则不会执行</span></span><br><span class="line">    Stream&lt;Stu&gt; stuStream = stuList.stream().filter((i) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"验证是否是延迟加载"</span>);</span><br><span class="line">        <span class="keyword">return</span>  i.getAge() &gt; <span class="number">40</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//终止操作 执行后，所有的中间操作一次执行，此时就称为延迟加载或者惰性求值</span></span><br><span class="line">    stuStream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">验证是否是延迟加载</span><br><span class="line">验证是否是延迟加载</span><br><span class="line">验证是否是延迟加载</span><br><span class="line">验证是否是延迟加载</span><br><span class="line">Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;</span><br><span class="line">验证是否是延迟加载</span><br><span class="line">Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125;</span><br></pre></td></tr></table></figure><blockquote><p>结论：若只有中间操作，则不会执行中间操作。终止操作 执行后，所有的中间操作一次执行。最后流中只有经过操作过滤后的元素。</p></blockquote><h4 id="2-2-1-筛选与切片"><a href="#2-2-1-筛选与切片" class="headerlink" title="2.2.1 筛选与切片"></a>2.2.1 筛选与切片</h4><p><strong>迭代：</strong></p><ul><li>内部迭代：迭代过程操作由<code>Stream API 内部</code>自主完成，无需自行再次编写。</li><li>外部迭代：由<code>程序编写人员</code>自己通过一些迭代方法进行的迭代操作。</li></ul><h5 id="2-2-1-1-filter-过滤"><a href="#2-2-1-1-filter-过滤" class="headerlink" title="2.2.1.1 filter-过滤"></a>2.2.1.1 <code>filter</code>-过滤</h5><p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code><br><code>断言型</code>接口参数 即条件判断过滤</p><p><strong>用例：</strong><br>先创建一个Stu类List集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Stu&gt; stuList = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">1</span>,<span class="string">"hh"</span>,<span class="number">22</span>),</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">2</span>,<span class="string">"aa"</span>,<span class="number">22</span>),</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">3</span>,<span class="string">"bb"</span>,<span class="number">32</span>),</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">4</span>,<span class="string">"cc"</span>,<span class="number">42</span>),</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">5</span>,<span class="string">"dd"</span>,<span class="number">52</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>filter过滤实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取age&gt;30的Stu元素</span></span><br><span class="line"><span class="comment">//若只有中间操作，则不会执行</span></span><br><span class="line">Stream&lt;Stu&gt; stuStream = stuList.stream()</span><br><span class="line">    .filter((i) -&gt; i.getAge() &gt; <span class="number">40</span>);</span><br><span class="line"><span class="comment">//终止操作 执行后，所有的中间操作一次执行，此时就称为延迟加载或者惰性求值</span></span><br><span class="line">stuStream.forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;</span><br><span class="line">Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-2-1-2-limit-限定元素数量"><a href="#2-2-1-2-limit-限定元素数量" class="headerlink" title="2.2.1.2 limit-限定元素数量"></a>2.2.1.2 <code>limit</code>-限定元素数量</h5><p><code>limit(n)</code></p><p>通过<code>截断流</code>，使流中元素<code>个数不超过</code>指定数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stuList.stream()</span><br><span class="line">        .filter((s) -&gt;&#123;</span><br><span class="line">            System.out.println(<span class="string">"测试迭代几次"</span>);</span><br><span class="line">            <span class="keyword">return</span> s.getAge()&gt;<span class="number">40</span>;</span><br><span class="line">        &#125;).limit(<span class="number">1</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试迭代几次</span><br><span class="line">测试迭代几次</span><br><span class="line">测试迭代几次</span><br><span class="line">测试迭代几次</span><br><span class="line">Stu&#123;id=<span class="number">4</span>, name=<span class="string">'cc'</span>, age=<span class="number">42</span>&#125;</span><br></pre></td></tr></table></figure><p>结果发现：先通过filter()过滤，迭代到<code>想要的过滤结果后</code>，再根据<code>limit(n)</code>，直接<code>截断流</code>，后续操作不继续，限制其流中<code>元素个数为n</code>，此操作称为<code>短路</code>操作，短路操作也用于<code>提高效率</code>；</p><p>所以前3次元素不在结果中，但都进行迭代判断，打印了3次后后面的元素再次进行迭代，发现元素满足过滤条件，但limit限制只要一个，即最后一次迭代后直接截断流，结果为第一个满足过滤条件的元素。</p><h5 id="2-2-1-3-skip-跳过元素"><a href="#2-2-1-3-skip-跳过元素" class="headerlink" title="2.2.1.3 skip-跳过元素"></a>2.2.1.3 <code>skip</code>-跳过元素</h5><p><code>skip(n)</code> </p><p>返回一个<code>跳过前n个元素</code>的流，若流中<code>元素不足n个</code>，则返回一个<code>空流</code>。<br>其<code>与limit(n)互补</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//skip(n)  跳过前n个元素</span></span><br><span class="line">stuList.stream()</span><br><span class="line">    .skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">/* 结果：</span></span><br><span class="line"><span class="comment">    Stu&#123;id=3, name='bb', age=32&#125;</span></span><br><span class="line"><span class="comment">    Stu&#123;id=4, name='cc', age=42&#125;</span></span><br><span class="line"><span class="comment">    Stu&#123;id=5, name='dd', age=52&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">stuList.stream().skip(<span class="number">6</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//流中元素个数总数为5，小于6，则返回空流，没有结果值</span></span><br></pre></td></tr></table></figure><h5 id="2-2-1-4-distinct-去重"><a href="#2-2-1-4-distinct-去重" class="headerlink" title="2.2.1.4 distinct-去重"></a>2.2.1.4 <code>distinct</code>-去重</h5><ul><li>通过流所生成元素的<code>hashCode()</code>和<code>equals()</code>来去除<code>重复</code>元素</li></ul><p>先在stuList中添加几个重复元素用于测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Stu&gt; stuList = Arrays.asList(</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">1</span>,<span class="string">"hh"</span>,<span class="number">22</span>),</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">2</span>,<span class="string">"aa"</span>,<span class="number">22</span>),</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">3</span>,<span class="string">"bb"</span>,<span class="number">32</span>),</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">4</span>,<span class="string">"cc"</span>,<span class="number">42</span>),</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">4</span>,<span class="string">"cc"</span>,<span class="number">42</span>),</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">4</span>,<span class="string">"cc"</span>,<span class="number">42</span>),</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">4</span>,<span class="string">"cc"</span>,<span class="number">42</span>),</span><br><span class="line">        <span class="keyword">new</span> Stu(<span class="number">5</span>,<span class="string">"dd"</span>,<span class="number">52</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>此时的Stu类中没有生成重写<code>hashCode()</code>和<code>equals()</code>方法，测试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//distinct 去重</span></span><br><span class="line">stuList.stream().distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>但是结果发现，并没有去重:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;</span><br><span class="line">Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;</span><br><span class="line">Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;</span><br><span class="line">Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;</span><br><span class="line">Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;</span><br><span class="line">Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;</span><br><span class="line">Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;</span><br><span class="line">Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125;</span><br></pre></td></tr></table></figure></p><p>此时，在Stu类中生成重写<code>hashCode()</code>和<code>equals()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Stu stu = (Stu) o;</span><br><span class="line">    <span class="keyword">return</span> Objects.equals(id, stu.id) &amp;&amp;</span><br><span class="line">            Objects.equals(name, stu.name) &amp;&amp;</span><br><span class="line">            Objects.equals(age, stu.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Objects.hash(id, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次测试用例后，发现结果已经去重：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;</span><br><span class="line">Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;</span><br><span class="line">Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;</span><br><span class="line">Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;</span><br><span class="line">Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结论：</strong></p><blockquote><p>distinct()去重原理为通过流所生成元素的<code>hashCode()</code>和<code>equals()</code>来去除<code>重复</code>元素</p></blockquote><h4 id="2-2-2-映射"><a href="#2-2-2-映射" class="headerlink" title="2.2.2 映射"></a>2.2.2 映射</h4><h5 id="2-2-2-1-map映射"><a href="#2-2-2-1-map映射" class="headerlink" title="2.2.2.1  map映射"></a>2.2.2.1  map映射</h5><p><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></p><ul><li><code>接收Lambda</code>，将元素转换成<code>其他形式</code>或<code>提取信息</code>。</li><li>接收一个<code>Function&lt;? super T, ? extends R&gt; mapper函数</code>作为参数，该函数会<code>被应用到每个元素上</code>，并将其<code>映射到一个新的元素</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map映射</span></span><br><span class="line">List&lt;String&gt; stringList = Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>);</span><br><span class="line">stringList.stream()</span><br><span class="line">    .map((x)-&gt;x.length()).forEach(System.out::println);</span><br><span class="line">stringList.stream()</span><br><span class="line">    .map((x)-&gt;x.toUpperCase()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">AA</span><br><span class="line">BB</span><br><span class="line">CC</span><br><span class="line">DD</span><br></pre></td></tr></table></figure></p><p>从结果看出，流中的<code>每个元素</code>都应用了map()里的<code>参数中的Function函数</code>，并返回经过Function处理的元素。</p><ul><li>map映射的重要应用为：即类似<code>SQL中的映射</code>，<code>获取</code>对象中的<code>某些属性</code>（即数据库中的某些字段）</li></ul><p>例如：获取Stu中的name属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stuList.stream().map(Stu::getName).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>测试结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hh</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc</span><br><span class="line">cc</span><br><span class="line">cc</span><br><span class="line">cc</span><br><span class="line">dd</span><br></pre></td></tr></table></figure></p><h5 id="2-2-2-2-flatMap映射"><a href="#2-2-2-2-flatMap映射" class="headerlink" title="2.2.2.2  flatMap映射"></a>2.2.2.2  flatMap映射</h5><ul><li>接收一个<code>函数</code>作为参数，将流中的<code>每个值</code>都<code>转换成另一个流</code>，然后把<code>所有流连接成一个流</code>。每个部分流中的每个值成单独小流，再串成一个整体流。</li></ul><p><strong>对比map映射：</strong></p><ol><li>map映射是将集合中的<code>部分流添加到整体流中</code>，而flatMap映射是将集合中的<code>部分流中的每个元素单独一个个地添加到整体流中</code>。</li><li>map映射: <code>Stream&lt;Stream&lt;Character&gt;&gt;</code> , flatMap映射：<code>Stream&lt;Character&gt;</code></li></ol><p><strong>测试用例</strong>：</p><ol><li><p>写一个函数用于flatMap映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字符串拆分成字符后组成一个字符类型的流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">filterCharacter</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    List&lt;Character&gt; characterList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Character ch: str.toCharArray()</span><br><span class="line">         ) &#123;</span><br><span class="line">        characterList.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> characterList.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用该函数分别测试map映射类型和flatMap映射类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Arrays.asList(<span class="string">"aa"</span>, <span class="string">"bb"</span>, <span class="string">"cc"</span>, <span class="string">"dd"</span>);</span><br><span class="line">Stream&lt;Stream&lt;Character&gt;&gt; st1 = stringList.stream()</span><br><span class="line">    .map(TestStream::filterCharacter);</span><br><span class="line"><span class="comment">//此时流的内容为 &#123;&#123;"aa"&#125;,&#123;"bb"&#125;,&#123;"cc"&#125;,&#123;"dd"&#125;&#125; 4个单独的字符流对象组成的流</span></span><br><span class="line">st1.forEach(System.out::println);</span><br><span class="line"><span class="comment">/*  再次遍历后</span></span><br><span class="line"><span class="comment">    结果：4个流对象 即 Stream&lt;Character&gt;  &#123;&#123;"aa"&#125;,&#123;"bb"&#125;,&#123;"cc"&#125;,&#123;"dd"&#125;&#125;</span></span><br><span class="line"><span class="comment">    java.util.stream.ReferencePipeline$Head@470e2030</span></span><br><span class="line"><span class="comment">    java.util.stream.ReferencePipeline$Head@3fb4f649</span></span><br><span class="line"><span class="comment">    java.util.stream.ReferencePipeline$Head@33833882</span></span><br><span class="line"><span class="comment">    java.util.stream.ReferencePipeline$Head@200a570f</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Character&gt; st2 = stringList.stream().flatMap(TestStream::filterCharacter);</span><br><span class="line"><span class="comment">//此时流的内容为&#123;"a","a","b","b","c","c","d","d"&#125;</span></span><br><span class="line">st2.forEach(System.out::println);</span><br><span class="line"><span class="comment">/*  再次遍历后</span></span><br><span class="line"><span class="comment">    结果直接返回了单个的字符流</span></span><br><span class="line"><span class="comment">    a</span></span><br><span class="line"><span class="comment">    a</span></span><br><span class="line"><span class="comment">    b</span></span><br><span class="line"><span class="comment">    b</span></span><br><span class="line"><span class="comment">    c</span></span><br><span class="line"><span class="comment">    c</span></span><br><span class="line"><span class="comment">    d</span></span><br><span class="line"><span class="comment">    d</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="D:/info/note/pic/StreamAPI的map映射.png" alt="image"></p><p><img src="D:/info/note/pic/StreamAPI的flatmap映射.png" alt="image"></p><h4 id="2-2-3-排序"><a href="#2-2-3-排序" class="headerlink" title="2.2.3 排序"></a>2.2.3 排序</h4><h4 id="2-2-3-1-自然排序"><a href="#2-2-3-1-自然排序" class="headerlink" title="2.2.3.1 自然排序"></a>2.2.3.1 自然排序</h4><p><code>sorted()</code> </p><ul><li>自然排序(Comparable方式)，按照<code>字典顺序</code>进行排序</li><li>按照<code>实现的Comparable中的compare to()</code>方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = Arrays.asList(<span class="string">"ee"</span>, <span class="string">"bb"</span>, <span class="string">"ff"</span>, <span class="string">"dd"</span>,<span class="string">"哈哈"</span>,<span class="string">"啊"</span>);</span><br><span class="line"><span class="comment">//根据String类中Comparable方式进行默认排序，即compare to()方法</span></span><br><span class="line">stringList.stream()</span><br><span class="line">    .sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bb</span><br><span class="line">dd</span><br><span class="line">ee</span><br><span class="line">ff</span><br><span class="line">哈哈</span><br><span class="line">啊</span><br></pre></td></tr></table></figure></p><h4 id="2-2-3-2-指定排序"><a href="#2-2-3-2-指定排序" class="headerlink" title="2.2.3.2 指定排序"></a>2.2.3.2 指定排序</h4><p><code>sorted(Comparator com)</code> </p><ul><li>根据<code>实现Comparator接口的指定方法</code>进行排序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stuList.stream().sorted(</span><br><span class="line">            (a,b) -&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span> (a.getAge().equals(b.getAge()))&#123;</span><br><span class="line">                    <span class="keyword">return</span> a.getName().compareTo(b.getName());</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> a.getAge().compareTo(b.getAge());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    ).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="2-3-终止Stream操作"><a href="#2-3-终止Stream操作" class="headerlink" title="2.3. 终止Stream操作"></a>2.3. 终止Stream操作</h3><p>终止操作，<code>执行中间链操作</code>，并<code>产生结果</code></p><h4 id="2-3-1-查找与匹配"><a href="#2-3-1-查找与匹配" class="headerlink" title="2.3.1. 查找与匹配"></a>2.3.1. 查找与匹配</h4><ul><li>匹配 <code>match</code> <code>利用断言型函数接口</code>，返回<code>boolean值</code> 是否匹配</li><li>查找返回容器类  <code>Optional类型</code> <code>避免空指针异常</code></li></ul><h5 id="2-3-1-1-allMatch-检查是否匹配所有元素"><a href="#2-3-1-1-allMatch-检查是否匹配所有元素" class="headerlink" title="2.3.1.1 allMatch-检查是否匹配所有元素"></a>2.3.1.1 <code>allMatch</code>-检查是否<code>匹配所有</code>元素</h5><p>返回结果：</p><ul><li>true <code>匹配到了所有的元素</code>  注意：和noneMatch()的false 结果代表集合不同</li><li>false <code>没有匹配到所有的元素</code>  说明匹配到条件集合中的真子集 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b = stuList.stream()</span><br><span class="line">    .allMatch((e) -&gt; e.getAge() &gt; <span class="number">20</span>);</span><br><span class="line">System.out.println(b);<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b1 = stuList.stream()</span><br><span class="line">    .noneMatch((e) -&gt; e.getAge() &gt; <span class="number">20</span>);</span><br><span class="line">System.out.println(b1);<span class="comment">//flase</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b2 = stuList.stream()</span><br><span class="line">    .noneMatch((e) -&gt; e.getAge() &gt; <span class="number">40</span>);</span><br><span class="line">System.out.println(b2);<span class="comment">//flase</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-3-1-2-anyMatch-检查是否至少匹配一个元素"><a href="#2-3-1-2-anyMatch-检查是否至少匹配一个元素" class="headerlink" title="2.3.1.2 anyMatch-检查是否至少匹配一个元素"></a>2.3.1.2 <code>anyMatch</code>-检查是否<code>至少匹配一个</code>元素</h5><p>返回结果：</p><ul><li>true 匹配到了条件集合中的真子集元素，<code>一个或者多个</code></li><li>false 一个元素都没有匹配到，<code>空集</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> hhh = stuList.stream()</span><br><span class="line">    .anyMatch((e) -&gt; e.getName().equals(<span class="string">"hhh"</span>));</span><br><span class="line">System.out.println(hhh);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hh = stuList.stream()</span><br><span class="line">    .anyMatch((e) -&gt; e.getName().equals(<span class="string">"hh"</span>));</span><br><span class="line">System.out.println(hhh);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-3-1-3-noneMatch-检查是否所有元素都没有匹配到"><a href="#2-3-1-3-noneMatch-检查是否所有元素都没有匹配到" class="headerlink" title="2.3.1.3 noneMatch-检查是否所有元素都没有匹配到"></a>2.3.1.3 <code>noneMatch</code>-检查是否<code>所有元素都没有匹配到</code></h5><p>返回结果：</p><ul><li>true <code>所有元素都没有匹配到</code>，空集</li><li>false 不是所有的元素都没有匹配到 即<code>匹配到了元素</code>,有匹配到的元素即返回false，真子集<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b1 = stuList.stream()</span><br><span class="line">    .noneMatch((e) -&gt; e.getAge() &gt; <span class="number">20</span>);</span><br><span class="line">System.out.println(b1);<span class="comment">//flase</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b2 = stuList.stream()</span><br><span class="line">    .noneMatch((e) -&gt; e.getAge() &gt; <span class="number">40</span>);</span><br><span class="line">System.out.println(b2);<span class="comment">//flase</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b3 = stuList.stream()</span><br><span class="line">    .noneMatch((e) -&gt; e.getAge() &gt; <span class="number">50</span>);</span><br><span class="line">System.out.println(b3);<span class="comment">//此时集合中只有一个元素能匹配到，返回了false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b4 = stuList.stream()</span><br><span class="line">    .noneMatch((e) -&gt; e.getAge() &gt; <span class="number">60</span>);</span><br><span class="line">System.out.println(b3);<span class="comment">//所有的元素都没有匹配到  返回了true</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="2-3-1-4-findFirst-返回第一个元素"><a href="#2-3-1-4-findFirst-返回第一个元素" class="headerlink" title="2.3.1.4 findFirst-返回第一个元素"></a>2.3.1.4 <code>findFirst</code>-返回<code>第一个元素</code></h5><p><code>Optional&lt;T&gt; findFirst();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Stu&gt; first = stuList.stream().findFirst();</span><br><span class="line">System.out.println(first.get());<span class="comment">// Stu&#123;id=1, name='hh', age=22&#125;</span></span><br></pre></td></tr></table></figure><p>返回第一个元素，用<code>Optional</code>集合类来封装，<code>避免了空指针异常</code></p><h5 id="2-3-1-5-findAny-返回当前流中的任意一个元素"><a href="#2-3-1-5-findAny-返回当前流中的任意一个元素" class="headerlink" title="2.3.1.5 findAny-返回当前流中的任意一个元素"></a>2.3.1.5 <code>findAny</code>-返回当前流中的<code>任意一个元素</code></h5><p><code>Optional&lt;T&gt; findAny();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从集合中随便找个age&gt;30的Stu对象  可以使用串行流stream,也可以使用parallelStream 并行流</span></span><br><span class="line">Optional&lt;Stu&gt; any = stuList.parallelStream()</span><br><span class="line">    .filter((e) -&gt; e.getAge() &gt; <span class="number">30</span>).findAny();</span><br><span class="line">System.out.println(any.get());<span class="comment">//Stu&#123;id=4, name='cc', age=42&#125;</span></span><br><span class="line">Optional&lt;Stu&gt; any1 = stuList.stream()</span><br><span class="line">    .filter((e) -&gt; e.getAge() &gt; <span class="number">30</span>).findAny();</span><br><span class="line">System.out.println(any1.get());<span class="comment">//Stu&#123;id=3, name='bb', age=32&#125;</span></span><br></pre></td></tr></table></figure><h5 id="2-3-1-6-count-返回流中元素总个数"><a href="#2-3-1-6-count-返回流中元素总个数" class="headerlink" title="2.3.1.6 count-返回流中元素总个数"></a>2.3.1.6 <code>count</code>-返回流中<code>元素总个数</code></h5><p><code>long count();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = stuList.stream().count();</span><br><span class="line">System.out.println(count);<span class="comment">//8</span></span><br></pre></td></tr></table></figure><h5 id="2-3-1-7-max-返回流中的最大值"><a href="#2-3-1-7-max-返回流中的最大值" class="headerlink" title="2.3.1.7 max-返回流中的最大值"></a>2.3.1.7 <code>max</code>-返回流中的<code>最大值</code></h5><p><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据年龄大小进行正序排序找出最大值</span></span><br><span class="line">Optional&lt;Stu&gt; max = stuList.parallelStream()</span><br><span class="line">    .max((a, b) -&gt; Integer.compare(a.getAge(), b.getAge()));</span><br><span class="line">System.out.println(max.get()); <span class="comment">//Stu&#123;id=5, name='dd', age=52&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据年龄大小进行倒序排序找出最大值</span></span><br><span class="line">Optional&lt;Stu&gt; max1 = stuList.parallelStream()</span><br><span class="line">    .max((a, b) -&gt; Integer.compare(b.getAge(), a.getAge()));</span><br><span class="line">System.out.println(max1.get()); <span class="comment">//Stu&#123;id=1, name='hh', age=22&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//提取最大年龄 先映射提取集合中每个对象的年龄 再直接进行max方法比较 最后返回一个年龄值</span><br><span class="line">Optional&lt;Integer&gt; maxAge = stuList.parallelStream()</span><br><span class="line">    .map(Stu::getAge)</span><br><span class="line">    .max(Integer::compare);</span><br><span class="line">System.out.println(maxAge.get()); //52</span><br></pre></td></tr></table></figure><h5 id="2-3-1-8-min-返回流中的最小值"><a href="#2-3-1-8-min-返回流中的最小值" class="headerlink" title="2.3.1.8 min-返回流中的最小值"></a>2.3.1.8 <code>min</code>-返回流中的<code>最小值</code></h5><p><code>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据年龄大小进行正序排序找出最小值</span></span><br><span class="line">Optional&lt;Stu&gt; min = stuList.parallelStream()</span><br><span class="line">    .min((a, b) -&gt; Integer.compare(a.getAge(), b.getAge()));</span><br><span class="line">System.out.println(min.get());<span class="comment">//Stu&#123;id=1, name='hh', age=22&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据年龄大小进行倒序排序找出最小值</span></span><br><span class="line">Optional&lt;Stu&gt; min1 = stuList.parallelStream()</span><br><span class="line">    .min((a, b) -&gt;  Integer.compare(b.getAge(), a.getAge()));</span><br><span class="line">System.out.println(min1.get()); <span class="comment">//Stu&#123;id=5, name='dd', age=52&#125;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-2-归约与收集"><a href="#2-3-2-归约与收集" class="headerlink" title="2.3.2. 归约与收集"></a>2.3.2. 归约与收集</h4><h5 id="2-3-2-1-reduce-将流中元素反复结合起来，得到一个值"><a href="#2-3-2-1-reduce-将流中元素反复结合起来，得到一个值" class="headerlink" title="2.3.2.1 reduce-将流中元素反复结合起来，得到一个值"></a>2.3.2.1 <code>reduce</code>-将流中<code>元素反复结合</code>起来，<code>得到一个值</code></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment">//利用reduce归约函数，可以指定归约规则，将集合中的元素数值进行求和操作等</span></span><br><span class="line"><span class="comment">//以0为起始值，对集合中的各个值进行相加</span></span><br><span class="line">Integer sum = list.stream().reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">System.out.println(sum);<span class="comment">//45</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//求出stuList集合中的年龄总和</span></span><br><span class="line"><span class="comment">//此时利用Integer类中的静态方法sum求和 无起始值，有可能为空，</span></span><br><span class="line"><span class="comment">// 则返回值自动变为Optional容器类封装过后的值</span></span><br><span class="line">Optional&lt;Integer&gt; ageSumOp = stuList.stream()</span><br><span class="line">    .map(Stu::getAge)</span><br><span class="line">    .reduce(Integer::sum);</span><br><span class="line">System.out.println(ageSumOp.get());<span class="comment">//296</span></span><br></pre></td></tr></table></figure><ul><li>此时利用Integer类中的静态方法sum求和 无起始值,<code>有可能为空</code>，则<code>返回值自动变为Optional容器类封装过后的值</code></li></ul><h5 id="2-3-2-2-collect-将流转换为其他形式"><a href="#2-3-2-2-collect-将流转换为其他形式" class="headerlink" title="2.3.2.2 collect-将流转换为其他形式"></a>2.3.2.2 <code>collect</code>-将<code>流转换为其他形式</code></h5><ul><li>接收一个<code>Collector</code>接口的实现，用于Stream中元素做<code>汇总的方法</code></li><li>利用<code>Collectors</code>实用工具类中提供的很多<code>静态实现Collector接口的方法</code>，进行相应的转换收集操作。</li><li></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收集stuList集合中的所有name值，转换为list集合</span></span><br><span class="line">List&lt;String&gt; nameList = stuList.stream().map(Stu::getName)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">nameList.forEach(System.out::println);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    结果： </span></span><br><span class="line"><span class="comment">    hh</span></span><br><span class="line"><span class="comment">    aa</span></span><br><span class="line"><span class="comment">    bb</span></span><br><span class="line"><span class="comment">    cc</span></span><br><span class="line"><span class="comment">    cc</span></span><br><span class="line"><span class="comment">    cc</span></span><br><span class="line"><span class="comment">    cc</span></span><br><span class="line"><span class="comment">    dd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//获取年龄转化成set集合 去掉了重复值</span></span><br><span class="line">Set&lt;Integer&gt; ageSet = stuList.stream().map(Stu::getAge)</span><br><span class="line">    .collect(Collectors.toSet());</span><br><span class="line">ageSet.forEach(System.out::println);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     结果：</span></span><br><span class="line"><span class="comment">    32</span></span><br><span class="line"><span class="comment">    52</span></span><br><span class="line"><span class="comment">    22</span></span><br><span class="line"><span class="comment">    42</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>如果想转换成<code>其他没有的现成静态方法</code>的数据结构集合，就使用<code>Collectors.toCollection()</code>方法，该方法具体参数和返回值为：<code>Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</code></li></ul><p>使用<code>Collectors.toCollection(HashSet::new)</code>方法 转换成<code>HashSet</code>集合,该方法<code>参数为Supplier供给型</code>函数接口，传给一个<code>构造函数</code>， 用例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用`Collectors.toCollection()`方法 转换成`其他没有的现成静态方法`的数据结构集合 比如HashSet</span></span><br><span class="line">HashSet&lt;String&gt; nameHashSet = stuList.stream().map(Stu::getName)</span><br><span class="line">    .collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">nameHashSet.forEach(System.out::println);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    result:</span></span><br><span class="line"><span class="comment">    hh</span></span><br><span class="line"><span class="comment">    aa</span></span><br><span class="line"><span class="comment">    bb</span></span><br><span class="line"><span class="comment">    cc</span></span><br><span class="line"><span class="comment">    dd</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="2-3-3-Collectors类中的常用方法"><a href="#2-3-3-Collectors类中的常用方法" class="headerlink" title="2.3.3. Collectors类中的常用方法"></a>2.3.3. <code>Collectors</code>类中的常用方法</h4><h5 id="2-3-3-1-counting-统计数量"><a href="#2-3-3-1-counting-统计数量" class="headerlink" title="2.3.3.1 counting-统计数量"></a>2.3.3.1 <code>counting</code>-统计数量</h5><p><code>Long count()</code>  统计元素个数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Long count = stuList.stream()</span><br><span class="line">        .collect(Collectors.counting());</span><br><span class="line">System.out.println(count);<span class="comment">//8</span></span><br></pre></td></tr></table></figure></p><h5 id="2-3-3-2-averagingDouble-求平均值并转换成Double类型"><a href="#2-3-3-2-averagingDouble-求平均值并转换成Double类型" class="headerlink" title="2.3.3.2 averagingDouble-求平均值并转换成Double类型"></a>2.3.3.2 <code>averagingDouble</code>-求平均值并转换成Double类型</h5><p><code>&lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code></p><p><code>&lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper)</code></p><p><code>&lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper)</code></p><p>测试用例：求年龄的平均值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Double ageAve = stuList.stream()</span><br><span class="line">            .collect(Collectors.averagingDouble(Stu::getAge));</span><br><span class="line">System.out.println(ageAve);<span class="comment">//37.0</span></span><br></pre></td></tr></table></figure></p><h5 id="2-3-3-3-summingDouble-求和并转换成Double类型"><a href="#2-3-3-3-summingDouble-求和并转换成Double类型" class="headerlink" title="2.3.3.3 summingDouble-求和并转换成Double类型"></a>2.3.3.3 <code>summingDouble</code>-求和并转换成Double类型</h5><p><code>&lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper)</code></p><p><code>&lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper)</code></p><p><code>&lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code></p><p>测试用例：求年龄之和<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Double ageSum = stuList.stream()</span><br><span class="line">        .collect(Collectors.summingDouble(Stu::getAge));</span><br><span class="line">System.out.println(ageSum);<span class="comment">//296.0</span></span><br></pre></td></tr></table></figure></p><h5 id="2-3-3-4-maxBy-根据函数条件求最大值"><a href="#2-3-3-4-maxBy-根据函数条件求最大值" class="headerlink" title="2.3.3.4 maxBy-根据函数条件求最大值"></a>2.3.3.4 <code>maxBy</code>-根据函数条件求最大值</h5><p><code>&lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt;  maxBy(Comparator&lt;? super T&gt; comparator)</code></p><p>测试用例：根据年龄找出最大年龄值的stu对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据年龄找出最大年龄值的stu对象</span></span><br><span class="line">Optional&lt;Stu&gt; stuOptional = stuList.stream()</span><br><span class="line">        .collect(Collectors.maxBy((a, b) -&gt; Double.compare(a.getAge(), b.getAge())));</span><br><span class="line">System.out.println(stuOptional.get());<span class="comment">//Stu&#123;id=5, name='dd', age=52&#125;</span></span><br></pre></td></tr></table></figure></p><h5 id="2-3-3-5-groupingBy-分组"><a href="#2-3-3-5-groupingBy-分组" class="headerlink" title="2.3.3.5 groupingBy-分组"></a>2.3.3.5 <code>groupingBy</code>-分组</h5><ul><li><code>单级分组</code> <code>&lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;  groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code></li></ul><p>测试用例：根据年龄分组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据年龄分组</span></span><br><span class="line">Map&lt;Integer, List&lt;Stu&gt;&gt; ageGroup = stuList.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(Stu::getAge));</span><br><span class="line">System.out.println(ageGroup);</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;32=[Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;],</span><br><span class="line">52=[Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125;],</span><br><span class="line">22=[Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;, Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;],</span><br><span class="line">42=[Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;]&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>多级分组</code> 两个参数，<code>第二个参数为Collector</code>，即实现无限分组<br><code>&lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream)</code></li></ul><p>先根据name分组，再根据年龄分组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先根据name分组，再根据年龄分组</span></span><br><span class="line">Map&lt;String, Map&lt;String, List&lt;Stu&gt;&gt;&gt; groupmap = stuList.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(Stu::getName, Collectors.groupingBy((e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getAge() &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"年轻人"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e.getAge() &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"中年人"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"老年人"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)));</span><br><span class="line">System.out.println(groupmap);</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;dd=&#123;老年人=[Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125;]&#125;,</span><br><span class="line"> cc=&#123;中年人=[Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;]&#125;,</span><br><span class="line"> bb=&#123;中年人=[Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;]&#125;,</span><br><span class="line"> aa=&#123;中年人=[Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;]&#125;,</span><br><span class="line"> hh=&#123;中年人=[Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-3-3-6-partitioningBy-分区"><a href="#2-3-3-6-partitioningBy-分区" class="headerlink" title="2.3.3.6 partitioningBy-分区"></a>2.3.3.6 <code>partitioningBy</code>-分区</h5><p><code>满足条件</code>的分到一个区，<code>不满足条件</code>分到另一个区</p><p><code>true , false</code>  <code>Map&lt;Boolean,List&lt;&gt;&gt;</code></p><p>测试用例：是否年龄大于40，分两个区<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Stu&gt;&gt; booleamGroup = stuList.stream()</span><br><span class="line">    .collect(Collectors.partitioningBy((e) -&gt; e.getAge() &gt; <span class="number">40</span>));</span><br><span class="line">System.out.println(booleamGroup);</span><br></pre></td></tr></table></figure></p><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    false=[</span><br><span class="line">        Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;,</span><br><span class="line">        Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;,</span><br><span class="line">        Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;</span><br><span class="line">        ],</span><br><span class="line">    true=[</span><br><span class="line">        Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;,</span><br><span class="line">        Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;,</span><br><span class="line">        Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;,</span><br><span class="line">        Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;,</span><br><span class="line">        Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125;</span><br><span class="line">         ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="2-3-3-7-summarizingDouble-计算方法总括函数"><a href="#2-3-3-7-summarizingDouble-计算方法总括函数" class="headerlink" title="2.3.3.7 summarizingDouble-计算方法总括函数"></a>2.3.3.7 <code>summarizingDouble</code>-计算方法总括函数</h5><p><code>&lt;T&gt;  Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code></p><p><code>summarizingDouble</code><br>返回 <code>DoubleSummaryStatistics</code> 类型 可以直接调用各种计算方法</p><p><code>summarizingInt</code></p><p><code>summarizingLong</code></p><p>实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DoubleSummaryStatistics ageSummaryStatis = stuList.stream()</span><br><span class="line">    .collect(Collectors.summarizingDouble(Stu::getAge));</span><br><span class="line">ageSummaryStatis.getAverage();</span><br><span class="line">ageSummaryStatis.getCount();</span><br><span class="line">ageSummaryStatis.getMax();</span><br><span class="line">ageSummaryStatis.getMin();</span><br><span class="line">ageSummaryStatis.getSum();</span><br></pre></td></tr></table></figure></p><h5 id="2-3-3-7-joining-连接字符串"><a href="#2-3-3-7-joining-连接字符串" class="headerlink" title="2.3.3.7 joining-连接字符串"></a>2.3.3.7 <code>joining</code>-连接字符串</h5><p><code>Collector&lt;CharSequence, ?, String&gt; joining()</code></p><p>测试用例：将stuList集合中所有的名字连接在一起<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将集合中所有的名字连接在一起</span></span><br><span class="line">String allNameStr = stuList.stream().map(Stu::getName)</span><br><span class="line">    .collect(Collectors.joining());</span><br><span class="line">System.out.println(allNameStr);<span class="comment">//hhaabbccccccccdd</span></span><br></pre></td></tr></table></figure></p><p>测试用例：将stuList集合中所有的名字连接在一起，并使用逗号分割</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//将集合中所有的名字连接在一起,并逗号分割</span></span><br><span class="line">String allNameStr1 = stuList.stream().map(Stu::getName)</span><br><span class="line">    .collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">System.out.println(allNameStr1);</span><br><span class="line"><span class="comment">//hh,aa,bb,cc,cc,cc,cc,dd</span></span><br></pre></td></tr></table></figure><h5 id="2-3-3-8-toList-返回集合"><a href="#2-3-3-8-toList-返回集合" class="headerlink" title="2.3.3.8 toList- 返回集合"></a>2.3.3.8 <code>toList</code>- 返回集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List kcResList = kcResInKkxyList.stream().filter((e) -&gt; kssj.equals(e.getKssj())).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;流（Stream）&quot;&gt;&lt;a href=&quot;#流（Stream）&quot; class=&quot;headerlink&quot; title=&quot;流（Stream）&quot;&gt;&lt;/a&gt;流（Stream）&lt;/h1&gt;&lt;h2 id=&quot;1-流的概念&quot;&gt;&lt;a href=&quot;#1-流的概念&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Java8" scheme="http://yoursite.com/categories/Java8/"/>
    
    
      <category term="Java8" scheme="http://yoursite.com/tags/Java8/"/>
    
      <category term="StreamAPI" scheme="http://yoursite.com/tags/StreamAPI/"/>
    
  </entry>
  
  <entry>
    <title>Java8-Lambda表达式基础知识</title>
    <link href="http://yoursite.com/2018/05/11/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/05/11/Lambda表达式基础语法/</id>
    <published>2018-05-10T16:00:00.000Z</published>
    <updated>2018-07-12T11:56:06.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><blockquote><p>Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递），其可以代替实现接口中的抽象方法时的书写匿名内部类的繁琐代码。</p></blockquote><p><strong>举个栗子：</strong></p><p>Java中有个Runnable接口，直接使用该接口，需要重写实现其接口内部中的抽象方法。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"old run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">run.run();</span><br></pre></td></tr></table></figure><p>该代码可以使用lambda表达式简化为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Runnable run1 = () -&gt; System.out.println(<span class="string">"lambda run"</span>);</span><br><span class="line">run1.run();</span><br></pre></td></tr></table></figure></p><h3 id="1-基础语法"><a href="#1-基础语法" class="headerlink" title="1. 基础语法"></a>1. 基础语法</h3><blockquote><p> java8中引入了一个新的操作符”-&gt;”，该操作符称为箭头操作符或Lambda操作符，该箭头符号将整个Lambda表达式拆分成两部分：</p></blockquote><blockquote><p>左侧：Lambda表达式的参数列表，即接口中对应抽象方法的参数列表。</p></blockquote><blockquote><p>右侧：Lambda表达式中所需要执行的功能，即Lambda表达式体。即需要实现的抽象方法的功能体。</p></blockquote><h4 id="1-1-语法格式一-无参数-无返回值"><a href="#1-1-语法格式一-无参数-无返回值" class="headerlink" title="1.1. 语法格式一 无参数,无返回值"></a>1.1. 语法格式一 无参数,无返回值</h4><blockquote><p>对应格式为:   () -&gt; 方法体…   括号内无参数</p></blockquote><blockquote><p>例如:() -&gt; Sysout…</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//无参数 , 无返回值 对应格式为: () -&gt; 方法体...   括号内无参数</span></span><br><span class="line">    Runnable run = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"old run"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    run.run();</span><br><span class="line">    System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">    Runnable run1 = () -&gt; System.out.println(<span class="string">"lambda run"</span>);</span><br><span class="line">    run1.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*result:</span></span><br><span class="line"><span class="comment">    old run</span></span><br><span class="line"><span class="comment">    -----------</span></span><br><span class="line"><span class="comment">    lambda run</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="1-2-语法格式二-有一个参数-无返回值"><a href="#1-2-语法格式二-有一个参数-无返回值" class="headerlink" title="1.2. 语法格式二 有一个参数,无返回值"></a>1.2. 语法格式二 有一个参数,无返回值</h4><blockquote><p>对应语法格式为 (x) -&gt; 无返回值的方法体</p></blockquote><blockquote><p>例如: (x) -&gt; System.out.println(x)</p></blockquote><blockquote><p>若有且只有一个参数,左侧的小括号可以省略不写</p></blockquote><blockquote><p>例如:  x -&gt; System.out.println(x)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有一个参数 , 无返回值</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Consumer&lt;String&gt; consumer = (s) -&gt; list.add(s);<span class="comment">//将consumer接收到的对象进行具体的功能的消费</span></span><br><span class="line">    consumer.accept(<span class="string">"ddd"</span>);</span><br><span class="line">    consumer.accept(<span class="string">"aaa"</span>);</span><br><span class="line">    consumer.accept(<span class="string">"ccc"</span>);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Result:</span></span><br><span class="line"><span class="comment">            ddd</span></span><br><span class="line"><span class="comment">            aaa</span></span><br><span class="line"><span class="comment">            ccc</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-语法格式三-有两个或两个以上参数-有返回值"><a href="#1-3-语法格式三-有两个或两个以上参数-有返回值" class="headerlink" title="1.3. 语法格式三 有两个或两个以上参数,有返回值"></a>1.3. 语法格式三 有两个或两个以上参数,有返回值</h4><blockquote><p>有两个或两个以上参数,有返回值,并且 lambda 体中有多条语句</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法为: </span><br><span class="line">(x,y) -&gt; &#123;</span><br><span class="line">    方法体</span><br><span class="line">    return 返回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">多条语句必须使用大括号包括在内,</span><br><span class="line">有返回值,需要使用return 返回返回值.</span><br><span class="line"> Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;x为&quot;+x);</span><br><span class="line">    System.out.println(&quot;y为&quot;+y);</span><br><span class="line">    return Integer.compare(x,y);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如果lambda体中只有一条语句,</span><br><span class="line">那么大括号&#123;&#125;可以省略,</span><br><span class="line">return关键字也可以省略</span><br><span class="line"></span><br><span class="line">例如: </span><br><span class="line">Comparator&lt;Integer&gt; com = (x,y) -&gt; &#123;</span><br><span class="line">    return Integer.compare(x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">就可以简写成:</span><br><span class="line"></span><br><span class="line">Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y);</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> Lambda表达式的参数列表的 数据类型可以省略不写,</span><br><span class="line">因为JVM编译器可以通过上下文推断出数据类型,即&apos;类型推断&apos;.</span><br><span class="line"></span><br><span class="line">即: </span><br><span class="line">(Integer x,Integer y) -&gt; Integer.compare(x,y);</span><br><span class="line"></span><br><span class="line">简化成:</span><br><span class="line">(x,y) -&gt; Integer.compare(x,y);</span><br></pre></td></tr></table></figure><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"x为"</span>+x);</span><br><span class="line">        System.out.println(<span class="string">"y为"</span>+y);</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(x,y);</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(com.compare(<span class="number">1111</span>,<span class="number">111</span>));</span><br><span class="line">    <span class="comment">// x为1111</span></span><br><span class="line">    <span class="comment">// y为111</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用用Java内置的Comparator接口（比较器）比较两个字符串的长度，可用lambda表达式表示为：</p><blockquote><p>使用Lambda表达式直接进行该接口的核心方法体的重写</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Lambda表达式直接进行该接口的核心方法体的重写</span></span><br><span class="line">Comparator&lt;String&gt; com1 = (x,y) -&gt;  &#123;</span><br><span class="line">    <span class="keyword">if</span>(x.length() == y.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x.length() &gt; y.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(com1.compare(<span class="string">"aa"</span>,<span class="string">"aaaaa"</span>));<span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h3 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2. 函数式接口"></a>2. 函数式接口</h3><blockquote><p>Lambda表达式需要函数式接口的支持</p></blockquote><blockquote><p>函数式接口定义: 接口中只有一个抽象方法的接口,称为函数式接口。</p></blockquote><blockquote><p>可以使用注解 @FuncitonalInterface 修饰，其修饰作用为：限定该接口必须为函数式接口,即该接口中有且只有一个抽象方法。否则无法通过编译。即可以检查是否为函数式接口。</p></blockquote><h4 id="2-1-自定义一个函数式接口："><a href="#2-1-自定义一个函数式接口：" class="headerlink" title="2.1. 自定义一个函数式接口："></a>2.1. 自定义一个函数式接口：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operation</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">operation</span><span class="params">(T t1, T t2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-1-方案一：写具体实现方法再直接使用"><a href="#2-1-1-方案一：写具体实现方法再直接使用" class="headerlink" title="2.1.1 方案一：写具体实现方法再直接使用"></a>2.1.1 方案一：写具体实现方法再直接使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">op</span> <span class="params">(Long l1, Long l2, Operation&lt;Long,Long&gt; operation)</span></span>&#123;</span><br><span class="line">        System.out.println(operation.operation(l1,l2));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    op(<span class="number">10l</span>,<span class="number">10l</span>,(x,y) -&gt; x*y);<span class="comment">//100</span></span><br><span class="line">    op(<span class="number">100l</span>,<span class="number">200l</span>,(x,y)-&gt; x+y);<span class="comment">//300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-方案二：-先使用lambda表示具体实现方法体，再进行接口中的方法调用，传入具体值："><a href="#2-1-2-方案二：-先使用lambda表示具体实现方法体，再进行接口中的方法调用，传入具体值：" class="headerlink" title="2.1.2 方案二： 先使用lambda表示具体实现方法体，再进行接口中的方法调用，传入具体值："></a>2.1.2 方案二： 先使用lambda表示具体实现方法体，再进行接口中的方法调用，传入具体值：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Operation&lt;Integer,Integer&gt;  op = (x,y) -&gt; x*y;</span><br><span class="line">    System.out.println(op.operation(<span class="number">10</span>,<span class="number">10</span>));  <span class="comment">//100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实际使用时，大多数情况下直接使用Java8内置四大函数式接口，并不要进行自己写函数式接口。</p></blockquote><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lambda表达式&quot;&gt;&lt;a href=&quot;#Lambda表达式&quot; class=&quot;headerlink&quot; title=&quot;Lambda表达式&quot;&gt;&lt;/a&gt;Lambda表达式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Lambda是一个匿名函数，我们可以把Lambda表达式理
      
    
    </summary>
    
      <category term="Java8" scheme="http://yoursite.com/categories/Java8/"/>
    
    
      <category term="Java8" scheme="http://yoursite.com/tags/Java8/"/>
    
      <category term="Lambda表达式" scheme="http://yoursite.com/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git基础知识</title>
    <link href="http://yoursite.com/2018/04/03/Git/"/>
    <id>http://yoursite.com/2018/04/03/Git/</id>
    <published>2018-04-03T08:07:32.000Z</published>
    <updated>2018-07-12T12:01:36.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、Git"><a href="#一、Git" class="headerlink" title="一、Git"></a>一、Git</h1><h2 id="1-Git的常用操作"><a href="#1-Git的常用操作" class="headerlink" title="1. Git的常用操作"></a>1. Git的常用操作</h2><h3 id="1-1-本地库初始化"><a href="#1-1-本地库初始化" class="headerlink" title="1.1 本地库初始化"></a>1.1 本地库初始化</h3><ul><li>进入自己创建的git仓库目录下，使用命令<code>git init</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hxhaaj@DESKTOP-CP80SC0 MINGW64 /d/code/GitSpace/testGit (master)</span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in D:/code/GitSpace/testGit/.git/</span><br></pre></td></tr></table></figure><ul><li>此时就会提示在该目录下初始化了一个空的Git仓库</li></ul><p><code>Initialized empty Git repository in D:/code/GitSpace/testGit/.git/</code></p><ul><li><p>使用命令<code>ll -la</code> 显示所有含有隐藏目录<code>.git</code> </p></li><li><p>查看<code>.git/</code>目录下的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ll</span><br><span class="line">total 7</span><br><span class="line">-rw-r--r-- 1 hxhaaj 197121 130 6月  22 17:12 config</span><br><span class="line">-rw-r--r-- 1 hxhaaj 197121  73 6月  22 17:12 description</span><br><span class="line">-rw-r--r-- 1 hxhaaj 197121  23 6月  22 17:12 HEAD</span><br><span class="line">drwxr-xr-x 1 hxhaaj 197121   0 6月  22 17:12 hooks/</span><br><span class="line">drwxr-xr-x 1 hxhaaj 197121   0 6月  22 17:12 info/</span><br><span class="line">drwxr-xr-x 1 hxhaaj 197121   0 6月  22 17:12 objects/</span><br><span class="line">drwxr-xr-x 1 hxhaaj 197121   0 6月  22 17:12 refs/</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-2-设置签名"><a href="#1-2-设置签名" class="headerlink" title="1.2 设置签名"></a>1.2 设置签名</h3><h4 id="1-2-1-项目级-仓库级别签名"><a href="#1-2-1-项目级-仓库级别签名" class="headerlink" title="1.2.1 项目级/仓库级别签名"></a>1.2.1 项目级/仓库级别签名</h4><ul><li><p>仅仅在当前本地库范围内有效</p></li><li><p>命令：<code>git config user.name  xxx</code>   设置项目级用户名称  </p></li><li><p>命令：<code>git config user.email  xxx</code>   设置项目级用户email   </p></li><li><p>信息保存在 <code>.git/config</code>文件中 </p></li></ul><h4 id="1-2-2-系统用户级签名"><a href="#1-2-2-系统用户级签名" class="headerlink" title="1.2.2 系统用户级签名"></a>1.2.2 系统用户级签名</h4><ul><li><p>登录当前操作系统的用户范围</p></li><li><p>命令：<code>git config  --global user.name xxx</code>   设置系统用户级用户名称</p></li><li><p>命令：<code>git config  --global user.email xxx</code>   设置系统用户级用户email</p></li><li><p>签名信息保存在 系统用户目录下的  <code>~/.gitconfig</code>文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[user]</span><br><span class="line">        name = hxhaaj_glb</span><br><span class="line">        email = hxhaaj_glb@163.com</span><br></pre></td></tr></table></figure></li></ul><h4 id="1-2-3-级别优先级"><a href="#1-2-3-级别优先级" class="headerlink" title="1.2.3 级别优先级"></a>1.2.3 级别优先级</h4><ul><li><code>项目级别</code>优先于系统用户级别，二者都有时采用<code>项目级别</code>的签名</li><li>如果只有系统用户级别的签名，就以系统用户级别的签名为准</li><li>二者都没有不允许这种情况</li></ul><h3 id="1-3-基本操作"><a href="#1-3-基本操作" class="headerlink" title="1.3 基本操作"></a>1.3 基本操作</h3><p><img src="/GitMedia/1529676880677.png" alt="git各个区的联系"></p><h4 id="1-3-1-状态查看操作"><a href="#1-3-1-状态查看操作" class="headerlink" title="1.3.1 状态查看操作"></a>1.3.1 状态查看操作</h4><p>命令： <code>git status</code> 查看工作区、暂存区状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        t1.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure></p><h4 id="1-3-2-添加操作"><a href="#1-3-2-添加操作" class="headerlink" title="1.3.2 添加操作"></a>1.3.2 添加操作</h4><p><code>git add [file name]</code><br>将工作区的<code>新建或者修改</code>后的文件添加到<code>暂存区</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add t1.txt</span><br></pre></td></tr></table></figure></p><p>执行后，查看状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   t1.txt</span><br></pre></td></tr></table></figure></p><h4 id="1-3-3-暂存区删除操作"><a href="#1-3-3-暂存区删除操作" class="headerlink" title="1.3.3 暂存区删除操作"></a>1.3.3 暂存区删除操作</h4><p><code>git rm --cache [filename]</code><br>将<code>暂存区</code>中的文件，移除暂存区，避免误添加操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached t1.txt</span><br><span class="line">rm &apos;t1.txt&apos;</span><br></pre></td></tr></table></figure></p><p>删除后，回到原状态：查看状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        t1.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure></p><h4 id="1-3-4-提交操作"><a href="#1-3-4-提交操作" class="headerlink" title="1.3.4 提交操作"></a>1.3.4 提交操作</h4><p>命令： <code>git commit</code></p><p>将暂存区的内容提交到<code>本地库</code></p><ul><li>提交并直接写入本次提交提示信息</li></ul><p><code>git commit -m  &quot;xxx提交提示信息&quot;  [文件名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;new file t1 and insert some ..&quot; t1.txt</span><br><span class="line">warning: LF will be replaced by CRLF in t1.txt.</span><br><span class="line">The file will have its original line endings in your working directory.</span><br><span class="line">[master b4b7b3e] new file t1 and insert some ..</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br></pre></td></tr></table></figure><h4 id="1-3-5-查看日志"><a href="#1-3-5-查看日志" class="headerlink" title="1.3.5 查看日志"></a>1.3.5 查看日志</h4><p><code>git log</code>   最完整的形式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit b4b7b3ecb73218f06a882363ea8982e78aea59b6 (HEAD -&gt; master)</span><br><span class="line">Author: hxhaaj &lt;hxhaaj@163.com&gt;</span><br><span class="line">Date:   Fri Jun 22 22:33:57 2018 +0800</span><br><span class="line"></span><br><span class="line">    new file t1 and insert some ..</span><br><span class="line"></span><br><span class="line">commit 55afec262bc7db58f8307f788dc57f3118e0d3d1</span><br><span class="line">Author: hxhaaj &lt;hxhaaj@163.com&gt;</span><br><span class="line">Date:   Fri Jun 22 22:28:49 2018 +0800</span><br><span class="line"></span><br><span class="line">    new t1`</span><br></pre></td></tr></table></figure></p><p><code>git log --pretty=oneline</code>  以一条信息一行的简洁状态显示日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">b4b7b3ecb73218f06a882363ea8982e78aea59b6 (HEAD -&gt; master) new file t1 and insert some ..</span><br><span class="line">55afec262bc7db58f8307f788dc57f3118e0d3d1 new t1`</span><br></pre></td></tr></table></figure></p><p><code>git log  --oneline</code>  哈希值简短显示的简洁状态 更简洁 只显示过去版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline</span><br><span class="line">b4b7b3e (HEAD -&gt; master) new file t1 and insert some ..</span><br><span class="line">55afec2 new t1`</span><br></pre></td></tr></table></figure></p><p><code>git reflog</code> 增加了头指针移动次数信息 HEAD@{x}  x为移动到当前版本需要的次数 常用，新老版本都能全部显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">b4b7b3e (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: new file t1 and insert some ..</span><br><span class="line">55afec2 HEAD@&#123;1&#125;: commit (initial): new t1`</span><br></pre></td></tr></table></figure></p><p>多屏显示控制方式：</p><ul><li><p>空格向下翻页</p></li><li><p>b向上翻页</p></li><li><p>q退出</p></li></ul><h4 id="1-3-6-前进后退"><a href="#1-3-6-前进后退" class="headerlink" title="1.3.6 前进后退"></a>1.3.6 前进后退</h4><ul><li><p>本质：根据最新版本为HEAD指针，即HEAD指针到旧版本所需要移动的次数,如下HEAD@{0}为最新版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b4b7b3e (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: new file t1 and insert some ..</span><br><span class="line">55afec2 HEAD@&#123;1&#125;: commit (initial): new t1`</span><br></pre></td></tr></table></figure></li><li><p>基于索引值操作（推荐）<br><code>git reset --hard [局部索引值(55afec2)]</code><br>回到或者前进到索引值代表的那个版本</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 55afec2</span><br><span class="line">HEAD is now at 55afec2 new t1`</span><br></pre></td></tr></table></figure><p>此时回到了55afec2这个版本，再使用 <code>git reflog</code> 查看日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">55afec2 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 55afec2</span><br><span class="line">b4b7b3e HEAD@&#123;1&#125;: commit: new file t1 and insert some ..</span><br><span class="line">55afec2 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): new t1`</span><br></pre></td></tr></table></figure></p><ul><li><p>使用 ^ 符号形式 只能后退<br><code>git reset --hard HEAD[^]</code><br>一个^符号，退一个版本，<code>n个^符号，退n个版本</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 55afec2 new t1`</span><br></pre></td></tr></table></figure></li><li><p>使用 ~ 符号形式<br><code>git reset --hard HEAD~n</code> n代表后退多少步，同样也只能后退</p><h4 id="1-3-7-reset命令的三个参数对比"><a href="#1-3-7-reset命令的三个参数对比" class="headerlink" title="1.3.7 reset命令的三个参数对比"></a>1.3.7 reset命令的三个参数对比</h4></li><li><code>--soft</code> 参数<br>仅仅在本地库移动HEAD指针 </li><li><code>--mixed</code> 参数<br>在本地库移动HEAD指针，重置暂存区</li><li><code>--hard</code> 参数<br>在本地库移动HEAD指针，重置暂存区，重置工作区</li></ul><h4 id="1-3-7-删除文件并找回"><a href="#1-3-7-删除文件并找回" class="headerlink" title="1.3.7 删除文件并找回"></a>1.3.7 删除文件并找回</h4><ul><li>前提：删除前，文件存在时的状态提交到了本地库。</li><li>命令：<code>git reset --hard [指针位置]</code><br>删除操作已经提交到本地库：指针位置指向历史记录<br>删除操作没有提交到本地库：指针位置使用HEAD</li></ul><h4 id="1-3-8-比较文件差异"><a href="#1-3-8-比较文件差异" class="headerlink" title="1.3.8 比较文件差异"></a>1.3.8 比较文件差异</h4><ul><li><p><code>git diff [文件名]</code><br>不带参数，将工作区中的文件和暂存区进行比较</p></li><li><p><code>git diff[本地库中历史版本] [文件名]</code><br>将工作区中的文件和本地库历史记录进行比较<br><code>git diff HEAD t1.txt</code><br><code>git diff HEAD^ t1.txt</code></p></li><li><p>不指定文件名，比较多个文件</p></li></ul><h3 id="1-4-分支"><a href="#1-4-分支" class="headerlink" title="1.4 分支"></a>1.4 分支</h3><h4 id="1-4-1-分支的好处"><a href="#1-4-1-分支的好处" class="headerlink" title="1.4.1 分支的好处"></a>1.4.1 分支的好处</h4><ul><li>同时并行推进多个功能开发，提高开发效率</li><li>各个分支在开发过程中，如果某个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</li></ul><h4 id="1-4-2-分支操作"><a href="#1-4-2-分支操作" class="headerlink" title="1.4.2 分支操作"></a>1.4.2 分支操作</h4><ul><li><p>创建分支<br><code>git branch [分支名]</code></p></li><li><p>查看分支<br><code>git branch -v</code></p></li><li><p>切换分支<br><code>git checkout [分支名]</code></p></li><li><p>合并分支<br>第一步：切换到接受修改的分支（被合并的，增加新内容的分支）上<br><code>git checkout [被合并分支名]</code><br>第二步：执行merge命令<br><code>git merge [有新内容的分支名]</code></p></li><li><p>解决冲突</p><ul><li>合并后有冲突的分支的表现：</li></ul><p><img src="/GitMedia/1529744945878.png" alt="1529744945878"></p><ul><li>解决方式：<ul><li>第一步：编辑文件，删除特殊符号</li><li>第二步：把文件修改到满意的程序，去掉冲突，保存退出</li><li>第三步：<code>git add [文件名]</code></li><li>第四步：<code>git commit -m &quot;日志信息&quot;</code><ul><li>注意点：此时commit 一定不能带具体文件名</li></ul></li></ul></li></ul></li></ul><h2 id="2-Git的基本原理"><a href="#2-Git的基本原理" class="headerlink" title="2. Git的基本原理"></a>2. Git的基本原理</h2><h3 id="2-1-哈希"><a href="#2-1-哈希" class="headerlink" title="2.1 哈希"></a>2.1 哈希</h3><p>哈希是一系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下几个共同点：</p><ul><li>不管输入数据的数据量有多大，输入同一个哈希算法，得到加密结果长度固定。</li><li>哈希算法确定，输入数据确定，输出数据能够保证不变。</li><li>哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大</li><li>哈希算法是不可逆的 </li><li>Git底层采用的是SHA-1算法。</li><li>哈希算法常常被用来验证文件的完整性，确定性。</li><li>Git底层就是根据这种验证机制保证了数据的完整性。</li></ul><p><img src="/GitMedia/1529746073916.png" alt="1529746073916"></p><h3 id="2-2-Git保存版本的机制"><a href="#2-2-Git保存版本的机制" class="headerlink" title="2.2 Git保存版本的机制"></a>2.2 Git保存版本的机制</h3><h4 id="2-2-1-集中式版本控制工具的文件管理机制"><a href="#2-2-1-集中式版本控制工具的文件管理机制" class="headerlink" title="2.2.1 集中式版本控制工具的文件管理机制"></a>2.2.1 集中式版本控制工具的文件管理机制</h4><blockquote><p>以文件变更列表的方式存储信息。这类系统将他们保存的信息看做是一组基本文件和每个文件随时间逐步累积的差异。</p></blockquote><p><img src="/GitMedia/1529746396773.png" alt="1529746396773"></p><h4 id="2-2-2-Git的文件管理机制"><a href="#2-2-2-Git的文件管理机制" class="headerlink" title="2.2.2 Git的文件管理机制"></a>2.2.2 Git的文件管理机制</h4><blockquote><p>Git把数据看做是小型文件系统的<code>一组快照</code>。每次提交更新时Git都会对当前的全部文件制作一个快照并保存这个快照的<code>索引</code>。为了高效，如果文件<code>没有修改</code>，Git<code>不再重新存储该文件</code>，而是<code>只保留一个链指向之前存储的文件</code>。所以Git的工作方式可以称之为<code>快照流</code>。</p></blockquote><p><img src="/GitMedia/1529746985054.png" alt="1529746985054"></p><p><img src="/GitMedia/1529747083280.png" alt="1529747083280"></p><h4 id="2-2-3-Git文件管理机制细节"><a href="#2-2-3-Git文件管理机制细节" class="headerlink" title="2.2.3 Git文件管理机制细节"></a>2.2.3 Git文件管理机制细节</h4><ul><li><p>Git的“提交对象“</p><p><img src="/GitMedia/1529747397619.png" alt="1529747397619"></p></li><li><p>提交对象及其父对象所形成的链条</p><p><img src="/GitMedia/1529747537769.png" alt="1529747537769"></p></li></ul><h3 id="2-3-Git分支管理机制"><a href="#2-3-Git分支管理机制" class="headerlink" title="2.3 Git分支管理机制"></a>2.3 Git分支管理机制</h3><h4 id="2-3-1-分支的创建"><a href="#2-3-1-分支的创建" class="headerlink" title="2.3.1 分支的创建"></a>2.3.1 分支的创建</h4><p><img src="/GitMedia/1529747792012.png" alt="1529747792012"></p><h4 id="2-3-1-分支的切换"><a href="#2-3-1-分支的切换" class="headerlink" title="2.3.1 分支的切换"></a>2.3.1 分支的切换</h4><p>实质上是指针指向的对象变了，改变指针的指向，快速做到切换。</p><p><img src="/GitMedia/1529747909566.png" alt="1529747909566"></p><p><img src="/GitMedia/1529747936086.png" alt="1529747936086"></p><p>仅仅移动了指针，切换了版本<br><img src="/GitMedia/1529747970147.png" alt="1529747970147"></p><p>此时开始有了分支，都基于f30ab版本</p><p><img src="/GitMedia/1529748074717.png" alt="1529748074717"></p><p>所有操作都是基于链条指针的移动和切换。</p><h2 id="3-Git的远程操作"><a href="#3-Git的远程操作" class="headerlink" title="3. Git的远程操作"></a>3. Git的远程操作</h2><h3 id="3-1-在本地初始化本地仓库，将文件提交到本地库"><a href="#3-1-在本地初始化本地仓库，将文件提交到本地库" class="headerlink" title="3.1 在本地初始化本地仓库，将文件提交到本地库"></a>3.1 在本地初始化本地仓库，将文件提交到本地库</h3><h3 id="3-2-在远程代码托管中心创建好仓库"><a href="#3-2-在远程代码托管中心创建好仓库" class="headerlink" title="3.2 在远程代码托管中心创建好仓库"></a>3.2 在远程代码托管中心创建好仓库</h3><h3 id="3-3-在git上给远程仓库地址起个别名"><a href="#3-3-在git上给远程仓库地址起个别名" class="headerlink" title="3.3 在git上给远程仓库地址起个别名"></a>3.3 在git上给远程仓库地址起个别名</h3><ul><li><p>起别名：<code>git remote add [别名] [仓库地址]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add git_note  https://github.com/hxhaaj/Git_note.git</span><br></pre></td></tr></table></figure></li><li><p>查看远程仓库信息以及别名：<code>git remote -v</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">git_note        https://github.com/hxhaaj/Git_note.git (fetch)</span><br><span class="line">git_note        https://github.com/hxhaaj/Git_note.git (push)</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-4-推送到远程库"><a href="#3-4-推送到远程库" class="headerlink" title="3.4 推送到远程库"></a>3.4 推送到远程库</h3><p><code>git push [仓库地址别名] [创建的分支名]</code></p><p>测试后，弹出登陆窗口，登陆后显示提交进度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push git_note master</span><br><span class="line">Counting objects: 20, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (19/19), done.</span><br><span class="line">Writing objects: 100% (20/20), 829.22 KiB | 12.02 MiB/s, done.</span><br><span class="line">Total 20 (delta 0), reused 0 (delta 0)</span><br><span class="line">To https://github.com/hxhaaj/Git_note.git</span><br><span class="line">* [new branch]      master -&gt; master</span><br></pre></td></tr></table></figure><h3 id="3-5-克隆远程库"><a href="#3-5-克隆远程库" class="headerlink" title="3.5 克隆远程库"></a>3.5 克隆远程库</h3><p><code>git clone [远程库地址]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/hxhaaj/Git_note.git</span><br><span class="line">Cloning into &apos;Git_note&apos;...</span><br><span class="line">remote: Counting objects: 23, done.</span><br><span class="line">remote: Compressing objects: 100% (22/22), done.</span><br><span class="line">remote: Total 23 (delta 1), reused 19 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (23/23), done.</span><br></pre></td></tr></table></figure><ul><li>克隆的效果<ol><li>完整的把远程库下载到了本地</li><li>创建了远程地址别名</li><li>初始化了本地库，一条龙解决<h3 id="3-6-邀请他人加入团队后，其才可以进行推送写入仓库"><a href="#3-6-邀请他人加入团队后，其才可以进行推送写入仓库" class="headerlink" title="3.6 邀请他人加入团队后，其才可以进行推送写入仓库"></a>3.6 邀请他人加入团队后，其才可以进行推送写入仓库</h3></li></ol></li></ul><h3 id="3-7-pull拉取操作"><a href="#3-7-pull拉取操作" class="headerlink" title="3.7 pull拉取操作"></a>3.7 pull拉取操作</h3><ul><li>pull = fetch + merge 即为pull操作是fetch操作和merge操作的组合，仅仅是fetch操作，不改变本地库，merge操作之后改变本地库里的文件</li><li><p><code>git fetch [远程库地址别名][远程分支名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch git_note master</span><br><span class="line">remote: Counting objects: 6, done.</span><br><span class="line">remote: Compressing objects: 100% (5/5), done.</span><br><span class="line">remote: Total 6 (delta 2), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (6/6), done.</span><br><span class="line">From https://github.com/hxhaaj/Git_note</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">   8228eff..aeda745  master     -&gt; git_note/master</span><br></pre></td></tr></table></figure></li><li><p><code>git merge [远程库地址别名]/[远程分支名]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge git_note/master</span><br><span class="line">Updating 8228eff..aeda745</span><br><span class="line">Fast-forward</span><br><span class="line"> Git.md | 79 +++++++++++++++++++++++++++++++++++++++++++++++++++++-------------</span><br><span class="line"> 1 file changed, 64 insertions(+), 15 deletions(-)</span><br></pre></td></tr></table></figure></li><li><p>pull 操作可以直接更新本地库,是fetch和merge的一次性操作<br><code>git pull [远程库地址别名] [远程分支名]</code></p></li></ul><h3 id="3-8-冲突解决"><a href="#3-8-冲突解决" class="headerlink" title="3.8 冲突解决"></a>3.8 冲突解决</h3><p>注意点：</p><ol><li>如果<code>不是</code>基于GitHub远程库的<code>最新版本</code>所做的修改，<code>不能进行push推送</code>，必须<code>先进行pull操作</code>拉取下来。</li><li>拉取下来后如果进入冲突状态，则先<code>解决冲突</code>，去掉冲突标记，选用合适的内容，<code>冲突解决后才能push操作</code>。</li></ol><h3 id="3-9-跨团队协作"><a href="#3-9-跨团队协作" class="headerlink" title="3.9 跨团队协作"></a>3.9 跨团队协作</h3><ol><li><p>在他人的远程库地址上点击fork，就可以fork到自己的远程库上</p></li><li><p>在自己的远程库上，使用git中的<code>git clone [远程库地址]</code>操作，克隆到自己的本地库</p></li><li><p>自己在本地进行修改，push推送到远程库中</p></li><li><p>在远程库的项目中找到 并点击 <code>pull requests</code> -&gt; <code>new pull requests</code> -&gt; <code>create pull request</code>,然后发送该pull request的信息 ，此时在被fork的原始项目中的 <code>pull requests</code>一栏中就可以看到pull request的信息，并可以进行对话。</p></li><li><p>合并代码，在对话框中就可以点击 <code>merge pull request</code>进行合并，点击之后填写合并信息</p></li><li><p>被fork的用户就可以将已经更新修改的远程库就可以拉取到本地</p></li></ol><h3 id="3-10-SSH连接方式"><a href="#3-10-SSH连接方式" class="headerlink" title="3.10 SSH连接方式"></a>3.10 SSH连接方式</h3><ol><li><p><code>ssh-keygen -t rsa -C [将要的登陆用户的邮箱]</code> 执行后会生成SSH目录 <code>.ssh/</code></p></li><li><p>在<code>.ssh/</code>目录下 ，<code>cat id_rsa.pub</code>  获取该id的SSH-RSA的公钥复制到GitHub上的SSH Keys中</p></li></ol><ol start="3"><li><p>在GitHub上添加SSH key</p><p><img src="GitMedia/1529831533798.png" alt="1529831533798"></p></li><li><p>新建使用SSH连接的远程地址别名<br><code>git remote add [别名] [ssh方式的连接地址]</code></p></li><li><p>使用ssh连接进行push操作</p></li></ol><h2 id="4-Git在eclipse中的应用"><a href="#4-Git在eclipse中的应用" class="headerlink" title="4. Git在eclipse中的应用"></a>4. Git在eclipse中的应用</h2><h3 id="4-1-忽略推送配置文件"><a href="#4-1-忽略推送配置文件" class="headerlink" title="4.1 忽略推送配置文件"></a>4.1 忽略推送配置文件</h3><ol><li>在网址<a href="https://github.com/github/gitignore/blob/master/Java.gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore/blob/master/Java.gitignore</a> 找到Java.gitignore文件，此文件为GitHub已经整理好的忽略配置文件。</li><li>在自己的用户目录，把Java.gitignore文件和.gitconfig文件放在一块。</li><li><p>在Java.gitignore文件中加入以下内容：添加过滤项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br></pre></td></tr></table></figure></li><li><p>Java.gitignore文件内容信息为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># Log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line"># BlueJ files</span><br><span class="line">*.ctxt</span><br><span class="line"></span><br><span class="line"># Mobile Tools for Java (J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xml</span><br><span class="line">hs_err_pid*</span><br><span class="line"></span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br></pre></td></tr></table></figure></li><li><p>在.gitconfig配置文件中加入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">excludesfile = C:/Users/hxhaaj/Java.gitignore</span><br></pre></td></tr></table></figure></li></ol><ul><li>此时注意，该路径内容为<code>Java.gitignore文件路径</code>信息，同时，<code>路径分割符必须为正斜线&#39;/&#39;，不能为反斜线&#39;\&#39;</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、Git&quot;&gt;&lt;a href=&quot;#一、Git&quot; class=&quot;headerlink&quot; title=&quot;一、Git&quot;&gt;&lt;/a&gt;一、Git&lt;/h1&gt;&lt;h2 id=&quot;1-Git的常用操作&quot;&gt;&lt;a href=&quot;#1-Git的常用操作&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git基础" scheme="http://yoursite.com/tags/Git%E5%9F%BA%E7%A1%80/"/>
    
      <category term="GitHub使用" scheme="http://yoursite.com/tags/GitHub%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaNIO</title>
    <link href="http://yoursite.com/2018/03/10/Java-NIO/"/>
    <id>http://yoursite.com/2018/03/10/Java-NIO/</id>
    <published>2018-03-10T08:07:32.000Z</published>
    <updated>2018-07-12T11:56:24.753Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h1><h2 id="1-Java-NIO-概念"><a href="#1-Java-NIO-概念" class="headerlink" title="1. Java NIO 概念"></a>1. Java NIO 概念</h2><blockquote><p>Java NIO（New IO） 是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。</p></blockquote><h2 id="2-NIO与IO的主要区别"><a href="#2-NIO与IO的主要区别" class="headerlink" title="2. NIO与IO的主要区别"></a>2. NIO与IO的主要区别</h2><table><thead><tr><th>IO</th><th>NIO</th></tr></thead><tbody><tr><td>面向流</td><td>面向缓冲区</td></tr><tr><td>阻塞IO</td><td>非阻塞IO</td></tr><tr><td>无</td><td>选择器</td></tr></tbody></table><p>NIO面向缓冲区数据流通图</p><ul><li><p>通道负责连通，搭建缓冲区流通路径</p></li><li><p>缓冲区用于来回运送数据</p></li></ul><p><img src="Java-NIO_Media/1530262134544.png" alt="NIO基于通道的双向缓冲区"></p><blockquote><p>NIO核心在于：通道（Channel）和缓冲区（Buffer）。通道表示打开到IO设备（例如：文件、套接字）的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。</p></blockquote><h2 id="3-缓冲区-（Buffer）"><a href="#3-缓冲区-（Buffer）" class="headerlink" title="3. 缓冲区  （Buffer）"></a>3. 缓冲区  （Buffer）</h2><blockquote><p>缓冲区就是数组，用于存储不同数据类型的数据。</p></blockquote><h3 id="3-1-缓冲区的类型"><a href="#3-1-缓冲区的类型" class="headerlink" title="3.1 缓冲区的类型"></a>3.1 缓冲区的类型</h3><p>根据数据类型不同（除了boolean类型）,提供了相应类型的缓冲区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer</span><br><span class="line">CharBuffer</span><br><span class="line">ShortBuffer</span><br><span class="line">IntBuffer</span><br><span class="line">LongBuffer</span><br><span class="line">FloatBuffer</span><br><span class="line">DoubleBuffer</span><br></pre></td></tr></table></figure></p><ul><li>上述各类型缓冲区管理方式几乎一致，通过<code>allocate()</code>获取缓冲区<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(1024);</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-缓冲区存取数据的两个核心方法"><a href="#3-2-缓冲区存取数据的两个核心方法" class="headerlink" title="3.2  缓冲区存取数据的两个核心方法"></a>3.2  缓冲区存取数据的两个核心方法</h3><ul><li><code>put()</code>  存入数据到缓冲区中</li><li><code>get()</code>  获取缓冲区中的数据</li></ul><h3 id="3-3-缓冲区中的四个核心属性"><a href="#3-3-缓冲区中的四个核心属性" class="headerlink" title="3.3 缓冲区中的四个核心属性"></a>3.3 缓冲区中的四个核心属性</h3><ol><li><code>capacity</code>    容量，表示缓冲区中最大存储数据的容量。一旦声明不能改变，即为数组长度。</li><li><code>limit</code>  界限，表示缓冲区中可以操作数据的大小。limit值后面的数据不能进行读写。</li><li><code>position</code>  位置，表示缓冲区中正在操作数据的位置。</li><li><code>mark</code>  标记 ， 表示记录当前position的位置，可以通过<code>reset()</code>恢复到mark的位置。</li><li><code>0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity</code></li></ol><h4 id="3-3-1-position、limit、capacity-值的关系"><a href="#3-3-1-position、limit、capacity-值的关系" class="headerlink" title="3.3.1 position、limit、capacity 值的关系"></a>3.3.1 position、limit、capacity 值的关系</h4><p><img src="Java-NIO_Media/1530491456931.png" alt="1530491456931"></p><ul><li><p>当<code>allocate(10)</code>分配10个字节大小的缓冲区后，position的位置为0，capacity(容量)的值为10，limit（界限）值为10。</p></li><li><p>当使用<code>put(5)</code>方法进入<code>写数据模式</code>时，position指针的位置在填入数据后的第一个空闲位置，此时位置为5，capacity总容量值不变，依然为10，limit界限值还是为10。</p></li><li><p>当使用方法<code>flip()</code>后进入<code>读数据模式</code>，此时的position指针的位置为使用区的开始位置，即为0。limit界限的值则为5，因为在读取模式中，读取的应为使用区，所以界限为5，超过5就是空闲区了，最多取到5。capacity总容量的值依然为10变。</p></li></ul><h3 id="3-4-缓冲区Buffer类中的常用方法"><a href="#3-4-缓冲区Buffer类中的常用方法" class="headerlink" title="3.4 缓冲区Buffer类中的常用方法"></a>3.4 缓冲区Buffer类中的常用方法</h3><table><thead><tr><th>Modifier and Type</th><th>Method and Description</th></tr></thead><tbody><tr><td><code>abstract Object</code></td><td><code>array()</code>返回支持此缓冲区的数组 <em>（可选操作）</em> 。</td></tr><tr><td><code>abstract int</code></td><td><code>arrayOffset()</code>返回该缓冲区的缓冲区的第一个元素的背衬数组中的偏移量 <em>（可选操作）</em> 。</td></tr><tr><td><code>int</code></td><td><code>capacity()</code>返回此缓冲区的容量。</td></tr><tr><td><code>Buffer</code></td><td><code>clear()</code>清除此缓冲区。但是其中的元素并没有消失，只是处于在 <code>被遗忘状态</code>,因为<code>position</code>、<code>limit</code> 值全部归零，和刚刚分配时一致。</td></tr><tr><td><code>Buffer</code></td><td><code>flip()</code>翻转这个缓冲区。</td></tr><tr><td><code>abstract boolean</code></td><td><code>hasArray()</code>告诉这个缓冲区是否由可访问的数组支持。</td></tr><tr><td><code>boolean</code></td><td><code>hasRemaining()</code>告诉当前位置和极限之间是否存在任何元素。</td></tr><tr><td><code>abstract boolean</code></td><td><code>isDirect()</code>告诉这个缓冲区是否为 <a href="https://blog.fondme.cn/apidoc/jdk-1.8-google/java/nio/ByteBuffer.html#direct" target="_blank" rel="noopener"><em>direct</em></a> 。</td></tr><tr><td><code>abstract boolean</code></td><td><code>isReadOnly()</code>告知这个缓冲区是否是只读的。</td></tr><tr><td><code>int</code></td><td><code>limit()</code>返回此缓冲区的限制。</td></tr><tr><td><code>Buffer</code></td><td><code>limit(int newLimit)</code>设置此缓冲区的限制。</td></tr><tr><td><code>Buffer</code></td><td><code>mark()</code>将此缓冲区的标记设置在其位置。</td></tr><tr><td><code>int</code></td><td><code>position()</code>返回此缓冲区的位置。</td></tr><tr><td><code>Buffer</code></td><td><code>position(int newPosition)</code>设置这个缓冲区的位置。</td></tr><tr><td><code>int</code></td><td><code>remaining()</code>返回当前位置和限制之间的元素数。</td></tr><tr><td><code>Buffer</code></td><td><code>reset()</code>将此缓冲区的位置重置为先前标记的位置。</td></tr><tr><td><code>Buffer</code></td><td><code>rewind()</code>倒带这个缓冲区。</td></tr></tbody></table><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"hxh"</span>;</span><br><span class="line"><span class="comment">//定义缓冲区，指定缓冲区类型和大小</span></span><br><span class="line">ByteBuffer bf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"--allocate()---"</span>);</span><br><span class="line">System.out.println(<span class="string">"capacity---"</span>+bf.capacity());</span><br><span class="line">System.out.println(<span class="string">"limit---"</span>+bf.limit());</span><br><span class="line">System.out.println(<span class="string">"position---"</span>+bf.position());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--allocate()---</span></span><br><span class="line"><span class="comment">capacity---1024</span></span><br><span class="line"><span class="comment">limit---1024</span></span><br><span class="line"><span class="comment">position---0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//利用put() 装入缓冲区,进去写模式</span></span><br><span class="line">bf.put(str.getBytes());</span><br><span class="line">System.out.println(<span class="string">"--put()---"</span>);</span><br><span class="line">System.out.println(<span class="string">"capacity---"</span>+bf.capacity());</span><br><span class="line">System.out.println(<span class="string">"limit---"</span>+bf.limit());</span><br><span class="line">System.out.println(<span class="string">"position---"</span>+bf.position());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--put()---</span></span><br><span class="line"><span class="comment">capacity---1024</span></span><br><span class="line"><span class="comment">limit---1024</span></span><br><span class="line"><span class="comment">position---3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//使用flip()进入读数据模式</span></span><br><span class="line">bf.flip();</span><br><span class="line">System.out.println(<span class="string">"--flip()---"</span>);</span><br><span class="line">System.out.println(<span class="string">"capacity---"</span>+bf.capacity());</span><br><span class="line">System.out.println(<span class="string">"limit---"</span>+bf.limit());</span><br><span class="line">System.out.println(<span class="string">"position---"</span>+bf.position());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">--flip()---</span></span><br><span class="line"><span class="comment">capacity---1024</span></span><br><span class="line"><span class="comment">limit---3</span></span><br><span class="line"><span class="comment">position---0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//使用get(byte []) 读取缓冲区中的数据</span></span><br><span class="line"><span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[bf.limit()];</span><br><span class="line">bf.get(dst);<span class="comment">//此方法将字节从此缓冲区传输到给定的目标数组</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst,<span class="number">0</span>,dst.length));<span class="comment">//打印字节数组中的数据</span></span><br><span class="line">System.out.println(<span class="string">"--get()---"</span>);</span><br><span class="line">System.out.println(<span class="string">"capacity---"</span>+bf.capacity());</span><br><span class="line">System.out.println(<span class="string">"limit---"</span>+bf.limit());</span><br><span class="line">System.out.println(<span class="string">"position---"</span>+bf.position());</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        hxh</span></span><br><span class="line"><span class="comment">        --get()---</span></span><br><span class="line"><span class="comment">        capacity---1024</span></span><br><span class="line"><span class="comment">        limit---3</span></span><br><span class="line"><span class="comment">        position---3</span></span><br><span class="line"><span class="comment">         */</span></span><br></pre></td></tr></table></figure><p>测试结果：如上图一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">--allocate()---</span><br><span class="line">capacity---<span class="number">1024</span></span><br><span class="line">limit---<span class="number">1024</span></span><br><span class="line">position---<span class="number">0</span></span><br><span class="line">--put()---</span><br><span class="line">capacity---<span class="number">1024</span></span><br><span class="line">limit---<span class="number">1024</span></span><br><span class="line">position---<span class="number">3</span></span><br><span class="line">--flip()---</span><br><span class="line">capacity---<span class="number">1024</span></span><br><span class="line">limit---<span class="number">3</span></span><br><span class="line">position---<span class="number">0</span></span><br><span class="line"> </span><br><span class="line"> hxh</span><br><span class="line">--get()---</span><br><span class="line">capacity---<span class="number">1024</span></span><br><span class="line">limit---<span class="number">3</span></span><br><span class="line">position---<span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>rewind()</code>，实现可重复读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用rewind方法，实现可重复读</span></span><br><span class="line">bf.rewind();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"--rewind() 重复读取，指针归0---"</span>);</span><br><span class="line">System.out.println(<span class="string">"capacity---"</span>+bf.capacity());</span><br><span class="line">System.out.println(<span class="string">"limit---"</span>+bf.limit());</span><br><span class="line">System.out.println(<span class="string">"position---"</span>+bf.position());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        --rewind() 重复读取，指针归0---</span></span><br><span class="line"><span class="comment">        capacity---1024</span></span><br><span class="line"><span class="comment">        limit---3</span></span><br><span class="line"><span class="comment">        position---0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br></pre></td></tr></table></figure><p><code>clear()</code>清除此缓冲区<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//clear()清除此缓冲区。但是其中的元素并没有消失，</span></span><br><span class="line"><span class="comment">// 只是处于在 被遗忘状态,</span></span><br><span class="line"><span class="comment">// 因为position、limit 值全部归零，和刚刚分配时一致。</span></span><br><span class="line">bf.clear();</span><br><span class="line">System.out.println(<span class="string">"--clear()---"</span>);</span><br><span class="line">System.out.println(<span class="string">"capacity---"</span>+bf.capacity());</span><br><span class="line">System.out.println(<span class="string">"limit---"</span>+bf.limit());</span><br><span class="line">System.out.println(<span class="string">"position---"</span>+bf.position());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"依然可以取到值，测试："</span>+(<span class="keyword">char</span>) bf.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        --clear()---</span></span><br><span class="line"><span class="comment">        capacity---1024</span></span><br><span class="line"><span class="comment">        limit---1024</span></span><br><span class="line"><span class="comment">        position---0</span></span><br><span class="line"><span class="comment">        依然可以取到值，测试：h</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         */</span></span><br></pre></td></tr></table></figure></p><ul><li>注意点：clear()清除此缓冲区。但是其中的<code>元素并没有消失</code>，只是处于在 <code>被遗忘状态</code>,因为<code>position、limit、capacity</code> 值全部归零，和刚刚分配时一致。如果直接<code>bf.get()</code>取值，当然也是可以取到。</li></ul><p><code>mark()</code>和 <code>reset()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abcdefg"</span>;</span><br><span class="line">ByteBuffer bf = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">bf.put(str.getBytes());</span><br><span class="line">bf.flip();</span><br><span class="line"><span class="keyword">byte</span>[] dst = <span class="keyword">new</span> <span class="keyword">byte</span>[bf.limit()];</span><br><span class="line">bf.get(dst,<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst,<span class="number">0</span>,<span class="number">2</span>)); <span class="comment">// ab</span></span><br><span class="line">System.out.println(<span class="string">"position---"</span>+bf.position()); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//此时标记一下position的位置</span></span><br><span class="line">bf.mark();</span><br><span class="line">System.out.println(<span class="string">"此时mark一下"</span>);</span><br><span class="line">bf.get(dst,<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(dst,<span class="number">2</span>,<span class="number">2</span>)); <span class="comment">//cd</span></span><br><span class="line">System.out.println(<span class="string">"position---"</span>+bf.position()); <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">bf.reset(); <span class="comment">//重置到标记位置</span></span><br><span class="line">System.out.println(<span class="string">"reset 重置后---"</span>);</span><br><span class="line">System.out.println(<span class="string">"position---"</span>+bf.position()); <span class="comment">//2 又回到了mark标记的位置</span></span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ab</span><br><span class="line">position---2</span><br><span class="line">此时mark一下</span><br><span class="line">cd</span><br><span class="line">position---4</span><br><span class="line">reset 重置后---</span><br><span class="line">position---2</span><br></pre></td></tr></table></figure><p><code>hasRemainin</code>  和 <code>remaining</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hasRemaining  当前位置和极限位置之间是否还有元素</span></span><br><span class="line"><span class="keyword">if</span>(bf.hasRemaining())&#123;</span><br><span class="line">  <span class="comment">//有元素， 返回当前位置和极限位置之间的元素数量</span></span><br><span class="line">  System.out.println(bf.remaining());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-继承Buffer类的各具体类型缓冲区中的常用方法-以ByteBuffer类为例"><a href="#3-5-继承Buffer类的各具体类型缓冲区中的常用方法-以ByteBuffer类为例" class="headerlink" title="3.5 继承Buffer类的各具体类型缓冲区中的常用方法(以ByteBuffer类为例)"></a>3.5 继承Buffer类的<code>各具体类型缓冲区</code>中的常用方法(以ByteBuffer类为例)</h3><h4 id="3-5-1-allocate-分配缓冲区"><a href="#3-5-1-allocate-分配缓冲区" class="headerlink" title="3.5.1 allocate  分配缓冲区"></a>3.5.1 allocate  <em>分配缓冲区</em></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static ByteBuffer allocate(int capacity)</span><br></pre></td></tr></table></figure><p><code>分配一个新的字节缓冲区</code></p><p>新缓冲区的位置将为零，其限制将为其容量，其标记将不定义，并且其每个元素将被初始化为零。 它将有一个<a href="https://blog.fondme.cn/apidoc/jdk-1.8-google/java/nio/ByteBuffer.html#array--" target="_blank" rel="noopener"><code>backing array</code></a> ，其<a href="https://blog.fondme.cn/apidoc/jdk-1.8-google/java/nio/ByteBuffer.html#arrayOffset--" target="_blank" rel="noopener"><code>array offset</code></a>将为零。</p><ul><li><p>参数</p><p><code>capacity</code> - 新的缓冲区的容量，以字节为单位</p></li><li><p>结果</p><p>新的字节缓冲区</p></li></ul><h4 id="3-5-2-put-存入-，写入缓冲区"><a href="#3-5-2-put-存入-，写入缓冲区" class="headerlink" title="3.5.2  put  存入 ，写入缓冲区"></a>3.5.2  put  <em>存入</em> ，写入缓冲区</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract ByteBuffer put(byte b)</span><br></pre></td></tr></table></figure><p>相对<em>放置</em>法<em>（可选操作）</em> 。</p><p>将给定字节写入当前位置的缓冲区，然后增加位置。</p><ul><li><p>参数</p><p><code>b</code> - 要写入的字节</p></li><li><p>结果</p><p>这个缓冲区</p></li></ul></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public abstract ByteBuffer put(int index,</span><br><span class="line">                               byte b)</span><br></pre></td></tr></table></figure><p>绝对<em>put</em>方法<em>（可选操作）</em> 。</p><p>将给定字节写入给定索引的缓冲区。</p><ul><li><p>参数</p><p><code>index</code> - 要写入字节的索引</p><p><code>b</code> - 要写入的字节值</p></li><li><p>结果</p><p>这个缓冲区</p></li></ul></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ByteBuffer put(byte[] src,</span><br><span class="line">                      int offset,</span><br><span class="line">                      int length)</span><br></pre></td></tr></table></figure><p>相对大容量<em>put</em>方法<em>（可选操作）</em> 。</p><p>此方法将字节从给定的源数组传输到此缓冲区。 如果要从数组中复制的字节多于保留在此缓冲区中的字节数，也就是说，如果<code>length</code> <code>&gt;</code> <code>remaining()</code> ，则不会传输任何字节，并抛出<a href="https://blog.fondme.cn/apidoc/jdk-1.8-google/java/nio/BufferOverflowException.html" target="_blank" rel="noopener"><code>BufferOverflowException</code></a> 。</p><p>否则，该方法将给定数组中的<code>length</code>个字节复制到此缓冲区中，从阵列中的给定偏移量和该缓冲区的当前位置开始。 此缓冲区的位置然后增加<code>length</code> 。</p><p>换言之，所述表格<code>dst.put(src, off, len)</code>的这种方法的调用具有完全一样的环相同的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = off; i &lt; off + len; i++) dst.put(a[i]);</span><br></pre></td></tr></table></figure><p>除了它首先检查这个缓冲区中是否有足够的空间，并且它可能更有效率。</p><ul><li><p>参数</p><p><code>src</code> - 要读取字节的数组</p><p><code>offset</code> - 要读取的第一个字节的数组内的偏移量; 必须是非负数，不得大于<code>array.length</code></p><p><code>length</code> - 要从给定数组读取的字节数; 必须是非负数，不得大于<code>array.length - offset</code></p></li><li><p>结果</p><p>这个缓冲区</p></li></ul></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ByteBuffer put(ByteBuffer src)</span><br></pre></td></tr></table></figure><p>相对大容量<em>put</em>方法<em>（可选操作）</em> 。</p><p>此方法将给定源缓冲区中剩余的字节传输到此缓冲区。 如果源缓冲区中剩余的字节多于此缓冲区，即<code>src.remaining()</code> <code>&gt;</code> <code>remaining()</code> ，则不会传输任何字节，并抛出<a href="https://blog.fondme.cn/apidoc/jdk-1.8-google/java/nio/BufferOverflowException.html" target="_blank" rel="noopener"><code>BufferOverflowException</code></a> 。</p><p>否则，该方法将<em>n</em> = <code>src.remaining()</code>个字节从给定缓冲区复制到此缓冲区中，从每个缓冲区的当前位置开始。 然后将两个缓冲器的位置递增<em>n</em> 。</p><p>换句话说，调用此方法的形式<code>dst.put(src)</code>具有与循环完全相同的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (src.hasRemaining())</span><br><span class="line">       dst.put(src.get());</span><br></pre></td></tr></table></figure><p>除了它首先检查这个缓冲区中是否有足够的空间，并且它可能更有效率。</p><ul><li><p>参数</p><p><code>src</code> - 读取字节的源缓冲区; 不能是这个缓冲区</p></li><li><p>结果</p><p>这个缓冲区</p></li></ul></li></ul><h4 id="3-5-3-get-获取-，读取缓冲区"><a href="#3-5-3-get-获取-，读取缓冲区" class="headerlink" title="3.5.3  get  获取  ，读取缓冲区"></a>3.5.3  get  <em>获取</em>  ，读取缓冲区</h4><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract byte get()</span><br></pre></td></tr></table></figure><p>相对<em>获取</em>方法。 读取该缓冲区当前位置的字节，然后增加位置。</p><ul><li><p>结果</p><p>缓冲区当前位置的字节</p></li></ul></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public abstract byte get(int index)</span><br></pre></td></tr></table></figure><p>绝对<em>获取</em>方法。 读取给定索引处的字节。</p><ul><li><p>参数</p><p><code>index</code> - 读取字节的索引</p></li><li><p>结果</p><p>给定索引的字节</p></li></ul></li></ul><ul><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public ByteBuffer get(byte[] dst)</span><br></pre></td></tr></table></figure><p>相对批量<em>获取</em>方法。</p><p>此方法将字节从此缓冲区传输到给定的目标数组。 调用此方法的形式为<code>src.get(a)的</code>行为方式与调用完全相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">src.get(a, 0, a.length)</span><br></pre></td></tr></table></figure><ul><li><p>参数</p><p><code>dst</code> - 目的地阵列</p></li><li><p>结果</p><p>这个缓冲区</p></li></ul></li><li><p>​</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ByteBuffer get(byte[] dst,</span><br><span class="line">                      int offset,</span><br><span class="line">                      int length)</span><br></pre></td></tr></table></figure><p>相对批量<em>获取</em>方法。</p><p>此方法将字节从此缓冲区传输到给定的目标数组。 如果缓冲区中剩余的字节比满足请求所需的字节少，也就是说，如果<code>length</code> <code>&gt;</code> <code>remaining()</code> ， <code>则不</code> <code>传输</code>任何字节并抛出<a href="https://blog.fondme.cn/apidoc/jdk-1.8-google/java/nio/BufferUnderflowException.html" target="_blank" rel="noopener"><code>BufferUnderflowException</code></a> 。</p><p>否则，该方法将<code>length</code>字节从该缓冲区复制到给定的数组中，从该缓冲区的当前位置开始，并在数组中给定的偏移量。 然后将该缓冲区的位置增加<code>length</code> 。</p><p>换句话说，调用此方法的形式<code>src.get(dst, off, len)</code>具有与循环完全相同的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (int i = off; i &lt; off + len; i++) dst[i] = src.get():</span><br></pre></td></tr></table></figure><p>除了它首先检查这个缓冲区中是否有足够的字节，并且它可能更有效率。</p><ul><li><p>参数</p><p><code>dst</code> - 要写入字节的数组</p><p><code>offset</code> - 要写入的第一个字节的数组中的偏移量; 必须是非负数，不得大于<code>dst.length</code></p><p><code>length</code> - 要写入给定数组的最大字节数; 必须是非负数，不得大于<code>dst.length - offset</code></p></li><li><p>结果</p><p>这个缓冲区</p></li></ul></li></ul><h2 id="4-非直接缓冲区和直接缓冲区"><a href="#4-非直接缓冲区和直接缓冲区" class="headerlink" title="4. 非直接缓冲区和直接缓冲区"></a>4. 非直接缓冲区和直接缓冲区</h2><h3 id="4-1-概念区分"><a href="#4-1-概念区分" class="headerlink" title="4.1 概念区分"></a>4.1 概念区分</h3><ul><li>非直接缓冲区：通过<code>allocate()</code>方法分配缓冲区，将缓冲区建立<code>在JVM的内存</code>中.</li><li>直接缓冲区：通过<code>allocateDirect()</code>方法分配直接缓冲区，将缓冲区建立在<code>物理内存</code>中。操作系统的内存中，可以提升效率。</li></ul><p><img src="/Java-NIO_Media/1530524051395.png" alt="1530524051395"></p><h3 id="4-2-直接缓冲区的相对优缺点"><a href="#4-2-直接缓冲区的相对优缺点" class="headerlink" title="4.2  直接缓冲区的相对优缺点"></a>4.2  直接缓冲区的相对优缺点</h3><ul><li>直接缓冲区利用了操作系统中<code>直接映射方式</code>，在物理内存中<code>初始化一个物理内存映射文件</code>，省去了非直接缓冲区的中间<code>多余的内容复制</code>步骤，让应用程序和物理磁盘直接面对。<ul><li>优点：简化步骤，直接映射，提升效率。</li><li>缺点：<ul><li>初始化物理内存映射文件时，<code>耗费较大物理内存</code>，并且不会直接用完释放，必须通过<code>垃圾回收</code>机制进行释放。</li><li>直接操作物理内存和磁盘，<code>不安全，不易控制</code>。</li></ul></li><li>适合：数据长时间在<code>内存</code>中操作，<code>大量数据</code>直接在<code>物理内存中存放</code>，不存放在jvm中。</li></ul></li><li>直接缓冲区，Java虚拟机会尽量<code>避免</code>将缓冲区的<code>内容复制到中间缓冲区</code>中（或从中间缓冲区中复制内容），即<code>省去了中间内容复制</code>操作。而是<code>直接</code>在此<code>缓冲区</code>上执行本机IO操作。</li><li>直接缓冲区，通过Buffer类中的<code>allocateDirect()</code>工厂方法来创建。此方法返回的缓冲区进行<code>分配和取消分配所需成本通常高于非直接缓冲区</code>。</li></ul><h2 id="5-通道（Channel）"><a href="#5-通道（Channel）" class="headerlink" title="5.  通道（Channel）"></a>5.  通道（Channel）</h2><h3 id="5-1-通道概念"><a href="#5-1-通道概念" class="headerlink" title="5.1 通道概念"></a>5.1 通道概念</h3><blockquote><p>用于源节点和目标节点的连接。NIO中负责缓冲区中数据的传输。Channel类似于传统的“流”。但是Channel本身不存储数据，因此需要配合缓冲区进行传输。</p></blockquote><h3 id="5-2-Channel的主要实现类"><a href="#5-2-Channel的主要实现类" class="headerlink" title="5.2  Channel的主要实现类"></a>5.2  Channel的主要实现类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.nio.channels.Channel 接口</span><br><span class="line">    |-- FileChannel</span><br><span class="line">    |-- SocketChannel</span><br><span class="line">    |-- ServletSocketChannel</span><br><span class="line">    |-- DatagramChannel</span><br></pre></td></tr></table></figure><h3 id="5-3-Channel的获取"><a href="#5-3-Channel的获取" class="headerlink" title="5.3 Channel的获取"></a>5.3 Channel的获取</h3><ol><li>Java对于支持通道的类都提供了<code>getChannel()</code>方法。<ul><li>本地IO：<ul><li><code>FileInputStream</code>  <code>FileOutputStream</code></li><li><code>RandomAccessFile</code></li></ul></li><li>网路IO：<ul><li><code>Socket</code></li><li><code>ServerSocket</code></li><li><code>DatagramSocket</code></li></ul></li></ul></li><li>Java7中的NIO 2 对于各个通道提供了静态方法<code>open()</code></li><li>Java7中的NIO 2 的<code>Files</code>工具类提供的方法 <code>newByteChannel()</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java-NIO&quot;&gt;&lt;a href=&quot;#Java-NIO&quot; class=&quot;headerlink&quot; title=&quot;Java NIO&quot;&gt;&lt;/a&gt;Java NIO&lt;/h1&gt;&lt;h2 id=&quot;1-Java-NIO-概念&quot;&gt;&lt;a href=&quot;#1-Java-NIO-概念&quot; c
      
    
    </summary>
    
      <category term="JavaSE回顾" scheme="http://yoursite.com/categories/JavaSE%E5%9B%9E%E9%A1%BE/"/>
    
    
      <category term="JavaNIO" scheme="http://yoursite.com/tags/JavaNIO/"/>
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE回顾-基础语法</title>
    <link href="http://yoursite.com/2018/01/12/JavaSE%E5%9B%9E%E9%A1%BE-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2018/01/12/JavaSE回顾-基础语法/</id>
    <published>2018-01-11T16:00:00.000Z</published>
    <updated>2018-07-12T12:01:51.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaSE-回顾-基础语法"><a href="#JavaSE-回顾-基础语法" class="headerlink" title="JavaSE 回顾-基础语法"></a>JavaSE 回顾-基础语法</h1><h2 id="1-Java语言的特性"><a href="#1-Java语言的特性" class="headerlink" title="1. Java语言的特性"></a>1. Java语言的特性</h2><h3 id="1-1-简单性"><a href="#1-1-简单性" class="headerlink" title="1.1 简单性"></a>1.1 简单性</h3><ul><li>java剔除了C++中许多很少使用、难以理解、易混淆的特性。尽可能的简单化。</li></ul><h3 id="1-2-面向对象"><a href="#1-2-面向对象" class="headerlink" title="1.2  面向对象"></a>1.2  面向对象</h3><ul><li>java是基于面向对象的程序设计技术设计的，将重点放在数据（即对象）和对象的接口上。</li></ul><h3 id="1-3-分布式"><a href="#1-3-分布式" class="headerlink" title="1.3 分布式"></a>1.3 分布式</h3><ul><li>java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。</li><li>java 应用能通过URL打开和访问网络上的对象，其便捷程度就行访问本地文件一样。</li></ul><h3 id="1-4-健壮性"><a href="#1-4-健壮性" class="headerlink" title="1.4  健壮性"></a>1.4  健壮性</h3><ul><li>java程序具有多方面的可靠性，Java编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题。</li></ul><h3 id="1-5-安全性"><a href="#1-5-安全性" class="headerlink" title="1.5  安全性"></a>1.5  安全性</h3><ul><li>Java适用于网络/分布式环境，为了达到这个目标，安全方面投入很大。使用java可以构建防病毒、防篡改的系统。</li><li>不可信的代码在一个<code>沙箱环境</code>中执行，在这里<code>不会影响主系统</code>。Java代码不论来自哪里，都不会脱离沙箱。</li></ul><h3 id="1-6-体系结构中立"><a href="#1-6-体系结构中立" class="headerlink" title="1.6  体系结构中立"></a>1.6  体系结构中立</h3><ul><li><p>编译器生成一个<code>体系结构中立</code>的<code>目标文件</code>格式，这是一种<code>编译过的代码</code>，只要Java运行时系统，这些编译后的代码可以在许多处理器上运行。</p></li><li><p>Java<code>编译器</code>通过<code>生成与特定的计算机体系结构无关</code>的<code>字节码指令</code>来实现这一特性。</p></li><li><p><code>字节码文件</code>可以容易的在<code>任何机器</code>上解释执行，而且还可以<code>动态翻译成本地机器码</code>。</p></li><li><p>Java虚拟机可以将执行最频繁的字节码序列翻译成机器吗，该过程为<code>即时编译</code>。</p></li><li><p>Java<code>虚拟机可以检测指令序列</code>，增强其安全性。</p></li></ul><h3 id="1-7-可移植性"><a href="#1-7-可移植性" class="headerlink" title="1.7 可移植性"></a>1.7 可移植性</h3><ul><li><code>数据类型</code>规定具有<code>固定的大小</code>。例如：Java中的int类型永远为32为的整数，不会随着操作系统或编译器不同而改变。</li><li><code>二进制数据</code>以<code>固定的格式</code>进行<code>存储和传输</code>，消除了<code>字节顺序</code>的困扰。</li><li><code>字符串</code>是用<code>标准的Unicode格式</code>存储的。</li><li>作为<code>系统组成</code>部分的类库，<code>定义了可移植的接口</code>。例如：有一个抽象的Window类，并给出了在UNIX、Windows和Macintosh环境下的不同实现。</li><li>除了用户界面有关的部分外，所有其他Java库都能很好的支持平台独立性，不用操心底层的操作系统。</li><li>不仅程序是可移植的，Java API 往往也比原生的API质量更高。</li></ul><h3 id="1-8-解释型"><a href="#1-8-解释型" class="headerlink" title="1.8 解释型"></a>1.8 解释型</h3><ul><li>Java解释器可以在<code>任何移植了解释器</code>的机器上<code>执行Java字节码</code>。</li></ul><h3 id="1-9-高性能"><a href="#1-9-高性能" class="headerlink" title="1.9 高性能"></a>1.9 高性能</h3><ul><li><code>字节码</code>可以在运行时<code>动态翻译</code>成<code>对应运行</code>这个应用的<code>特定CPU</code>的<code>机器码</code>。</li><li>即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。</li></ul><h3 id="1-10-多线程"><a href="#1-10-多线程" class="headerlink" title="1.10  多线程"></a>1.10  多线程</h3><ul><li>Java支持<code>多线程和并发性</code>,可以带来更好的交互响应和实时行为。</li></ul><h3 id="1-11-动态性"><a href="#1-11-动态性" class="headerlink" title="1.11 动态性"></a>1.11 动态性</h3><ul><li>适应不断发展的环境，在类库中可以<code>自由的添加新方法和实例变量</code>，而对<code>客户端不产生任何影响</code>。</li></ul><h2 id="2-Java-基本语法注意点"><a href="#2-Java-基本语法注意点" class="headerlink" title="2. Java 基本语法注意点"></a>2. Java 基本语法注意点</h2><h3 id="2-1-类名"><a href="#2-1-类名" class="headerlink" title="2.1  类名"></a>2.1  类名</h3><ul><li><p>关键字<code>class</code> 后面<code>紧跟类名</code>。</p></li><li><p>类名命名规则：</p><ul><li>必须以<code>字母或下划线开头</code>，后面可以跟<code>字母和数字的任意组合</code>。<ul><li>注意：Java中的字母和数字的范围更大。字母包括<code>&#39;A&#39;~&#39;Z&#39;、&#39;a&#39;~&#39;z&#39;、&#39;_&#39;、&#39;$&#39;</code>或者在某种语言中表示字母的任何Unicode字符。</li></ul></li><li>长度基本上没限制。</li><li>不能使用Java保留字作为类名。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> $<span class="title">Test1</span> </span>&#123;  <span class="comment">//类名还可以是 _Test  以下划线开头</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]  args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> _a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> $a = <span class="number">1</span>;</span><br><span class="line">System.err.println(_a);</span><br><span class="line">System.out.println($a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>源代码的文件名必须与公共类名相同，并用<code>.java</code>作为拓展名。</p></li><li><p>类名命名规范：</p><ul><li>类名以大写字母开头名词</li><li>骆驼命名法。</li></ul></li></ul><h3 id="2-2-main方法"><a href="#2-2-main方法" class="headerlink" title="2.2 main方法"></a>2.2 main方法</h3><ul><li><p>Java语言规范，main 方法 必须声明为 <code>public</code>。 </p></li><li><p>Java SE 1.4及以后版本<code>强制</code> main 方法<code>一定是</code>public修饰的。</p></li><li>main 方法 必须为 <code>public static void main(String[] args)</code>  ，缺少<code>public</code>  、<code>static</code>、以及<code>String[] args</code> 参数，都不能成为class 的入口，运行不了。</li></ul><h3 id="2-3-注释"><a href="#2-3-注释" class="headerlink" title="2.3  注释"></a>2.3  注释</h3><ul><li><p>Java一共3种注释方式：</p><ul><li><p><code>// xxxxx</code>    单行注释</p></li><li><p>多行注释  ，形成一个注释块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">  xxxx</span><br><span class="line">  xxx</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>注意： <code>/* xxx*/</code>  注释<code>不能嵌套</code>使用。</p></li><li><p>文档注释   可以用来自动地生成文档。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @version</span><br><span class="line"> * @author hxh</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-4-数据类型"><a href="#2-4-数据类型" class="headerlink" title="2.4 数据类型"></a>2.4 数据类型</h3><p>Java是强类型语言。每一个变量声明一种类型。一共有8种基本类型。</p><ul><li>4种<code>整型</code>    <code>int</code>  <code>short</code>  <code>long</code>   <code>byte</code></li><li>2种<code>浮点类型</code>  <code>float</code>   <code>double</code>  </li><li>1种用于表示Unicode编码的<code>字符单元类型</code>    <code>char</code></li><li>1种用于<code>表示真值</code> 类型   <code>boolean</code></li></ul><p>注意： Java 有一个能够表示任意精度的算术包，通常被称为“大数值” (big number)。它只是一个Java对象，不是一个数据类型。</p><h4 id="2-4-1-整型"><a href="#2-4-1-整型" class="headerlink" title="2.4.1 整型"></a>2.4.1 整型</h4><blockquote><p>整型用于表示没有小数部分的数值，它可以是负数据。</p></blockquote><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">字节数</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">1</td></tr></tbody></table><ul><li>整型的范围与运行Java代码的机器无关。</li><li><code>长整型</code>数值有一个<code>后缀L或l</code>,如：1111L</li><li><code>十六进制</code>数值有一个<code>前缀0x或0X</code>，如 0xCAFE </li><li><code>八进制</code>有一个<code>前缀0</code></li><li>Java7开始，加上<code>前缀0b或0B</code>就可以写<code>二进制</code>数。如：0b1001就是9。</li><li>Java7开始，还可以为数字字面量加下划线。如  1_000_00（0b1111_0100_0010_0100_0000）表示一百万。注意：这些下划线<code>只是为了让人易读</code>，Java<code>编译器</code>会<code>自动去除</code>这些下划线。</li></ul><h4 id="2-4-2-浮点类型"><a href="#2-4-2-浮点类型" class="headerlink" title="2.4.2  浮点类型"></a>2.4.2  浮点类型</h4><blockquote><p>浮点类型用于表示有小数部分的数值。</p></blockquote><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">字节数</th></tr></thead><tbody><tr><td style="text-align:center">float</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">8</td></tr></tbody></table><ul><li><p><code>double</code>类型数值精度是<code>float类型的两倍</code>，称为<code>双精度</code>数值。</p></li><li><p>float类型数值有一个<code>后缀F或f</code>（3.14f），<code>没有后缀F</code>的浮点数值（3.14）<code>默认为double类型</code>。</p></li><li><p>所有浮点数值计算都遵循IEEE 754规范。用于表示溢出或出错情况的三个特殊浮点数值：</p><ul><li>正无穷大</li><li>负无穷大</li><li>NaN(不是一个数字)</li></ul><p>例如：</p><p> 一个正整数除以0的结果为正无穷大。</p><p>计算0/0或者负数的平方根结果为NaN。</p></li><li><p>浮点数值<code>不适用</code>于<code>无法接受舍入误差</code>的金融计算中。</p><ul><li>例如： <code>System.out.println(2.0-1.1);</code> 结果为  <code>0.8999999999999999</code> 而不是<code>正确结果0.9</code>。</li><li>这种舍入误差原因是 浮点数值采用二进制系统表示，二进制系统中<code>无法精确地表示分数1/10</code>。就像十进制无法精确表示分数1/3一样。</li><li>如果数值计算中不允许出现这种舍入误差，就应该采用<code>BigDecimal</code>类。</li></ul></li></ul><h4 id="2-4-3-char类型"><a href="#2-4-3-char类型" class="headerlink" title="2.4.3  char类型"></a>2.4.3  char类型</h4><ul><li><p>char占2字节，16位。可在存放汉字，只能放单个字符。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a=<span class="string">'h'</span>;  <span class="comment">//任意单个字符，加单引号。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a=<span class="string">'中'</span>; <span class="comment">//任意单个中文字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a = <span class="number">111</span>; <span class="comment">//整数。0~65535。十进制、八进制、十六进制均可。输出字符编码表中对应的字符。</span></span><br></pre></td></tr></table></figure></li><li><p>char 类型<code>原本</code>用于表示单个字符。但是现在有所改变，有些Unicode字符可以用一个char值描述，另一些Unicode字符则需要两个char值。</p></li><li><p>char类型<code>字面量值</code>要用<code>单引号</code>括起来。</p><ul><li>例如：’A’是编码值为65所对应的字符常量。它和 “A” 不同，”A” 是包含一个字符A的字符串。</li></ul></li><li><p>对char类型字符运行时，直接当做ASCII表对应的整数来对待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> m=<span class="string">'a'</span>;　　<span class="comment">//a。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> m=<span class="string">'a'</span>+<span class="string">'b'</span>;　　<span class="comment">// Ã。  //char类型相加，提升为int类型，输出对应的字符。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m=<span class="string">'a'</span>+<span class="string">'b'</span>;　　 <span class="comment">//195没有超出int范围，直接输出195。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> m=<span class="string">'a'</span>+b;　　<span class="comment">//报错。 因为b是一个赋值的变量。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> m=<span class="number">197</span>;　 <span class="comment">//输出字符编码表中对应的字符。 　——Ã。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> m=<span class="string">'197;　 //因为有单引号，表示是字符，只允许放单个字符。　——报错。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">char m='</span>a<span class="string">'+1;　　//提升为int，计算结果98对应的字符是b。——b。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">char m='</span>中<span class="string">'+'</span>国<span class="string">';　 // 42282。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">char m='</span>中<span class="string">'+'</span>国<span class="string">'+'</span>国<span class="string">'+'</span>国<span class="string">';　　// 报错。int转char有损失。因为结果已经超出char类型的范围。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">int m='</span>中<span class="string">'+'</span>国<span class="string">'+'</span>国<span class="string">'+'</span>国<span class="string">';　　//86820</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">char m='</span>中<span class="string">'+1;　　//1是int，结果提升为int，输出对应的字符。 ——丮。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">char m='</span>中<span class="string">'+"国";　　// 报错。String无法转换为char。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">System.out.println('</span>中<span class="string">'+"国");　　//没有变量附值的过程。String与任何字符用“+”相连，转换为String。——中国。</span></span><br></pre></td></tr></table></figure></li><li><p><code>char+char</code>，<code>char+int</code>  ， 类型均<code>提升为int</code>，赋值给char变量后，输出<code>字符编码表中对应的字符</code>(<code>char h = 97</code>  a)。 </p></li><li><p>char类型的值可以表示为<code>十六进制值</code>，范围从<code>\u0000</code>到 <code>\uffff</code>。</p></li><li><p>除了转义序列<code>\u</code>之外，还有其他用于表示特殊字符的转义序列。</p></li><li><p>所有转义序列都<code>可以出现</code>在<code>加引号的字符字面量或字符串中</code>。例如： <code>&#39;\u2122&#39;</code>  <code>&quot;hello\n&quot;</code></p></li><li><p>转义序列<code>\u</code>还可以出现在加引号的字符常量或者字符串<code>之外</code>。<code>其他</code>转义序列<code>不可以</code>。</p></li><li><p>Unicode转义序列会在<code>解析代码之前</code>得到处理。</p><ul><li>例如： <code>&quot;\u0022+\u0022&quot;</code>并不是一个由引号包围加号构成的字符串。实际上，<code>\u0022</code>会在解析之前转换为<code>&quot;</code>，这样就会得到<code>&quot;&quot;+&quot;&quot;</code>，也就是一个<code>空串</code>。</li></ul></li><li><p>当心注释中的<code>\u</code>。</p><ul><li><p><code>// Look inside C:\users</code>  会产生一个语法错误，因为<code>\u</code>后面并未跟着4个十六进制数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]  args)</span> </span>&#123;</span><br><span class="line">System.err.println(<span class="string">"1"</span>);<span class="comment">// Look inside C:\users</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语法出错： 编译都通不过:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: </span><br><span class="line">Invalid unicode</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在Java中，char类型描述了UTF-16编码中的一个代码单元。建议不要在程序中使用char类型，除非缺失需要处理UTF-16代码单元。最好将字符串作为抽象画数据类型处理。</p></li></ul><h4 id="2-4-4-boolean类型"><a href="#2-4-4-boolean类型" class="headerlink" title="2.4.4   boolean类型"></a>2.4.4   boolean类型</h4><ul><li>只有两个值： <code>flase</code> 和 <code>true</code></li><li>用来判断逻辑条件</li><li><code>整型值</code>和<code>布尔值</code>之间<code>无法相互转换</code></li></ul><h3 id="2-5-变量"><a href="#2-5-变量" class="headerlink" title="2.5   变量"></a>2.5   变量</h3><h4 id="2-5-1-变量命名规定"><a href="#2-5-1-变量命名规定" class="headerlink" title="2.5.1 变量命名规定"></a>2.5.1 变量命名规定</h4><ul><li>变量名必须是一个以<code>字母、下划线、$符号</code>开头并由字母或数字构成的序列。一般来说，在Java中，下划线和$均属于字母。<code>π</code>  、 其他国家的字母 也可以。</li><li>不能出现 其他符号  例如 <code>+</code>  、 <code>@</code> 这样的符号 以及 空格 不能出现在变量名中。</li><li>大小写敏感</li><li>长度基本没有限制</li><li>尽管<code>$</code>是一个合法的Java字符，但是最好不要出现在自己的代码中使用这个字符。它只用在Java编译器或者其他工具生成的名字中。</li><li>不能使用Java保留字</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> $a = <span class="number">1</span>;</span><br><span class="line">System.err.println(_a);</span><br><span class="line">System.out.println($a);</span><br></pre></td></tr></table></figure><h4 id="2-5-2-变量初始化"><a href="#2-5-2-变量初始化" class="headerlink" title="2.5.2 变量初始化"></a>2.5.2 变量初始化</h4><ul><li>声明后的一个变量，<code>不能直接使用未初始化的变量</code>。<code>必须</code>使用赋值语句对变量进行<code>显式初始化</code>。</li></ul><h3 id="2-6-常量"><a href="#2-6-常量" class="headerlink" title="2.6  常量"></a>2.6  常量</h3><ul><li>利用关键字<code>final</code> 指示常量。</li><li>final修饰的变量只能被赋值一次，一旦赋值一次后，不能再更改。</li><li>习惯上常量名使用全大写</li><li>若某个常量经常<code>被一个类中的多个方法中使用</code>，通常称该常量为<code>类常量</code>。可以使用<code>static  final</code> 设置一个类常量。定义在main方法的外部。</li></ul><h3 id="2-7-运算符"><a href="#2-7-运算符" class="headerlink" title="2.7  运算符"></a>2.7  运算符</h3><ul><li>当参与<code>/</code>运算的两个操作数都是<code>整数</code>时，表示<code>整数除法</code>；否则表示<code>浮点除法</code>。<ul><li>例如 ： <code>15.0/2</code>  等于 <code>7.5</code>   而  <code>15/2</code> 等于 <code>7</code></li></ul></li><li><code>整数被0除</code>将会产生一个<code>异常</code>，而<code>浮点数被0除</code>将会得到<code>一个无穷大或NaN结果</code>。</li></ul><h3 id="2-8-数值类型之间的转换"><a href="#2-8-数值类型之间的转换" class="headerlink" title="2.8   数值类型之间的转换"></a>2.8   数值类型之间的转换</h3><ul><li><p>小字节类型转换成大字节类型无信息丢失转换，相反，可能会有精度损失。</p></li><li><p>下图中，6个实心箭头表示无信息丢失的转化，3个虚线箭头表示可能有精度损失。</p><p><img src="/JavaSE回顾_Media/1530703877331.png" alt="1530703877331"></p></li><li><p><code>二元运算</code>时，注意：先将两个操作数转换为同一种类型，然后再进行计算。</p><ul><li>若 两个中有一个是double类型，另一个将会转换为double类型；</li><li><code>否则</code>，若 两个中有一个是float类型，另一个将会转换成float类型；</li><li><code>否则</code>，若 两个中有一个是long类型，另一个将会转换成long类型；</li><li><code>否则，两个都将会转换成int类型</code>。</li></ul></li></ul><h3 id="2-9-强制类型转换"><a href="#2-9-强制类型转换" class="headerlink" title="2.9   强制类型转换"></a>2.9   强制类型转换</h3><ul><li><p>强制类型转换通过<code>截断小数部分</code>将<code>浮点值转换成整型</code>。</p></li><li><p>如果想对浮点数进行舍入运算，就需要用<code>Math.round()</code>方法，该方法返回值为<code>long类型</code>，所以只有使用<code>显式的强制转换</code>才能将<code>long类型</code>转换成<code>int类型</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">9.999</span>;</span><br><span class="line">System.err.println((<span class="keyword">int</span>)x);<span class="comment">//9</span></span><br><span class="line"></span><br><span class="line">Long hh = Math.round(x);</span><br><span class="line">System.err.println(hh);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h = (<span class="keyword">int</span>) Math.round(x);</span><br><span class="line">System.err.println(h); <span class="comment">//10</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>需要注意<code>目标类型的表示范围</code>：</p><ul><li><p>如果试图将一个数值从一种类型强制转换成为另一种类型，而又<code>超出了目标类型的表示范围</code>，结果就会<code>截断成一个完全不同的值</code>。例如：<code>(byte)300</code>  实际值 却只为 44。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">300</span>;</span><br><span class="line">System.out.println((<span class="keyword">byte</span>)a); <span class="comment">//44</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="2-10-空串与Null串"><a href="#2-10-空串与Null串" class="headerlink" title="2.10  空串与Null串"></a>2.10  空串与Null串</h3><ul><li><p><code>空串</code>是长度为0的字符串，是一个<code>Java对象</code>，有自己的<code>串长度（0）和内容 （空）</code>。</p></li><li><p><code>String h = null;</code>  表示一个<code>Null串</code>，目前<code>没有任何对象</code>与该变量关联，<code>无引用</code>。</p></li><li><p>检查一个字符串，要检查它既不是null也不为空串：<code>if(str != null &amp;&amp; str.length() != 0)</code></p></li></ul><h3 id="2-11-switch语句"><a href="#2-11-switch语句" class="headerlink" title="2.11   switch语句"></a>2.11   <code>switch</code>语句</h3><ul><li><code>switch</code>语句将会从<code>与选项值相匹配的case标签</code>处开始执行直到<code>遇到break</code>语句，或者执行到switch语句的<code>结束处</code>为止。</li><li>如果<code>没有匹配case分支</code>，而<code>有default子句</code>，就<code>执行default子句</code>。</li><li>很有可能触发多个分支：<ul><li>如果在case分支语句的<code>末尾没有break</code>语句，那么就会<code>接着执行</code>下一个case分支语句。</li></ul></li><li><code>case标签</code>可以是：<ul><li>类型为 <code>char 、byte 、short 、 int 的常量表达式</code></li><li><code>枚举常量</code></li><li>Java SE 7开始，<code>case标签</code>还可以是<code>字符串字面量</code>。</li></ul></li></ul><h3 id="2-12-大数值"><a href="#2-12-大数值" class="headerlink" title="2.12  大数值"></a>2.12  大数值</h3><blockquote><p>如果<code>基本的整数和浮点值精度不够</code>，那么可以使用<code>java.math</code>包中的两个类：<code>BigInteger</code>和<code>BigDecimal</code>。这两个类可以处理<code>包含任意长度数字序列的数值</code>。</p></blockquote><ul><li><code>BigInteger</code>类实现了<code>任意精度的整型运算</code>。</li><li><code>BigDecimal</code>类实现了<code>任意精度的浮点数运算</code>。</li><li>使用静态的<code>valueOf()</code>方法可以将普通的数值转换成大数值。</li></ul><h4 id="2-12-1-BigDecimal"><a href="#2-12-1-BigDecimal" class="headerlink" title="2.12.1 BigDecimal"></a>2.12.1 <code>BigDecimal</code></h4><blockquote><p>浮点数值<code>不适用</code>于<code>无法接受舍入误差</code>的金融计算中。</p></blockquote><ul><li><p>例如： <code>System.out.println(2.0-1.1);</code> 结果为  <code>0.8999999999999999</code> 而不是<code>正确结果0.9</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1.01</span> + <span class="number">2.02</span>);<span class="comment">//3.0300000000000002</span></span><br><span class="line">System.out.println(<span class="number">3.0</span> - <span class="number">2.1</span>);<span class="comment">//0.8999999999999999</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>这种舍入误差原因是 浮点数值采用二进制系统表示，二进制系统中<code>无法精确地表示分数1/10</code>。就像十进制无法精确表示分数1/3一样。</li></ul><blockquote><p>如果数值计算中不允许出现这种舍入误差，就应该采用<code>BigDecimal</code>类。用来<code>对超过16位有效位的数</code>进行精确的运算。</p><p>双精度浮点型变量<code>double可以处理16位有效数</code>。在实际应用中，需要对更大或者更小的数进行运算和处理。<code>float和double</code>只能用来做科学计算或者是工程计算，在<code>商业计算</code>中要用<code>java.math.BigDecimal</code>。 </p></blockquote><ul><li><p><code>创建BigDecimal对象</code>主要有两种:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal b1= <span class="keyword">new</span> BigDecimal(<span class="string">"3.0"</span>);<span class="comment">//new BigDecimal(Double.toString(3.0))</span></span><br><span class="line">BigDecimal b2 = BigDecimal.valueOf(<span class="number">2.1</span>);</span><br></pre></td></tr></table></figure><ul><li><p>b1也可以写成<code>new BigDecimal(Double.toString(3.0))</code>，直接用<code>new BigDecimal(3.0)</code>，就会出现精度问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal x1 = <span class="keyword">new</span> BigDecimal(<span class="number">1.34</span>);<span class="comment">//1.3400000000000000799360577730112709105014801025390625</span></span><br><span class="line">BigDecimal x2 = <span class="keyword">new</span> BigDecimal(<span class="string">"1.34"</span>);<span class="comment">//1.34</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>除了这两种外，特殊的像0、1、10可以这样写 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal zero = BigDecimal.ZERO;</span><br><span class="line">BigDecimal one = BigDecimal.ONE;</span><br><span class="line">BigDecimal ten = BigDecimal.TEN;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>BigDecimal所创建的是对象，<code>不能使用传统的+、-、*、/等算术运算符</code>直接对其对象进行数学运算，而<code>必须调用其相对应的方法</code>。方法中的参数也<code>必须是BigDecimal的对象</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">add</span><span class="params">(BigDecimal value)</span></span>;<span class="comment">//加法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">subtract</span><span class="params">(BigDecimal value)</span></span>;<span class="comment">//减法 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">multiply</span><span class="params">(BigDecimal value)</span></span>;<span class="comment">//乘法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">divide</span><span class="params">(BigDecimal value)</span></span>;<span class="comment">//除法</span></span><br></pre></td></tr></table></figure></li><li><p>BigDecimal的<code>运算不对原值进行操作</code>，而是<code>返回一个新的BigDecimal对象</code>。</p></li><li><p>BigDecimal的<code>比较</code>用的是BigDecimal的<code>compareTo</code>方法，将此 BigDecimal 与指定的 BigDecimal 比较。</p><ul><li>注意：<code>值相等</code>但具有<code>不同标度</code>的两个BigDecimal对象（如，2.0 和 2.00）被<code>认为是相等</code>的。</li><li>BigDecimal 在数字上<code>小于、等于或大于</code>比较对象时，返回 <code>-1、0 或 1</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = BigDecimal.valueOf(<span class="number">1</span>);</span><br><span class="line">BigDecimal b = BigDecimal.valueOf(<span class="number">20</span>);</span><br><span class="line">BigDecimal c = a.add(b);</span><br><span class="line"><span class="keyword">int</span> i1 = a.compareTo(b);<span class="comment">//-1</span></span><br><span class="line"><span class="keyword">int</span> i2 = b.compareTo(b);<span class="comment">//0</span></span><br><span class="line"><span class="keyword">int</span> i3 = c.compareTo(b);<span class="comment">//1</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JavaSE-回顾-基础语法&quot;&gt;&lt;a href=&quot;#JavaSE-回顾-基础语法&quot; class=&quot;headerlink&quot; title=&quot;JavaSE 回顾-基础语法&quot;&gt;&lt;/a&gt;JavaSE 回顾-基础语法&lt;/h1&gt;&lt;h2 id=&quot;1-Java语言的特性&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="JavaSE回顾" scheme="http://yoursite.com/categories/JavaSE%E5%9B%9E%E9%A1%BE/"/>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/tags/JavaSE/"/>
    
      <category term="基础语法" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
