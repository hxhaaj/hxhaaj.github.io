<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java面向对象(三) 继承和final实例]]></title>
    <url>%2F2018%2F06%2F24%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%89)%20%E7%BB%A7%E6%89%BF%E5%92%8Cfinal%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Java面向对象(三) 继承和final实例继承概述 继承是面向对象思想的三大特性之一，使类与类之间产生特殊 - 一般的关系，即is-a关系。 继承是从已有类中派生出新的类，新的类能吸收已有类的属性和方法，并且能拓展新的属性和行为。 在Java中使用extends关键字表示继承，语法表示为: class 子类 extends 父类{} 子类被称为派生类，父类又被称为超类。 子类继承父类，表名子类是一种特殊的父类，子类拥有父类的属性和方法，并且子类可以拓展具有父类所没有的一些属性和方法。 子类即是不扩展父类，也能维持拥有父类的操作。 优缺点 继承的好处 提高了代码的复用性 提高了代码的维护性 让类与类之间产生了关系，是多态的前提 缺点 增加了耦合性 OOP思想开发原则：高内聚，低耦合 耦合：类与类之间的关系 内聚：自身完成事情的能力 Java继承特点 Java只支持单继承，不支持多重继承操作（extends A,B,C..） 123class A &#123;&#125;class B &#123;&#125;class C extends A,B &#123;&#125; // 错误的，一个子类继承了两个父类，Java中不允许 为什么只支持单继承？ 多继承会存在安全隐患，因为当继承的多个类都存在相同的属性或方法名相同方法体不同的方法，子类进行调用时，就会产生不知道该调用哪一个类中的方法的情况。 Java支持多层继承（继承体系） 123class A &#123;&#125;class B extends A &#123;&#125;class C extends B &#123;&#125; 如果想用这个继承体系的所有功能，那么就实用对底层的子类创建的对象 如果想看这个体系的共性功能，那么就看最顶层的类的功能 继承注意点 成员变量和方法 子类只能继承父类的所有非私有的成员变量和方法。可以继承public protected 修饰的成员，不可以继承private修饰的。 但是可以通过父类中提供的public 的setter和getter方法进行间接的访问和操作private 的属性 对于子类可以继承父类中的成员变量和成员方法，如果子类中出现了和父类同名的成员变量和成员方法时，父类的成员变量会被隐藏，父类的成员方法会被覆盖。需要使用父类的成员变量和方法时，就需要使用super关键字来进行引用。 隐藏是针对成员变量和静态方法，覆盖是针对普通方法。 构造器 子类不能继承父类的构造方法，但是可以通过super关键字来访问父类构造方法。 super 和 this 的调用都必须是在第一句，否则会产生编译错误，this和super只能存在一个。 不能进行递归构造器调用，即多个构造器之间互相循环调用。 如果父类有无参构造时，所有构造方法（包含任意有参构造）自动默认都会访问父类中的空参构造方法。（自带super();） 因为继承的目的是子类获取和使用父类的属性和行为，所以子类初始化之前，一定要先完成父类数据的初始化。 在Java中，每个类都会默认继承Object超类，所以每一个构造方法的第一条默认语句都是super() 如果父类没有无参构造，反而有其他的有参构造方法时，子类继承父类后，子类必须显式的创建构造器，不论子类的构造器是否和父类构造器中参数类型是否一致，都必须在子类的构造器中显式的通过super关键字调用和父类构造器相应参数的构造方法。否则编译都通不过。代码示例如下： 123456789101112131415class Person &#123; public Person(int age)&#123; System.out.println(age); &#125; &#125;class Student extends Person&#123; public Student(int age) &#123; super(age); &#125; public Student()&#123; super(10); //必须调用父类的有参构造 System.out.println("子类可以创建其他类型构造器，但是必须显式的用super调用父类构造器") &#125;&#125; 也可以使用this先调用子类中的构造方法，再间接调用父类中的有参构造方法，实例如下： 12345678910111213141516171819202122public class ExtendTest1 &#123; public static void main(String[] args) &#123; new Student(); &#125;&#125;class Person &#123; public Person(int age)&#123; System.out.println("父类有参构造"); &#125;&#125;class Student extends Person&#123; public Student(int age) &#123; super(age); System.out.println("子类有参构造"); &#125; public Student()&#123; this(10); //可以使用this先调用子类中的有参构造，从而间接调用父类中的有参构造 System.out.println("子类无参构造"); &#125;&#125; 使用this，执行顺序结果为：先调用了子类中无参构造，此无参构造会接着调用子类中的有参构造，又接着调用父类中的有参构造，此时首先执行完毕了父类有参构造，接着子类有参构造执行完毕，最后子类无参构造才执行完毕。 123父类有参构造子类有参构造子类无参构造 以下这种是错误的：（因为当父类中没有无参构造器时，父类中没有这种类型的构造方法） 1234567891011121314151617class Student extends Person&#123; public Student(String name)&#123; super(); &#125; //错误的，因为当父类中没有无参构造器时，父类中没有这种类型的构造方法 public Student(int age) &#123; super(age); &#125;&#125; class Person &#123; public Person(String name ,int age)&#123; System.out.println(name+age); &#125; public Person(int age)&#123; System.out.println(age); &#125;&#125; 以下这种正确：（因为当父类中没有无参构造器时，子类中的构造方法的类型在父类中有） 123456789101112131415class Student extends Person&#123; //因为当父类中没有无参构造器时，子类中的构造方法的类型在父类中有 public Student(int age) &#123; super(age); &#125;&#125; class Person &#123; public Person(String name ,int age)&#123; System.out.println(name+age); &#125; public Person(int age)&#123; System.out.println(age); &#125;&#125; 123456789101112131415161718class Student extends Person&#123;//因为当父类中没有无参构造器时，子类中的构造方法的类型在父类中有 public Student(String name ,int age)&#123; super(name,age); &#125; public Student(int age) &#123; super(age); &#125;&#125; class Person &#123; public Person(String name ,int age)&#123; System.out.println(name+age); &#125; public Person(int age)&#123; System.out.println(age); &#125;&#125; 结论：**当父类中没有无参构造器时，子类继承父类，子类中的构造器方法类型可以和父类中的构造器不同，但是必须每个构造器都显式的使用super关键字调用父类中的某个有参构造器，也可以使用this调用子类中的某个有参构造器，但这个有参构造器必须通过super访问父类中的有参构造器。** 继承的执行顺序问题 父类和子类中都有静态代码块和构造代码块，示例如下： 1234567891011121314151617181920212223242526272829303132class Test2_Extends &#123; public static void main(String[] args) &#123; Zi z = new Zi(); &#125;&#125;class Fu &#123; static &#123; System.out.println("静态代码块Fu"); &#125; &#123; System.out.println("构造代码块Fu"); &#125; public Fu() &#123; System.out.println("构造方法Fu"); &#125;&#125;class Zi extends Fu &#123; static &#123; System.out.println("静态代码块Zi"); &#125; &#123; System.out.println("构造代码块Zi"); &#125; public Zi() &#123; System.out.println("构造方法Zi"); &#125;&#125; 此时的执行结果： 123456静态代码块Fu静态代码块Zi构造代码块Fu构造方法Fu构造代码块Zi构造方法Zi 执行顺序分析： 主类Test2_Extends先加载到内存，其中的main方法入栈执行，main方法中创建了子类对象 子类对象创建过程中，父类和子类都加载到内存中，并且Fu.class优先于Zi.class加载，父类中的静态域先执行后，再执行子类中的静态域，此时会第一个输出：静态代码块Fu，第二个输出：静态代码块Zi 创建对象时进入子类的构造器，因为Java是分层初始化的，所以会先初始化父类再初始化子类，子类构造器会自动默认先执行父类的构造器，因为构造代码块优先于构造方法执行，所以此时就会先执行父类的构造代码块后，再执行父类的构造方法。所以第三个输出：构造代码块Fu，第四个输出：构造方法Fu Fu类初始化结束后，子类初始化，第五个输出的是：构造代码块Zi，第六个输出：构造方法Zi 方法重写 重写：子父类出现一模一样的方法，但返回值类型可以是子父类。 方法重写的应用： 当子类需要父类的功能，而功能主体子类有自己的特有内容时，可以重写父类中的方法。即沿用了父类的功能，又定义了子类特有的内容 重写注意点 父类中的私有方法不能被重写 因为父类的私有方法子类无法继承，得不到 子类重写父类方法时，访问权限不能更低，子类方法访问权限应该大于或等于父类的，最好和父类中一致 父类静态方法，子类也必须通过静态方法进行覆盖，即静态只能覆盖静态 子类重写父类方法时，最好声明得一模一样 重写和重载 Override 和 Overload 的区别？Overload能改变返回值类型吗？ Override是重写，Overload是重载。重载可以改变返回值类型，它是方法名相同，参数列表不同，与返回值类型无关。 方法重写：子类中出现和父类中方法声明一模一样的方法。返回值类型相同（或者是子父类，多态），方法名和参数列表一模一样 方法重载：本类中出现方法名相同，参数列表不同的方法，和返回值类型无关，可以改变。 子类对象调用方法时，先找子类本身的方法，再找父类中的方法。 final实例域 可以将实例域定义为final。构造对象时必须初始化这样的域。 必须确保在每一个构造器执行之后，这个域的值被设置初始化，并且在后面的操作中，不能够再对它进行修改。 final修饰的大都应用于基本类型域，或不可变类的域。 不可变类：如果类中的每个方法都不会改变其对象，这种类是不可变的类。例如String类。 对于可变类，使用final修饰只是表示存储在对象变量中的对象引用不会再指向其他对象，不过这个对象中的属性可以更改。 final修饰特点 修饰类时，类不能被继承。 修饰变量时，变量就变成了常量，只能被初始化赋值一次，后续不可进行改变。一般与 public static 配合使用。 修饰方法时，方法不能被重写。 final修饰局部变量时： 方法内部或者方法声明上 基本类型：值不能被改变 引用类型：地址引用不能被改变，不会再指向其他对象，但是对象中的属性可以改变。会报 “无法为最终变量x分配值” 的错误 final变量的初始化时机 final修饰的成员变量必须显式的进行初始化赋值，否则默认的是个无效值，会报“可能尚未初始化变量xxx”的错误。 1234567//方式1：直接进行显式得初始化赋值，不进行赋值，会报错Class Demo&#123; final int num ; //没有显式赋值，报错 final int num = 10； //进行显式得初始化赋值 public Demo()&#123; &#125;&#125; 也可以在构造方法执行完毕前对其进行初始化赋值 1234567//方式2：在构造方法执行完毕之前进行赋值初始化Class Demo&#123; final int num; public Demo()&#123; num = 10; //在构造方法执行完毕之前进行赋值初始化 &#125;&#125;]]></content>
      <categories>
        <category>Java面向对象</category>
      </categories>
      <tags>
        <tag>Java面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象(一) 类与对象以及方法]]></title>
    <url>%2F2018%2F06%2F23%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%B8%80)%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java面向对象(一) 类与对象以及方法面向对象概述 面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。 在OOP中，不必关心对象的具体实现，只要能够满足用户的需求即可。 类 类是构造对象的模板或蓝图。 Java编写的所有代码都位于某个类的内部。 Java中的类文件时以.java为后缀的代码文件，在每个类文件中最多只允许出现一个public类。 当有public类时，类文件名必须和public类的名称相同。 当没有public类时，类文件名可以是任意合法名称。 实例 由类构造对象的过程称为创建类的实例。 封装 封装也称为数据隐藏，是面向对象思想的三大特性之一。 从形式上看，封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。 实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。 程序也是仅仅通过对象的方法与对象的数据进行交互。 好处： 封装给对象赋予了“黑盒”特征，这是提高重用性和可靠性的关键。 一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。 对象 对象的三个主要特征： 对象的行为（behavior）：可调用的方法 对象的状态（state）：描述当前对象的特性信息 对象的标识（identity）：进行辨别具有相同行为与状态的不同对象 对象中的数据称为实例域，操纵数据的过程称为方法。 对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（state）。 无论何时，只要对象发送一个消息，它的状态就有可能发生改变。 对象的状态的改变必须通过调用方法实现，不会自发改变。如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏。 对象的状态并不能完全描述一个对象，每个对象都有一个唯一的身份标识。 作为一个类的实例，每个对象的标识永远是不同的，状态也常常存在差异。 对象变量 一个对象变量并没有实际包含一个对象，而仅仅引用一个对象 Java中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。new操作符的返回值也是一个引用，这个返回值引用存储在对象变量中。 Java中，局部变量不会自动初始化为null，而必须通过调用new或者将他们设置为null进行初始化。 成员变量初始化 在Java类内部，对于成员变量，如果在定义时没有直接进行赋值初始化，那么Java会保证类的每个成员变量都得到对应的初始化值。 对于基本类型变量，char short byte int long float double 等都会默认初始化为0，boolean类型变量值默认会被初始化为false。 对于引用类型的变量，会默认初始化为null 方法（行为）方法重载 方法名相同，与返回值类型无关，只看参数列表 构造器 构造器概述和作用： 给对象的数据（实例域）进行初始化 构造器规则： 构造器必须与类同名 每个类可以有一个或者多个构造器（构造方法的重载） 构造器可以有0个、1个或者多个参数（构造方法的重载） 构造器没有返回类型，连void都没有 构造器没有返回值，但是默认会有return;，可以省略 构造器总是伴随着null操作符一起调用 注意点： 不要在构造器中定义与实例域重名的局部变量 构造方法不能使用该类的对象调用，即：p.Person()是错误的 如果我们自身没有给出构造方法， 系统将自动提供一个无参构造方法。 如果我们给出了构造方法，系统将不再提供默认的无参构造方法。 建议永远自己给出无参构造方法。 访问器方法 在类中，例如getXxx()方法，用于获取实例域值（属性值）的方法称为访问器。 可以自定义改变内部实现，除了该类的方法之外，不会影响其他代码 为什么不直接让属性使用public修饰，直接获取？ 如果使用public进行修饰，就破坏了封装的思想，那么破坏这个属性值的有可能会出现在任何地方。 属性在类中进行封装，它是一个只读域，一旦在构造器中设置完毕，就没有任何一个办法可以对其进行修改，从而来确保属性不会受外界的破坏。 更改器方法 在类中，例如setXxx()方法，用于更改实例域值（属性值）的方法 为了进行新旧数据之间的转换 可以执行错误检查，然而直接对域进行赋值将不会进行这些处理 一个私有的数据实例域 一个公有的域访问器方法 一个公有的域更改器方法 可变对象注意点注意： 不要编写返回引用可变对象的访问器方法！ 一个Date类的实例：Date类中本身有一个更改器方法setTime 可以设置毫秒数，此时的Date对象是可变的，破坏了封装性，就会发生数据不一致。 12345678910111213141516171819202122232425public class DateTest &#123; public static void main(String[] args) &#123; Student student = new Student(new GregorianCalendar().getTime()); Date d = student.getDay(); System.out.println(student.getDay()); //Thu Jul 19 11:15:02 CST 2018 //Date对象d内部提供了一个方法 可以设置时间 d.setTime(d.getTime()-(long)10*365*24*3600*1000); //虽然没有使用Student对象设置时间，最后还是回到了10年前 //说明该Student类中的Date对象属性可以被除了Student本身的对象方法改变，存在了数据安全隐患 //破坏了封装性 System.out.println(student.getDay()); //Mon Jul 21 11:15:02 CST 2008 &#125; &#125; class Student &#123; private Date day; public Student(Date day)&#123; this.day = day; &#125; public Date getDay()&#123; return day; &#125;&#125; 上述代码执行结果： 12Thu Jul 19 11:15:02 CST 2018Mon Jul 21 11:15:02 CST 2008 由此发现： 虽然没有使用Student对象设置时间，最后还是回到了10年前，说明该Student类中的Date对象属性可以被除了Student本身的对象的方法改变，存在了数据安全隐患，破坏了封装性 如果实在是需要返回一个可变对象的引用，应该对它进行克隆。 对象clone是指在另一个位置存放一个对象副本。 更改访问器代码： 1234public Date getDay()&#123;//由于Date类对象是一个可变对象，所以应使用clone，保证数据不被外界修改 return (Date) day.clone();&#125; 给成员变量赋值的两种方式 使用更改器修改属性值： setXxx()方法 使用构造器，给对象初始化属性值 隐式参数与显式参数 隐式参数 出现在方法名前的类对象 Java中常常使用this关键字表示 显式参数 位于方法名后面括号中的数值，明显地列在方法声明中 main方法 在Java中，main方法是Java程序的入口，Java核心编程中，JVM会查找类中的public static void mian(String[] args)，如果找不到该方法就会抛出错误NoSuchMethodError:main程序终止。 main 方法必须严格遵循它的语法规则，即它的方法签名必须是public static void ，方法名必须是main，参数是字符串数组类型，参数名可以随意更改。Jdk1.5以后还可以使用可变参数：public static void main(String... args) main方法的规则 必须是static的 因为需要被JVM调用，不用创建对象实例，直接类加载就可以访问。 需要JVM的调用，因为main方法是静态的，JVM调用这个方法时就不需要创建包含这个main方法的类的实例。 反之，如果不是静态的，JVM就必须需要创建包含这个main方法的类的实例， 因为构造器可以被重载，JVM就没法确定调用哪个main方法。 必须是public修饰 因为需要被JVM调用，权限为public就可以轻松的访问执行它。 必须是void类型的 因为被JVM调用，不需要有任何的返回值 方法名必须是main 因为只有方法名是main，JVM才会识别，注意main不是一个关键字。 参数必须是String[]数组类型或者String... 可变参数类型 除了static void public ，还可以使用final synchronized和strictfp关键字就行修饰main方法 main方法可以像其他方法一样被重载，但是JVM还是会调用上面这种签名规范的main方法。 可以使用throws子句在main方法中，可以抛出任何checked和unchecked异常。 静态域在JVM调用main方法之前就初始化了，它们在类被JVM加载到内存是就执行了。]]></content>
      <categories>
        <category>Java面向对象</category>
      </categories>
      <tags>
        <tag>Java面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java面向对象(二) 静态域、代码块和内存区域图]]></title>
    <url>%2F2018%2F06%2F23%2FJava%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1(%E4%BA%8C)%20%E9%9D%99%E6%80%81%E5%9F%9F%E5%92%8C%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Java面向对象(二) 静态域、代码块和内存区域图静态域 将域定义成static后，每个类中只有一个这样的域，与类相关的，也称为类成员。但是每个对象对于所有的实例域却都有自己的一份拷贝。 静态域会随着类的加载而加载并初始化，存在于方法区内存中的字节码文件的静态区域中。 优先于对象存在，先有方法区的类加载，后才可能会有堆内存的对象实例化。 静态域会被所有的对象共享，也称为共享区。 一般共性用静态，特性用非静态。 一般通过类名直接调用，虽然也可以通过对象名调用，但是不推荐，也不合适。 static关键字注意事项 在静态方法中没有this关键字 静态是随着类的加载而初始化，而this是随着对象的创建而存在的。 静态比对象优先存在。 静态方法只能访问静态成员和静态成员方法，即静态只能访问静态 静态方法： 成员变量：只能访问静态变量 成员方法：只能访问静态成员方法 非静态方法： 成员变量：可以是静态的，也可以是非静态的 成员方法：可以是静态的成员方法，也可以是非静态的成员方法。 静态变量和成员变量区别 静态变量也叫类变量，成员变量也叫对象变量。 所属不同 静态变量属于类 成员变量属于对象 内存中的位置不同： 静态变量存储于方法区的静态区 成员变量存储于堆内存 代码块代码块概述 Java中，使用{}括起来的代码称为代码块 代码块的分类 根据位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块和同步代码块 代码块的应用 局部代码块 在方法中出现，可以限定变量的生命周期，及早释放，提高内存利用率。 构造代码块（初始化代码块） 在类中方法外出现，将多个构造器中的相同代码放到一起，每次调用构造器都执行，并且在构造方法前执行。 静态代码块 在类中方法外出现，并且用static修饰，用于给代码块中的代码静态化，加入静态域中，在类加载的时候直接执行，并且只执行一次。 静态代码块优先于main方法执行。 一般常用于加载驱动、IO操作等消耗资源的代码 代码块面试题根据程序写输出结果，考察执行顺序 1234567891011121314151617181920212223242526class Student &#123; static &#123; System.out.println("Student 静态代码块"); &#125; &#123; System.out.println("Student 构造代码块"); &#125; public Student() &#123; System.out.println("Student 构造方法"); &#125;&#125; class StudentTest &#123; static &#123; System.out.println("StudentTest静态代码块"); &#125; public static void main(String[] args) &#123; System.out.println("我是main方法"); Student s1 = new Student(); Student s2 = new Student(); &#125;&#125; 测试结果： 1234567StudentTest静态代码块我是main方法Student 静态代码块Student 构造代码块Student 构造方法Student 构造代码块Student 构造方法 分析： ​ main方法是Java程序的入口，JVM先找main方法，先把有main方法的类加载到内存中，此时StudentTest类的静态代码块直接随着类的加载而先执行； ​ 随后main方法开始执行，当Student类被实例化后，Student类的静态代码块先执行，并且只执行一个，不管实例化多少对象； ​ 之后，每实例化一次Student类，类中的构造代码块比构造方法就会先执行，并且每实例化一次就执行一次。 初始化执行顺序总结 当程序执行时，如果需要创建某个类的对象，那么Java会先检查是否加载了这个类，如果没有加载，则先执行类的加载再生成对象。如果已经加载，则直接生成对象。 类的执行顺序过程： 首先类先加载到方法区内存中，类的静态域会先被加载并且初始化并且优先于main方法执行。Java中类的加载时按需加载，需要时才加载，并且只加载一次。 静态成员变量和静态代码块的执行顺序同代码中的顺序一致。 每创建一次对象时，先初始化对象中的成员变量，再执行构造代码块，其次再执行构造方法。 类中的变量会在任何方法（包括构造器）调用之前得到初始化，即使变量散布于方法定义之间。 Java内存区域分配 此分配图基于Java8之前版本]]></content>
      <categories>
        <category>Java面向对象</category>
      </categories>
      <tags>
        <tag>Java面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库高并发下乐观锁的原理]]></title>
    <url>%2F2018%2F06%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%B9%B6%E5%8F%91%E4%B8%8B%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据库高并发下乐观锁的原理在高并发下，经常需要处理SELECT之后，在业务层处理逻辑，再执行UPDATE的情况。 若两个连接并发查询同一条数据，然后在执行一些逻辑判断或业务操作后，执行UPDATE，可能出现与预期不相符的结果。 在不使用悲观锁与复杂SQL的前提下，可以使用乐观锁处理该问题，同时兼顾性能。 场景模拟： 假设一张表两个字段，一个id，一个use_count。表里存了100个id，每个id对应自己的use_count。 当id每使用一次，use_count要加1。当use_count大于1000时，这个id就不能在被使用了（换句话说 无法从数据库中查出）。 在高并发情况下，会遇到一种问题：假设数据表中有一条记录为：id=123456, use_count=999A与B两个连接并发查询这个id=123456，都执行下列SQL: 1`SELECT * FROM table WHERE id=123456 and use_count &lt; 1000;` A先执行，得到id=123456的use_count是999，之后在程序里做了一些逻辑判断或业务操作后执行SQL： 1`UPDATE table SET use_count + 1 WHERE id=123456;` 在A做判断且没有update之前，B也执行了查询SQL，发现use_count是999，之后它也会执行SQL： 1`UPDATE table SET use_count + 1 WHERE id=123456;` 但是，事实上B不应该取得这个id，因为A已经是第1000个使用者。 处理步骤如下： 1、添加第3个字段version，int类型，default值为0。version值每次update时作加1处理。 1`ALTER TABLE table ADD COLUMN version INT DEFAULT &apos;0&apos; NOT NULL AFTER use_count; ` 2、SELECT时同时获取version值（例如为3）。 1`SELECT use_count, version FROM table WHERE id=123456 AND use_count &lt; 1000;` 3、UPDATE时检查version值是否为第2步获取到的值。 1`UPDATE table SET version=4, use_count=use_count+1 WHERE id=123456 AND version=3;` 如果UPDATE的记录数为1，则表示成功。如果UPDATE的记录数为0，则表示已经被其他连接UPDATE过了，需作异常处理。]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>乐观锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络知识]]></title>
    <url>%2F2018%2F06%2F21%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[计算机网络知识OSI和TCP/IP各层的结构和功能OSI体系协议应用层 表示层 会话层 运输层 网络层 数据链路层 物理层 TCP/IP协议体系应用层 运输层 网际层 网络接口层 五层协议体系应用层 运输层 网络层 数据链路层 物理层 各层的作用应用层 通过应用进程间的交互来完成特定的网络应用 应用层的协议定义的是应用进程间的通信和交互的规则 对于不同的网络应用需要使用不同的应用层协议 常用的应用层协议有：DNS（域名系统）HTTP（超文本传输协议） 支持电子邮件的SMTP协议 应用层交互的数据单元称为报文。 DNS 域名系统（Domain Name System） 是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 HTTP 超文本传输协议，是互联网上应用最为广泛的一种网络协议，所有的万维网文件都必须遵守这个标准，设计HTTP最初是为了提供一种发布和接收HTML页面的方法。 运输层 主要作用是负责两台主机进程之间的通信，提供通用的数据传输服务。 运输层主要使用以下两种协议： 传输控制协议 TCP（Transmission Control Protocol）提供面向连接的，可靠的数据传输服务 用户数据协议 UDP（User Datagram Protocol）提供无连接的，尽最大努力的数据传输服务，不保证数据可靠性 UDP UDP是无连接的 UDP使用尽最大努力交付，不保证可靠交付，因此主机不需要维持复杂的链接状态 UDP是面向报文的 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低，所以对实时传输应用很有用，如 直播，实时视频会议等 UDP支持一对一、一对多、多对一和多对多的交互通信 UDP的首部开销小，只有8个字节，比TCP的20个字节首部要短 TCP TCP是面向连接的，传输数据之前要先建立连接，传输结束之后，要释放连接。 每一条TCP连接只能由两个端点，每一条TCP连接只能是点对点的，一对一的 TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达。 TCP面向字节流。流是指流入进程或从进程流出的字节序列。面向字节流的含义是： 虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。 TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。 网络层 主要负责为分组交换网上的不同主机提供通信服务，并且选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报，简称 数据报。 数据链路层 两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻界节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等） 在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。 物理层 物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。 TCP协议如何保证可靠传输 应用数据被分割成TCP认为最适合发送的数据块 TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 校验和： TCP将保持它首部和数据的校验和。 TCP的接收daunting会丢弃重复的数据 流量控制 拥塞控制 停止等待协议 超时重传 打开一个网页，整个过程会使用哪些协议 DNS：获取域名对应的IP地址 TCP：与服务器建立TCP连接 IP：建立TCP连接时，需要使用网络层的IP协议发送数据 OPSF：IP数据包在路由之间，路由选择时使用OPSF协议 ARP：地址解析协议，路由器在与服务器通信时，需要将IP地址转换成MAC地址，需要使用ARP协议 HTTP：在TCP建立连接完成后，使用HTTP协议访问网页 状态码 状态码 类别 原因短语 1XX 信息性状态码 接收的请求正在处理 2xx 成功状态码 请求正在处理完毕 3xx 重定向状态码 需要进行附加操作以完成请求 4xx 客户端错误状态码 服务器无法处理请求 5xx 服务器错误状态码 服务器处理请求出错 HTTP长连接和短连接在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次连接，任务结束就中断连接。当客户端浏览器访问的某个html或其他类型的web页中包含有其他的web资源（如js、图像、css等），没遇见这样一个web资源，浏览器就会重新建立一个HTTP会话。 而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应投加入这行代码：Connection:keep-alive 在使用长连接时，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。 Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件中设定这个时间。实现长连接需要客户端和服务端都支持长连接。 TCP的三次握手过程中，accept发生在三次握手的哪个阶段？发生在三次握手之后，分析一下“三次握手”的过程： 1、服务端处于LISTEN状态，客户端处于CLOSED状态； 2、客户端打开，并进行SYN的发送，处于SYN_SENT状态； 3、服务端收到此条消息后，转为SYN_RCVD状态，并对客户端进行消息回复； 4、客户端收到此条消息后，转为ESTABLISHED状态，并发送一个ACK的确认消息。 5、服务端收到此条消息后，转为ESTABLISHED状态。 至此，三次握手完成。 然而，聪明的你，通过上面的分析，你可能会得到这样的结论：accept()发生在第3步，原因是，此时accept()函数需要给此次连接分配资源。的确，最初是想这样设计的。但是，设想一个情景，若有10000个客户端都和该服务端进行连接，发送SYN，服务端收到之后，这些客户端却不再理会服务端的回复，然而此时服务端的资源却都用accept()分配了。这就是所谓的“DDOS攻击”。 为了解决这个问题，accept()于是被放在三次握手之后。 当然，这样也不能保证不能被攻击，当然这是后话]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础-一些重要的基本概念]]></title>
    <url>%2F2018%2F06%2F20%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E9%A1%BE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[多线程基本概念程序(program) 为了完成特定任务、用某种语言编写的一组指令的集合。即一段静态的代码，静态对象。 进程(process) 程序的一次执行过程，或者是正在运行的一个程序，是动态过程。 动态过程：有自身的产生、存在和消亡的过程。 程序是静态的，而进程是动态的。 线程(thread) 进程可以进一步细化为线程，是一个程序内部的一条执行路径。 若一个程序可同一时间执行多个线程，那么这个程序就支持多线程。 Java中的线程 Java线程是依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码，只有本地线程才是真正的线程实体。 Java代码中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体 多线程的用处 发挥多核CPU的优势，大大提高效率 防止多余的阻塞 单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率 ，但是单核CPU我们还是要应用多线程，就是为了防止阻塞 。 多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行 方便进行业务拆分，提升应用性能 时间片 时间片是CPU调度给各个线程的时间。 并行和并发 并行：多个任务同时进行，必须有多核CPU的支持 并发：指多个任务都请求运行，而处理器只能接受一个任务，就是把多个任务轮流进行，由于轮转时间间隔过短，让人感觉是多个任务都在同时运行。 同步和异步 同步和异步通常用来形容一次方法调用。 同步方法调用一开始，调用者必须等待被调用的方法执行结束后，才能执行后面的代码。 异步方法调用后，调用者不用理会调用方法是否执行完毕，都会继续执行后面的代码，当被调用的方法完成之后会通知调用者。 临界区 临界区表示一种公共资源，共享数据，可以被多个线程使用。 一旦临界区资源被一个线程占用时，其他线程必须等待其使用完毕后才能使用。 阻塞和非阻塞 阻塞和非阻塞通常用来形容多线程之间的相互影响。 当一个线程占用了临界区资源，那么其他线程需要这个资源就必须等待该资源被那个线程释放，这就会导致等待的线程挂起，这种情况就是阻塞。 非阻塞强调没有一个线程可以阻塞到其他线程，所有的线程都会尝试地往前运行。和阻塞正好相反。 问题引入 Java程序的运行原理？ Java命令会启动Java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。这个进程会自动的启动一个主线程，然后主线程调用类中的main方法。 实际上java程序天生就是一个多线程程序，包含了： （1）分发处理发送给给JVM信号的线程 （2）调用对象的finalize方法的线程 （3）清除Reference的线程； （4）main线程，用户程序的入口 JVM的启动是多线程吗？ JVM的启动至少启动了主线程和垃圾回收线程，所以是多线程的。]]></content>
      <categories>
        <category>Java多线程基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE回顾-多线程基础知识整合]]></title>
    <url>%2F2018%2F06%2F20%2FJavaSE%E5%9B%9E%E9%A1%BE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JavaSE回顾-多线程基础知识整合多线程基本概念程序(program) 为了完成特定任务、用某种语言编写的一组指令的集合。即一段静态的代码，静态对象。 进程(process) 程序的一次执行过程，或者是正在运行的一个程序，是动态过程。 动态过程：有自身的产生、存在和消亡的过程。 程序是静态的，而进程是动态的。 线程(thread) 进程可以进一步细化为线程，是一个程序内部的一条执行路径。 若一个程序可同一时间执行多个线程，那么这个程序就支持多线程。 Java中的线程 Java线程是依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码，只有本地线程才是真正的线程实体。 Java代码中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体 多线程的用处 发挥多核CPU的优势，大大提高效率 防止多余的阻塞 单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率 ，但是单核CPU我们还是要应用多线程，就是为了防止阻塞 。 多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行 方便进行业务拆分，提升应用性能 时间片 时间片是CPU调度给各个线程的时间。 并行和并发 并行：多个任务同时进行，必须有多核CPU的支持 并发：指多个任务都请求运行，而处理器只能接受一个任务，就是把多个任务轮流进行，由于轮转时间间隔过短，让人感觉是多个任务都在同时运行。 同步和异步 同步和异步通常用来形容一次方法调用。 同步方法调用一开始，调用者必须等待被调用的方法执行结束后，才能执行后面的代码。 异步方法调用后，调用者不用理会调用方法是否执行完毕，都会继续执行后面的代码，当被调用的方法完成之后会通知调用者。 临界区 临界区表示一种公共资源，共享数据，可以被多个线程使用。 一旦临界区资源被一个线程占用时，其他线程必须等待其使用完毕后才能使用。 阻塞和非阻塞 阻塞和非阻塞通常用来形容多线程之间的相互影响。 当一个线程占用了临界区资源，那么其他线程需要这个资源就必须等待该资源被那个线程释放，这就会导致等待的线程挂起，这种情况就是阻塞。 非阻塞强调没有一个线程可以阻塞到其他线程，所有的线程都会尝试地往前运行。和阻塞正好相反。 问题引入 Java程序的运行原理？ Java命令会启动Java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。这个进程会自动的启动一个主线程，然后主线程调用类中的main方法。 实际上java程序天生就是一个多线程程序，包含了： （1）分发处理发送给给JVM信号的线程 （2）调用对象的finalize方法的线程 （3）清除Reference的线程； （4）main线程，用户程序的入口 JVM的启动是多线程吗？ JVM的启动至少启动了主线程和垃圾回收线程，所以是多线程的。 多线程的实现方式方式一： 继承Thread类 Thread类实现了Runnable接口，在java.long包下。 创建执行线程方法一：将类继承Thread类，重写Thread类的run方法。接下来就可以分配并启动该子类的实例。 具体步骤： 继承Thread类 重写run方法 将执行的代码写在run方法中 创建Thread类的子类对象 使用start方法开启线程。 注意：调用run方法不能开启多线程。 只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。 一个线程不能多次开启是非法的 代码示例： 12345678910111213141516171819202122public class ThreadTest &#123; public static void main(String[] args) &#123; //4，创建Thread类的子类对象 MyThread mt = new MyThread(); mt.start();//5，使用start方法开启线程 for (int i = 0; i &lt; 10000; i++) &#123; System.out.println("main" + i); &#125; &#125;&#125;class MyThread extends Thread&#123; //1.继承Thread类 //2，重写run方法 @Override public void run()&#123; //3，将执行的代码写在run方法中 for (int i = 0; i &lt;10000 ; i++) &#123; System.out.println("mt"+i); &#125; &#125;&#125; 方式二：实现Runnable接口（常用，优点多） 声明实现Runnable接口的类，实现Runnable接口中仅有的run方法，然后分配实例对象，在创建Thread时作为一个参数来传递并启动。 具体步骤 1，定义类实现Runnable接口 2，在该类中实现Runnable接口中的run()方法 3，线程中具体要执行的东西写在run()方法中 4，创建Thread类的对象，并在该对象中传入该实现Runnable接口的对象作参数 5，Thread类的对象调用start()方法开启新线程，其内部会自动的调用run方法 12345678910111213141516171819202122public class RunnableTest &#123; public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); //4、创建自己定义的Runnable实现类的对象 Thread thread = new Thread(mr); //5、创建Thread类的对象，并将自定义Runnable实现类的对象作为参数传递给Thread的构造函数 thread.start(); //使用thread类的start方法开启线程。 for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("main+"+i); &#125; &#125;&#125;//1、定义一个Runnable实现类class MyRunnable implements Runnable&#123; //2、实现Runnable接口中的抽象方法 @Override public void run() &#123; //3、在run方法中写入要使用多线程的具体方法 for (int i = 0; i &lt;1000; i++) &#123; System.out.println("mr"+i); &#125; &#125;&#125; 实现Runnable接口方式的实现原理 1、查看Thread 类的构造函数，传递了Runnable接口的引用，直接调用了init方法。 123public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0); &#125; 2、追踪init方法，在init方法体中找到了传递的target参数，赋值给了Thread类的Runnable接口的成员变量的target 1this.target = target; 12/* What will be run. */ private Runnable target; 3、查看run方法时，发现run方法中有判断，如果target不为null就会调用实现Runnable接口子类对象的run方法 123456@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 为什么实例效果不明显？ 多线程指的是多个线程的代码块可以同时运行，而不必一个线程去等待另一个线程执行完才可以进行。 对于单核CPU来说，无法做到真正意义上的多线程特性。只能会让用户看起来像是同时执行的，因为每个时间点上，CPU都会执行特定的代码，由于CPU执行代码时间非常快，多个线程代码块就会轮询执行，速度很快，但是同一个线程进行的轮询操作。 具体执行某段代码多长时间和分时机制系统密切相关。 分时系统把CPU时间划分为多个时间片，操作系统以时间片为单位执行各个线程的代码，时间片越小，执行效率越高。 多线程的两种实现方式的区别 源码中的区别 继承Thread类方式：由于子类重写了Thread类的run()，当调用start()时，直接找子类的run()方法(Java虚拟机自动完成) 实现Runnable方式：构造函数中传入了Runnable的引用，传给了Thread类中的成员变量，start()调用了run()方法时的内部判断成员变量Runnable的引用是否为空，若不为空，编译时看的是Runnable的run()，运行时执行的是具体实现类中的run() 优缺点： 继承Thread类方式 好处：可以直接使用Thread类中的方法，代码简单 弊端：同样也是面向对象中的继承的缺点：如果该具体类已经有了其他的父类，那么就不能多重继承Thread类，就不能使用这种方法。此时面向接口编程的优势脱颖而出。 实现Runnable接口方式 好处：即继承的弊端：即使自己定义的线程类有了其他父类也可以实现该Runnable接口。Java中的接口是多实现的，继承是单继承，比较有局限性。 弊端：不能直接使用Thread类中的方法，需要先把Runnable具体实现类对象传递给Thread类并获取到线程对象后，才能得到Thread类的方法，代码相对复杂 匿名内部类实现线程的两种方式即直接使用匿名内部类的方式简化代码： 继承Thread类方式 123456789//匿名内部类new Thread()&#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("t+"+i); &#125; &#125;&#125;.start(); 实现Runnable接口方式 123456789//匿名内部类new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt;1000; i++) &#123; System.out.println("mr"+i); &#125; &#125;&#125;).start(); Runnable接口是一个函数式接口，可以直接用Lambda表达式代替: 123456//Lambda表达式new Thread(()-&gt;&#123; for (int i = 0; i &lt;1000; i++) &#123; System.out.println("mr"+i); &#125;&#125;).start(); 方式三：实现Callable接口 步骤： 创建实体类，实现Callable接口 实现接口中的call()方法 利用 ExecutorService线程池对象 的 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task()方法提交该Callable接口的线程任务。 123456789101112131415161718192021222324252627282930// 创建线程池ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程Future&lt;Integer&gt; f1 = pool.submit(new MyCallable(100));Future&lt;Integer&gt; f2 = pool.submit(new MyCallable(200));// V get()Integer i1 = f1.get();Integer i2 = f2.get();System.out.println(i1);System.out.println(i2);// 结束pool.shutdown();public class MyCallable implements Callable&lt;Integer&gt; &#123; private int number; public MyCallable(int number) &#123; this.number = number; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int x = 1; x &lt;= number; x++) &#123; sum += x; &#125; return sum; &#125;&#125; 利用匿名内部类方式： 123456789101112131415ExecutorService service = Executors.newSingleThreadExecutor(); Future&lt;String&gt; future = service.submit(new Callable() &#123; @Override public String call() throws Exception &#123; return "通过实现Callable接口"; &#125; &#125;); try &#123; String result = future.get(); System.out.println(result); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; Lambda表达式方式： 12345678910111213public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //使用Executors工厂类创建一个单线程池 ExecutorService es = Executors.newSingleThreadExecutor(); //使用这个单线程提交一个Callable接口线程服务，返回值为String //Callable接口是一个函数式接口，Java8开始可以直接使用Lambda表达式表示 //其内部实现了call()方法 V call() throws Exception; //并得到该结果值打印 System.out.println( es.submit(()-&gt;"使用lambda表达式的Callable接口").get()); es.shutdown(); //关闭该线程池 &#125;&#125; 实现callable接口，提交给ExecutorService返回值是异步执行的。 该方式的优缺点： 优点： 有返回值 可以抛出异常 缺点： 代码较复杂，需要利用线程池 线程相关实例方法获取线程ID- getId 在一个Java应用程序中，有一个long型的全局唯一的线程ID生成器threadSeqNumber，每new出来一个线程就会自增一次，从0开始，并且赋值给线程的tid属性。 用户只能获取ID，不能执行一个线程的ID，这是Thread类内部自己完成的。 获取和设置线程的名字 获取线程名 通过getName()方法获取线程对象名 123456new Thread()&#123; @Override public void run() &#123; System.out.println(this.getName());//Thread-0 &#125;&#125;.start(); 设置线程名 通过构造函数传入String类型名 12345678910111213new Thread("线程1")&#123; @Override public void run() &#123; System.out.println(this.getName());//线程1 &#125;&#125;.start();new Thread("线程2")&#123; @Override public void run() &#123; System.out.println(this.getName());//线程2 &#125;&#125;.start(); 12345//Lambda表达式的Runnable方式，Thread的构造函数Thread t2 = new Thread(() -&gt; System.out.println("线程5的执行方法体"),"线程5");t2.start();System.out.println(t2.getName());//线程5 通过setName(String name)方法设置 1234567new Thread()&#123; @Override public void run() &#123; this.setName("线程3"); System.out.println(this.getName());//线程3 &#125;&#125;.start(); 12345678Thread t1 = new Thread() &#123; @Override public void run() &#123; System.out.println(this.getName());//线程4 &#125;&#125;;t1.setName("线程4");t1.start(); 12345678Thread t1 = new Thread(()-&gt; System.out.println("线程4的执行方法体"));t1.setName("线程4");t1.start();System.out.println(t1.getName());//线程4/* 线程4 线程4的执行方法体 */ 线程对象是否处于活动状态 - isAlive t.isAlive() 测试线程t是否处于活动状态，只要线程启动并且没有终止，方法返回值就是true。 start()之前，线程不处于活动状态，之后就处于了活动状态。 获取当前线程的对象 Thread.currentThread() 静态方法，获取当前执行线程， 主线程也可以获取 1234//Runnable接口方式//new Thread(Runnable target,String threadName) 构造方法new Thread(()-&gt; System.out.println(Thread.currentThread().getName()),"线程6") .start();//线程6 在main方法中可以获取主线程对象并设置： 12Thread.currentThread().setName("我是主线程");System.out.println(Thread.currentThread().getName());//我是主线程 休眠线程-sleep Thread.sleep(毫秒) / Thread.sleep(毫秒，纳秒) 控制当前线程休眠若干毫秒 1秒 = 1000毫秒 1秒 = 1000 1000 1000 纳秒 （100,000,000） 12345678910new Thread(()-&gt;&#123; for(int i = 0; i &lt; 10 ;i++)&#123; System.out.println(Thread.currentThread().getName()); try&#123; Thread.sleep(1000); //每个线程休眠1秒（1000毫秒) &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;,"测试线程1").start(); sleep方法不会释放锁，wait方法会释放锁 加入线程-join join() 当前线程暂停，等待指定的线程执行结束后，当前线程才能再继续。即把指定的线程插队处理。 join(int ms) 可以等待指定的毫秒后再继续。 join()方法会使调用该方法的线程处于运行状态，让一开始所在的线程处于无限阻塞状态，直到调用了join方法的线程执行完毕，线程销毁为止。 下面这个例子中，t2线程处于了阻塞状态，直到t1线程的run()方法执行完，线程死亡状态，t2线程才可以运行。 123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; //Java8中 匿名内部类调用外接方法和变量时，外接变量可以不用final修饰，但是其值还是不能改变 Thread t1 = new Thread() &#123; //此时的t1在Java8之前必须用final修饰，是不可变的 @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "aaa"); &#125; &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 2) &#123; try &#123; //Java8中 匿名内部类调用外接方法和变量时，外接变量可以不用final修饰，但是其值还是不能改变 t1.join();//t1线程对象来插队了，t1执行完之后t2才能继续执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + "bbb"); &#125; &#125; &#125;; t1.start(); t2.start();&#125; 执行结果： 1234567891011121314151617181920Thread-1bbbThread-1bbbThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbb 结果显示：当t2线程执行两个后，t1使用join方法来插队，t1执行完之后，t2才继续执行完。 让出线程-yield Thread.yield() 使该线程让出cpu，给其他线程使用cpu执行 yield只会把时间片让给同优先级的线程 使CPU调度到其他线程，让该线程从运行状态回到可运行状态 设置线程优先级 thread.setPriority(int priority) 设置线程的优先级 Thread类源码中有三种优先级：(1,5,10) 1234567891011121314/** * The minimum priority that a thread can have. */public final static int MIN_PRIORITY = 1;/** * The default priority that is assigned to a thread. */public final static int NORM_PRIORITY = 5;/** * The maximum priority that a thread can have. */public final static int MAX_PRIORITY = 10; 优先级值：默认为5，最大为10，最小为1； 不能超过1~10这个范围。 12t1.setPriority(Thread.MIN_PRIORITY);//最小t1.setPriority(Thread.MAX_PRIORITY);//最大 中断线程-Interrupt 中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。 其他线程可以调用该线程的interrupt()方法对其进行中断操作，同时该线程可以调用isInterrupted()来感知其他线程对其是否进行了中断操作，从而做出相应。 也可以调用Thread中的静态方法interrupted()对当前线程进行中断操作，该方法会清除中断标志位。 当抛出InterruptedException时，会清除中断标志位，也就是说在调用isInterrupted会返回false。 如果线程调用了 wait()、sleep()、join()方法而导致的阻塞，可以中断线程，并抛出InterruptedException来唤醒 方法名 作用 备注 public void interrupt() 中断该线程对象 如果线程调用了 wait()、sleep()、join()方法而导致的阻塞，可以中断线程，并抛出InterruptedException来唤醒，并且中断标志位会被清除 public boolean isInterrupted() 测试该线程对象是否被中断 中断标志位不会被清除 public static boolean interrupted() 测试当前线程是否被中断 中断标志位会被清除 守护线程-Deamon setDaemon(boolean on) 设置一个线程作为守护线程。 守护线程为其他线程的运行提供便利的服务，最典型的应用便是GC线程 。 该线程不会单独执行，当其他非守护线程都执行结束后，守护线程就没有可服务的对象了，就会自动退出。 123456789101112131415161718public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt;&#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(Thread.currentThread().getName()+"非守护线程"); &#125; &#125;); Thread t2 = new Thread(()-&gt;&#123; for (int i = 0; i &lt; 30; i++) &#123; System.out.println(Thread.currentThread().getName()+"守护线程"); &#125; &#125;); t2.setDaemon(true);//将t2设置成守护线程 t1.start(); t2.start();&#125; 第一次执行结果： 123Thread-0非守护线程Thread-0非守护线程Thread-0非守护线程 说明：非守护线程直接执行完毕后，守护线程还未开启执行，就自动退出了。 第二次执行结果： 12345678910Thread-0非守护线程Thread-1守护线程Thread-1守护线程Thread-0非守护线程Thread-0非守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程 根据结果发现，守护线程和非守护线程穿插执行，非守护线程执行完之后，守护线程继续执行了，没有立即停止，该现象为线程缓冲，即守护线程正在执行，需要等到非守护线程的执行完毕信号后，才能停止下来，自动退出。 wait()和notify()/notifyAll()Object类中的wait()、notify()、notifyAll()三个方法，每个对象都是有的，结合多线程后可以起到很大的效果。 wait() wait()方法作用是使当前执行的代码的线程进行等待，当前线程会进入等待队列中。 wait()代码处会停止执行，直到接到通知（notify()）或者被中断（Interrupt()）。 在调用wait()之前，线程必须获取该对象的锁，因此wait()方法只能在同步代码中调用执行。 wait()方法可以使调用该线程的方法释放共享资源的锁，然后从运行状态退出，进入等待队列，直到再次被唤醒。 notify() 唤醒等待的线程，如果有多个线程在等待队列中，那么会随机挑选一个等待的线程，对其发出唤醒通知，并且使它等待获取该对象的对象锁。 等待获取对象锁说明了即使收到了通知，wait 的线程也不会马上获取对象锁，会在锁池中进行等待notify方法的线程释放锁才可以，获取了对象锁之后才能从锁池中出去进入可运行状态。 在调用notify()之前，和wait()一样，必须在同步代码中调用。因为有锁的操作。 notify()不释放锁 notifyAll() notifyAll()方法可以使所有正在等待队列中等待同一共享资源的全部线程从等待状态退出，随机进入锁池，等待拿到对象锁，进入可运行状态。 如果wait()方法和notify()/notifyAll()方法不在同步方法/同步代码块中被调用，那么虚拟机会抛出java.lang.IllegalMonitorStateException ☆ sleep()和wait()的区别 方法本质上： wait()方法时Object类中的实例方法。可以传入参数，也可以不传入参数。 而sleep()方法时Thread类中的静态方法。必须传入参数ms值。 使用环境上： wait()方法必须要在同步方法或同步代码块中使用，因为它必须已经获得对象锁。 而sleep()方法没有这个限制，它可以在任何地方使用。 是否释放锁： wait()方法会释放占有的对象锁，使该线程进入等待池中。 而sleep()方法不会释放对象锁，只会让出CPU。 使其继续执行方式上： wait()方法必须等待 notify()/notifyAll()方法的唤醒通知后，才会离开等待池并且如果再次获得CPU时间片才会继续执行。 而sleep()方法在休眠时间到达后，如果再次获得CPU时间片就会继续执行。 Java中用到的线程调度算法 Java中用到的是抢占式的线程调度算法。一个线程用完CPU后，操作系统会根据线程优先级、线程饥饿程度等数据算出一个总的优先级并分配下一个时间片给某个线程。 Thread.sleep(0)的作用？ 平衡CPU控制权的一种操作： 由于Java采用的是抢占式线程调度算法，因此可能就会出现某条线程综合来看常常会获取到CPU的控制权的情况，为了让某些优先级较低的线程也能获得到CPU控制权，可以使用Thread.sleep(0)手动出发一次操作系统分配时间片的操作，来平衡控制权。 线程六大状态根据Thread类中定义的枚举类型State值，可以看出有6中状态： 1234567public enum State &#123; NEW, RUNNABLE, WAITING, TIMED_WAITING, TERMINATED;&#125; 新建状态 NEW 新建了Thread类对象，但是没有启动的线程。new Thread() 可运行状态 RUNNABLE 线程对象新建后，调用start()方法即处于了RUNNABLE状态。 此状态线程可能在Java虚拟机中运行； 可能在等待CPU处理器分配资源。 一个线程只有获取到CPU的资源后，才可以运行其run()方法执行代码，否则就会处于排队等待 阻塞状态 BLOCKED 该线程正在等待同步锁来进入一个同步代码块中来使用CPU资源，此时该线程就处于阻塞状态。 等待状态 WAITING 线程调用以下方法时，会自己进入等待状态： 不带超时的Object类中的wait()方法 不带超时的Thread类中的join()方法 LockSupport类中的park()方法 一直等待，直到手动唤醒 超时等待状态 TIMED_WAITING 线程调用带有正的等待时间参数的下列各方法时，会处于超时等待状态： Object中的wait() Thread中的join() Thread中的sleep() LockSupport中的parkNanos() LockSupport中的parkUntil() 终止状态 TERMINATED 线程执行完毕，或run()方法全部执行结束后，线程进入终止状态。 终止状态的线程不具备继续运行的能力。 线程状态图 锁池队列：当资源被一个线程访问时，上锁后，其他线程就会进入锁池队列，当锁释放后，其他线程获得了锁，就会变成可运行状态。 《Thinking in Java》中线程被阻塞的五种可能原因： 线程调用 sleep(ms) ，使线程睡眠，规定时间内，该线程不会运行。 使用suspend()暂停了线程的执行，除非收到resume()消息，否则不会进入可运行状态 线程正在等待一些IO操作完成 线程试图调用另一个对象的同步方法，但那个对象处于锁状态，暂时无法使用 调用wait()暂停了线程的执行，进入了等待队列。 怎么唤醒一个阻塞的线程 如果线程调用了 wait()、sleep()、join()方法而导致的阻塞，可以中断线程，并抛出InterruptedException来唤醒 如果该线程遇到了IO阻塞，只能等系统IO操作结束后，才能唤醒，Java代码无能为力，无法直接接触到底层操作系统的调度。 怎么检测一个线程是否持有对象监视器 Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true 1public static boolean holdsLock(Object obj) 同步代码需要同步的情况 当多线程并发，有多段代码同时执行时，希望某一段代码执行的过程中，CPU不要切换到其他线程上，此时就需要同步。 如果有两段代码是同步进行的，那么同一时间只能执行其中一段，在一段代码没执行结束之前，不会执行另外一段代码。 同步代码块操作 使用synchronized关键字加上一个锁对象来定义一段代码，这就称为同步代码块。 如果多个同步代码块使用同一个锁对象，那么他们就是同步的 同步代码块是锁机制，同一个锁对象，同步代码块是同步的。 锁对象是任意对象，但不能是匿名对象，因为匿名对象不是同一个对象。 当多个代码块使用了同一个锁对象的 synchronized 锁机制，只有当一个线程把 synchronized 代码块的代码全部执行完之后，才能去执行该同一锁对象的另一段代码。 即该多个代码块是同步的，同一时间只能执行其中一段，执行完之后，才能执行另一段。 若锁对象不一致，即不是同步的，会出现抢占线程执行的情况。 具体操作： 1234567891011121314151617181920212223242526272829303132333435363738394041public class SynchronizeTest &#123; public static void main(String[] args) &#123; Consumer con = new Consumer(); new Thread(()-&gt;&#123; while(true) con.print1(); &#125;).start(); new Thread(()-&gt;&#123; while(true) con.print2(); &#125;).start(); &#125;&#125;class Consumer &#123; //定义一个Object对象，作为锁对象 Object obj = new Object(); public void print1()&#123; //锁机制使用同一个锁对象 synchronized (obj)&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125; &#125; public void print2()&#123; //锁机制使用同一个锁对象，作为同步代码块 synchronized(obj)&#123; System.out.print("多"); System.out.print("线"); System.out.print("程"); System.out.println(); &#125; &#125;&#125; 同步方法 使用synchronized关键字修饰一个方法时，该方法中所有代码都是同步的。 123456789101112//同步方法只需在方法上加 synchronized public synchronized void print1()&#123; //锁机制使用同一个锁对象 synchronized (obj)&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125;&#125; 非静态同步函数的锁是this 1234567891011121314151617181920//同步方法只需在方法上加 synchronized public synchronized void print1()&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125;public void print2()&#123; //非静态的同步方法的锁对象是this synchronized(this)&#123; System.out.print("多"); System.out.print("线"); System.out.print("程"); System.out.println(); &#125;&#125; 此时 这两个方法时 同步的 静态同步函数的锁是字节码对象 静态域随着类的加载而加载，此时会产生该类的字节码对象，所以静态同步方法锁对象不能是this，而是产生的字节码对象 12345678910111213141516171819public static synchronized void print1()&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125;public static void print2()&#123; //静态的同步方法的锁对象是随着类加载而产生的类的字节码对象 synchronized(Customer.class)&#123; System.out.print("多"); System.out.print("线"); System.out.print("程"); System.out.println(); &#125;&#125; 同步方法和同步块，哪个是更好的选择 基本原则：同步的范围越小越好。 同步块之外的代码是异步执行的，比同步整个方法更有效率。 线程安全 如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的 线程安全级别 1、不可变 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 2、绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的。不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet 3、相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。 4、 线程非安全 ArrayList、LinkedList、HashMap等都是线程非安全的类 常见的线程安全类 线程安全类 线程不安全类 Vector ArrayList StringBuffer StringBuilder Hashtable HashMap … LinkedList … … StringBuffer 线程安全（其append方法中加了synchronized修饰 vector add、remove方法都是原子操作,加了synchronized修饰 但是Collections集合工具类中提供了静态方法synchronizedXXX(XXX)，分别对应着线程不安全的那些集合类，可以让他们转换成线程安全的集合，所以Vector类淘汰了… 方法摘要 方法说明 static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) 返回指定 collection 支持的同步（线程安全的）collection。 static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) 返回指定列表支持的同步（线程安全的）列表。 static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) 返回由指定映射支持的同步（线程安全的）映射。 static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) 返回指定 set 支持的同步（线程安全的）set。 static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m) 返回指定有序映射支持的同步（线程安全的）有序映射。 static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s) 返回指定有序 set 支持的同步（线程安全的）有序 set。 多线程中的线程安全问题 多线程并发操作同一共享数据时，就会可能出现线程安全问题。 使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 就不会多个线程同时执行 多窗口卖票问题 如果不开启锁同步 ，就会出现卖出票号为负数的现象 在循环中使用锁同步，让各个线程进入循环之后进行同步，一个线程把ticketNum–后，其他线程再执行 使用Runnable方式实现： 123456789101112131415161718192021222324252627282930313233public class SynchronizeTicketTest &#123; public static void main(String[] args) &#123; new Thread(new TicketSeller()).start(); new Thread(new TicketSeller()).start(); new Thread(new TicketSeller()).start(); new Thread(new TicketSeller()).start(); &#125;&#125;class TicketSeller implements Runnable&#123; private static int tikcetNum = 10000;//总共10000张票，放到静态池中共享 @Override public void run() &#123; while(true)&#123; //在循环中使用锁同步，让各个线程进入循环之后进行同步，一个线程把ticketNum--后，其他线程再执行 synchronized(TicketSeller.class)&#123; if(tikcetNum &lt;= 0) break; try &#123; //让线程睡10ms 如果不开启锁同步 就会出现票号为负数的现象 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "...这是第" + tikcetNum-- + "号票"); &#125; &#125; &#125;&#125; 死锁问题 线程A和线程B相互等待对方持有的锁导致程序无限死循环下去 线程A持有锁H并且想获取锁W，此时线程B持有锁W并且想获取锁H，那么这两个线程AB就会永远等待下去，产生最简单的死锁。 一个类可能发生死锁，并不意味着每次都会发生，往往在高并发、高负载的情况下，死锁出现概率高很多。 多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁 写一个死锁程序 哲学家进餐问题，使用同步代码块嵌套，互相先持有对方需要的锁对象 写一个死锁程序步骤： 定义两个对象分别代表两个线程一开始就持有的锁对象 在run方法中使用 synchronized 同步代码块嵌套 外层synchronized锁对象是对方所需求的，自己所持有的，内层synchronized锁对象是对方所持有，自己所需要的 。 当一个线程中的锁对象是自己持有的，还未走出外层代码块，需要对方所持有的锁对象时，cpu调度到了另一个线程，另一个线程正好也是这种情况，此时双方都持有了对方所需要的锁对象，发生了死锁。 1234567891011121314151617181920212223242526272829303132333435public class DeadLockTest &#123; private static String left = "left one"; private static String right = "right one"; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; while(true)&#123; synchronized (right)&#123; System.out.println(Thread.currentThread().getName()+"--持有了right,想得到left"); synchronized(left)&#123; System.out.println(Thread.currentThread().getName()+"--得到了left,可以开吃了"); &#125; &#125; &#125; &#125;).start(); new Thread(() -&gt; &#123; while(true)&#123; synchronized (left)&#123; System.out.println(Thread.currentThread().getName()+"--持有了left,想得到right"); synchronized(right)&#123; System.out.println(Thread.currentThread().getName()+"--得到了right,可以开吃了"); &#125; &#125; &#125; &#125;).start(); /* Thread-1--持有了left,想得到right Thread-0--持有了right,想得到left 执行到此时，就会发现这两个线程的锁对象谁都不想放，就会产生死锁。 */ &#125;&#125; 结果： 123上方结果省略....Thread-1--持有了left,想得到rightThread-0--持有了right,想得到left 执行到此时，就会发现这两个线程的锁对象谁都不想放，就会产生死锁。 避免死锁的方式 注意和减少同步代码块嵌套问题 设计时考虑清楚锁的顺序，尽量减少嵌套加锁交互数量 由于死锁是因为两个或多个线程之间无限时间等待对方持有的锁对象而形成的，那么给同步代码块加个等待时间限制。 synchronized 关键字 不具备这个功能，使用Lock类中的tryLock方法，指定一个超时时限，在等待时，若超过该时限，就返回一个失败信息结束阻塞。 单例模式的线程安全问题单例模式 单例设计模式：保证一个类在内存中只有一个对象，内存唯一。 保证类在内存中只有一个对象： 1、控制类的创建，不让其他类来创建本类的对象，将本类的构造函数私有private 2、在本类中定义一个本类的对象，并且外界无法修改。 3、在本类中提供一个唯一的公共访问方法，可获取本类的对象。 饿汉式 在类中直接创建一个不可修改的对象引用，不管有没有调用，都创建，空间换时间。 饿汉式在多线程环境下是线程安全的。 123456789101112class Singleton &#123; //1.将本类的构造函数私有private private Singleton ()&#123;&#125; //2. 在本类中定义一个本类的对象，并且外界无法修改。 private static Singleton s = new Singleton(); //3. 在本类中提供一个唯一的公共访问方法，可获取本类的对象 //饿汉式 public static Singleton getInstance()&#123; return s ; &#125;&#125; 另一种饿汉式，利用final直接修饰 1234567class Singleton &#123; //1.将本类的构造函数私有private private Singleton ()&#123;&#125; //2. 在本类中定义一个本类的对象，并且外界无法修改。 public final static Singleton s = new Singleton() ;&#125; 懒汉式 在类中获取对象时加以判断，为空时才创建，即用到该类对象时才创建，时间换空间。 懒汉式单例模式在多线程下是非线程安全的。 当线程A判断为null时，正准备new，此时，被另一个线程B抢占了CPU资源，线程B也判断为null，new了之后，第一个线程A又抢回了CPU资源，此时线程A又new了。此时这两个线程就new了两次，就不是唯一的内存引用了。 1234567891011121314class Singleton &#123; //1.将本类的构造函数私有private private Singleton ()&#123;&#125; //2. 在本类中定义一个本类的对象，并且外界无法修改。 private static Singleton s ; //3. 在本类中提供一个唯一的公共访问方法，可获取本类的对象 //懒汉式 对象引用为空 才创建， public static Singleton getInstance()&#123; //用到时创建，用不到时不创建 if(s == null) s = new Singleton() ; return s; &#125;&#125; 饿汉式和懒汉式的区别 线程安全上： 饿汉式线程安全，多线程下也不会创建多个对象 懒汉式非线程安全，多线程下可能会创建多个对象 执行效果： 饿汉式是 空间换时间，执行速度快。 懒汉式是 时间换空间，延迟加载。 互斥锁 JDK1.5版本提供了java.util.concurrent.locks包，该包中提供了锁和等待条件的接口和类，可以用于代替JDK1.5之前的synchronized同步和监视器机制。 互斥锁指的是一次最多只能有一个线程持有的锁。 互斥锁在Java中的体现是Lock接口和其实现类ReentrantLock。 Lock接口的出现主要替代了synchronized关键字的用处，其提供了一个比sychronized机制更广泛的锁定操作 Lock和sychronized机制的主要区别 synchronized机制提供了对于每个对象相关的隐式监视器锁的访问，并强制所有锁获取和释放都要出现在一个块结构中。 当获取了多个锁时（多个synchronized代码块嵌套时），它们必须以相反的顺序释放。 synchronized机制对锁的释放是隐式的，只要线程运行的代码超出了synchronized语句块范围，持有的锁对象就会自动释放。 锁定和取消锁定出现在不同作用范围中时，必须谨慎地确保保持锁定时所执行的所有代码用 try-finally 或 try-catch 加以保护，以确保在必要时释放锁 Lock机制必须是显式调用Lock对象的unlock()方法才能释放锁。 Lock机制可以不在同一个块结构中获取和释放锁，更加自由的释放锁。 Lock接口 Lock 实现提供了使用 synchronized 方法和语句所没有的其他功能，包括提供了一个非块结构的获取锁尝试 tryLock()、一个获取可中断锁的尝试 lockInterruptibly() 和一个获取超时失效锁的尝试 tryLock(long, TimeUnit)。 Lock 类还可以提供与隐式监视器锁完全不同的行为和语义，如保证排序、非重入用法或死锁检测。如果某个实现提供了这样特殊的语义，则该实现必须对这些语义加以记录。 注意，Lock 实例只是普通的对象，其本身可以在 synchronized 语句中作为目标使用。获取 Lock 实例的监视器锁与调用该实例的任何 lock()方法没有特别的关系。为了避免混淆，建议除了在其自身的实现中之外，决不要以这种方式使用 Lock 实例。 lockvoid lock() 获取锁 如果锁处于空闲状态，当前线程将直接获取该lock对象锁。 相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁. unlockvoid unlock() 释放锁 当前线程将释放持有的锁。 锁只能由持有者释放。 如果线程并不持有锁，却执行了该方法，可能会导致异常的发生。 tryLockboolean tryLock() 仅在调用时锁为空闲状态才获取该锁。 如果锁可用，则获取锁，并返回true 如果锁不可用，立即返回false 此方法可确保如果获取了锁，则会释放锁，如果未获取锁，则不会试图将其释放。即通常配合unlock()使用来释放锁。 1234567891011Lock lock = new ReentrantLock();if(lock.tryLock())&#123; try&#123; //获取到锁的一些操作 &#125;finally&#123; //确保了获取锁，才能释放 lock.unlock(); &#125;&#125;else&#123; //未获取到锁的一些操作&#125; tryLock()和lock()方法的区别： tryLock()方法只是试图获取锁，如果锁不可用，当前线程仍然可以继续往下执行. lock()方法是一定要获取到锁，如果锁不可用，就会一直等待下去，锁定当前线程，在未获取指定锁对象之前，当前线程不会继续向下执行。 Condition接口 - 条件 Condition将Object监视器方法wait、notify、notifyAll方法分解成不同的对象，为了方便通过将这些对象与任意Lock对象实现组合使用，为每个对象提供了多个等待set（wait-set）。其中，Lock替代了synchronized方法和语句的使用，Condition替代了Object监视器方法的使用。 使用Condition对象的相关方法，可以方便的挂起和唤醒线程，而且可以特定的唤醒其其中某个线程。这也是和Object对象的wait()、notify()、notifyAll()方法的区别。 Object对象的wait()、notify()、notifyAll()方法存在一个问题：如果多个线程调用了obj的wait()方法而挂起，那么我们无法做到调用obj的notify()和notifyAll()方法唤醒其中特定的一个线程，而Conditon对象就可以做到。 Condition对象只能通过Lock类的newCondition()方法获取，因此一个Condition对象必然会有一个与其绑定的Lock锁。 awaitvoid await() 造成当前线程再接到信号或被中断之前一直处于等待状态 将当前线程处于等待状态，并释放该Condition对象所绑定的锁. 使用await()方法前，当前线程必须持有与该Condition对象绑定的锁，否则程序可能会抛出异常。 signalvoid signal() 唤醒一个在该Condition对象上挂起的线程 如果存在多个线程同时等待该Condition对象的唤醒，则随机选择其中一个唤醒。 线程被唤醒之前，必须重新获取到锁，即与该Condition对象绑定的Lock对象。 signalAllvoid signalAll() 唤醒所有在该Condition对象上挂起的线程 所有被唤醒的线程将竞争与该Condition对象绑定的锁，只有获取到锁的线程才能恢复到运行状态。 一个实例1234567891011121314151617181920问题的描述:启动3个线程打印递增的数字, 线程1先打印1,2,3,4,5, 然后是线程2打印6,7,8,9,10,然后是线程3打印11,12,13,14,15. 接着再由线程1打印16,17,18,19,20....以此类推,直到打印到75. 程序的输出结果应该为: 线程1: 1 线程1: 2 线程1: 3 线程1: 4 线程1: 5 线程2: 6 线程2: 7 线程2: 8 线程2: 9 线程2: 10 ... 线程3: 71 线程3: 72 线程3: 73 线程3: 74 线程3: 75 利用ReentrantLock和Condition接口组合，可以轻松指定和分配各个线程该完成的操作。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class ReentrantLockTest &#123; public static void main(String[] args) &#123; NumPrinter n = new NumPrinter(); //此处确定每个线程应该执行几次，总共75个数分3个线程，每个线程分25个数字， // 5*5=25，每个线程执行5次，每次打印5个数字 new Thread(()-&gt;&#123; //每个线程执行5次 for (int i = 0; i &lt; 5 ; i++) &#123; try &#123; n.print1(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt;5 ; i++) &#123; try &#123; n.print2(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 5 ; i++) &#123; try &#123; n.print3(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;&#125;class NumPrinter&#123; private int num = 1; private int flag = 1; //使用ReentrantLock类和Condition接口来配合使用，指定唤醒哪个线程 private ReentrantLock lock = new ReentrantLock(); private Condition c1 = lock.newCondition(); private Condition c2 = lock.newCondition(); private Condition c3 = lock.newCondition(); public void print1() throws InterruptedException &#123; //三个线程同时占用临界区的资源，应该使用同步 lock.lock(); //获取锁 和 下面的 unlock 代替了 synchronized if(flag != 1) //当flag不为1时，c1进行等待，因为此时其他的线程正在执行他们的操作 c1.await(); if(num &lt;= 75) for (int i = 0; i &lt; 5; i++) &#123; System.out.println("1---"+num++); &#125; flag = 2; //标记指定为2，在print2中限制除了flag不为2时，c2进行等待 c2.signal(); //唤醒指定的c2 lock.unlock(); //释放锁 &#125; public void print2() throws InterruptedException &#123; lock.lock(); if(flag != 2) c2.await(); if(num &lt;= 75) for (int i = 0; i &lt; 5; i++) &#123; System.out.println("2---"+num++); &#125; flag = 3; c3.signal(); lock.unlock(); &#125; public void print3() throws InterruptedException &#123; lock.lock(); if(flag != 3) c3.await(); if(num &lt;= 75) for (int i = 0; i &lt; 5; i++) &#123; System.out.println("3---"+num++); &#125; flag = 1; c1.signal(); lock.unlock(); &#125;&#125; 线程组线程组概述 Java中用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。 默认情况下，所有的线程都属于主线程组。 public final ThreadGroup getThreadGroup() 通过线程对象获取所属的线程组 public final String getName() 通过线程组对象获取线程组的名字 123456789101112131415MyRunnable mr = new MyRunnable();Thread t1 = new Thread(mr, "张三");Thread t2 = new Thread(mr, "李四");//获取线程组// 线程类里面的方法：public final ThreadGroup getThreadGroup()ThreadGroup tg1 = t1.getThreadGroup();ThreadGroup tg2 = t2.getThreadGroup();// 线程组里面的方法：public final String getName()String name1 = tg1.getName();String name2 = tg2.getName();System.out.println(name1);System.out.println(name2);// 通过结果我们知道了：线程默认情况下属于main线程组// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组System.out.println(Thread.currentThread().getThreadGroup().getName()); 给线程设置线程组 ThreadGroup(String name) 线程组对象的构造器并赋值名字 Thread(ThreadGroup group, Runnable target,String name) 线程对象的构造器，直接设置线程组 12345678910111213// ThreadGroup(String name)ThreadGroup tg = new ThreadGroup("这是一个新的组"); MyRunnable mr = new MyRunnable();// Thread(ThreadGroup group, Runnable target, String name)Thread t1 = new Thread(tg, mr, "张三");Thread t2 = new Thread(tg, mr, "李四");System.out.println(t1.getThreadGroup().getName());System.out.println(t2.getThreadGroup().getName());//通过组名称设置后台线程，表示该组的线程都是后台线程tg.setDaemon(true); 线程池为什么会有线程池？（线程池概述） 程序创建一个新的线程成本较高，因为它涉及到要与操作系统进行交互。频繁的线程创建和销毁，大大消耗时间和降低系统的效率。 线程池的使用解决了这个问题，它使得多个线程能够一次创建完，放在线程池中，执行完后并不会被销毁，而是再次回到线程池中变成空闲状态，等待下一个对象来使用。并且即拿即用，不用每次都创建，大大提高了线程的复用性，提高系统效率。 JDK1.5开始，Java有了内置的线程池。Executors工厂类 内置线程池 JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法： public static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。 参数： nThreads - 池中的线程数 返回： 新创建的线程池 public static ExecutorService newSingleThreadExecutor() 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程 Executors.newCachedThreadPool() 创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。 下面是这三个静态方法的具体实现: 12345678910111213141516public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 根据源码的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。 ThreadPoolExecutor构造器如下： 12345public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 参数含义： corePoolSize - 池中所保存的线程数，包括空闲线程 maximumPoolSize - 池中允许的最大线程数。 keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。 unit - keepAliveTime 参数的时间单位。 workQueue - 执行前用于保持任务的队列。此队列仅由保持 execute 方法提交的 Runnable 任务。 handler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。 方法源码分析： newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue； newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue； newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。 实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。 另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。 ExecutorService提供了如下方法： Future&lt;?&gt; submit(Runnable task) 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功 完成时将会返回 null。 参数： task - 要提交的任务 返回： 表示任务等待完成的 Future &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。 void shutdown() 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。如果已经关闭，则调用没有其他作用。 代码示例： 1234567ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象//或者Callable对象代表的线程pool.submit(new MyRunnable());pool.submit(new MyRunnable());//结束线程池pool.shutdown(); Future 接口Future 表示异步计算的结果。 它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。 计算完成后只能使用 get 方法来获取结果，如有必要，计算完成前可以阻塞此方法。 取消则由 cancel 方法来执行。 还提供了其他方法，以确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。 如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。 FutureTask 是其实现类 方法摘要 boolean cancel(boolean mayInterruptIfRunning) 试图取消对此任务的执行。 V get() 如有必要，等待计算完成，然后获取其结果。 V get(long timeout, TimeUnit unit) 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。 boolean isCancelled() 如果在任务正常完成前将其取消，则返回 true。 boolean isDone() 如果任务已完成，则返回 true。 实现多线程的第三种方式 步骤： 创建实体类，实现Callable接口 实现接口中的call()方法 利用 ExecutorService线程池对象 的 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task()方法提交该Callable接口的线程任务。 123456789101112131415161718192021222324252627282930// 创建线程池ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程Future&lt;Integer&gt; f1 = pool.submit(new MyCallable(100));Future&lt;Integer&gt; f2 = pool.submit(new MyCallable(200));// V get()Integer i1 = f1.get();Integer i2 = f2.get();System.out.println(i1);System.out.println(i2);// 结束pool.shutdown();public class MyCallable implements Callable&lt;Integer&gt; &#123; private int number; public MyCallable(int number) &#123; this.number = number; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int x = 1; x &lt;= number; x++) &#123; sum += x; &#125; return sum; &#125;&#125; 利用匿名内部类方式： 123456789101112131415ExecutorService service = Executors.newSingleThreadExecutor(); Future&lt;String&gt; future = service.submit(new Callable() &#123; @Override public String call() throws Exception &#123; return "通过实现Callable接口"; &#125; &#125;); try &#123; String result = future.get(); System.out.println(result); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; Lambda表达式方式： 12345678910111213public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //使用Executors工厂类创建一个单线程池 ExecutorService es = Executors.newSingleThreadExecutor(); //使用这个单线程提交一个Callable接口线程服务，返回值为String //Callable接口是一个函数式接口，Java8开始可以直接使用Lambda表达式表示 //其内部实现了call()方法 V call() throws Exception; //并得到该结果值打印 System.out.println( es.submit(()-&gt;"使用lambda表达式的Callable接口").get()); es.shutdown(); //关闭该线程池 &#125;&#125; 实现callable接口，提交给ExecutorService返回值是异步执行的。 该方式的优缺点： 优点： 有返回值 可以抛出异常 缺点： 代码较复杂，需要利用线程池]]></content>
      <categories>
        <category>JavaSE回顾</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
        <tag>线程安全</tag>
        <tag>死锁问题</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础-线程组和线程池]]></title>
    <url>%2F2018%2F06%2F20%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-%E7%BA%BF%E7%A8%8B%E7%BB%84%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8CCallable%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[线程组线程组概述 Java中用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。 默认情况下，所有的线程都属于主线程组。 public final ThreadGroup getThreadGroup() 通过线程对象获取所属的线程组 public final String getName() 通过线程组对象获取线程组的名字 123456789101112131415MyRunnable mr = new MyRunnable();Thread t1 = new Thread(mr, "张三");Thread t2 = new Thread(mr, "李四");//获取线程组// 线程类里面的方法：public final ThreadGroup getThreadGroup()ThreadGroup tg1 = t1.getThreadGroup();ThreadGroup tg2 = t2.getThreadGroup();// 线程组里面的方法：public final String getName()String name1 = tg1.getName();String name2 = tg2.getName();System.out.println(name1);System.out.println(name2);// 通过结果我们知道了：线程默认情况下属于main线程组// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组System.out.println(Thread.currentThread().getThreadGroup().getName()); 给线程设置线程组 ThreadGroup(String name) 线程组对象的构造器并赋值名字 Thread(ThreadGroup group, Runnable target,String name) 线程对象的构造器，直接设置线程组 12345678910111213// ThreadGroup(String name)ThreadGroup tg = new ThreadGroup("这是一个新的组"); MyRunnable mr = new MyRunnable();// Thread(ThreadGroup group, Runnable target, String name)Thread t1 = new Thread(tg, mr, "张三");Thread t2 = new Thread(tg, mr, "李四");System.out.println(t1.getThreadGroup().getName());System.out.println(t2.getThreadGroup().getName());//通过组名称设置后台线程，表示该组的线程都是后台线程tg.setDaemon(true); 线程池为什么会有线程池？（线程池概述） 程序创建一个新的线程成本较高，因为它涉及到要与操作系统进行交互。频繁的线程创建和销毁，大大消耗时间和降低系统的效率。 线程池的使用解决了这个问题，它使得多个线程能够一次创建完，放在线程池中，执行完后并不会被销毁，而是再次回到线程池中变成空闲状态，等待下一个对象来使用。并且即拿即用，不用每次都创建，大大提高了线程的复用性，提高系统效率。 JDK1.5开始，Java有了内置的线程池。Executors工厂类 内置线程池 JDK5新增了一个Executors工厂类来产生线程池，有如下几个方法： public static ExecutorService newFixedThreadPool(int nThreads) 创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。 参数： nThreads - 池中的线程数 返回： 新创建的线程池 public static ExecutorService newSingleThreadExecutor() 创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程 Executors.newCachedThreadPool() 创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE 这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。 下面是这三个静态方法的具体实现: 12345678910111213141516public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 根据源码的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。 ThreadPoolExecutor构造器如下： 12345public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) 参数含义： corePoolSize - 池中所保存的线程数，包括空闲线程 maximumPoolSize - 池中允许的最大线程数。 keepAliveTime - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。 unit - keepAliveTime 参数的时间单位。 workQueue - 执行前用于保持任务的队列。此队列仅由保持 execute 方法提交的 Runnable 任务。 handler - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。 方法源码分析： newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue； newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue； newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。 实际中，如果Executors提供的三个静态方法能满足要求，就尽量使用它提供的三个方法，因为自己去手动配置ThreadPoolExecutor的参数有点麻烦，要根据实际任务的类型和数量来进行配置。 另外，如果ThreadPoolExecutor达不到要求，可以自己继承ThreadPoolExecutor类进行重写。 ExecutorService提供了如下方法： Future&lt;?&gt; submit(Runnable task) 提交一个 Runnable 任务用于执行，并返回一个表示该任务的 Future。该 Future 的 get 方法在成功 完成时将会返回 null。 参数： task - 要提交的任务 返回： 表示任务等待完成的 Future &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) 提交一个返回值的任务用于执行，返回一个表示任务的未决结果的 Future。该 Future 的 get 方法在成功完成时将会返回该任务的结果。 void shutdown() 启动一次顺序关闭，执行以前提交的任务，但不接受新任务。如果已经关闭，则调用没有其他作用。 代码示例： 1234567ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象//或者Callable对象代表的线程pool.submit(new MyRunnable());pool.submit(new MyRunnable());//结束线程池pool.shutdown(); 使用线程池的风险​ 虽然线程池是构建多线程应用程序的强大机制，但使用它并不是没有风险的。使用线程池构建的应用程序容易遭受任何其他多线程应用程序容易遭受的所有并发风险，例如同步错误、死锁、资源不足和线程泄露。 Future 接口Future 表示异步计算的结果。 它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。 计算完成后只能使用 get 方法来获取结果，如有必要，计算完成前可以阻塞此方法。 取消则由 cancel 方法来执行。 还提供了其他方法，以确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。 如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。 FutureTask 是其实现类 方法摘要 boolean cancel(boolean mayInterruptIfRunning) 试图取消对此任务的执行。 V get() 如有必要，等待计算完成，然后获取其结果。 V get(long timeout, TimeUnit unit) 如有必要，最多等待为使计算完成所给定的时间之后，获取其结果（如果结果可用）。 boolean isCancelled() 如果在任务正常完成前将其取消，则返回 true。 boolean isDone() 如果任务已完成，则返回 true。 实现多线程的第三种方式 步骤： 创建实体类，实现Callable接口 实现接口中的call()方法 利用 ExecutorService线程池对象 的 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task()方法提交该Callable接口的线程任务。 123456789101112131415161718192021222324252627282930// 创建线程池ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程Future&lt;Integer&gt; f1 = pool.submit(new MyCallable(100));Future&lt;Integer&gt; f2 = pool.submit(new MyCallable(200));// V get()Integer i1 = f1.get();Integer i2 = f2.get();System.out.println(i1);System.out.println(i2);// 结束pool.shutdown();public class MyCallable implements Callable&lt;Integer&gt; &#123; private int number; public MyCallable(int number) &#123; this.number = number; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int x = 1; x &lt;= number; x++) &#123; sum += x; &#125; return sum; &#125;&#125; 利用匿名内部类方式： 123456789101112131415ExecutorService service = Executors.newSingleThreadExecutor(); Future&lt;String&gt; future = service.submit(new Callable() &#123; @Override public String call() throws Exception &#123; return "通过实现Callable接口"; &#125; &#125;); try &#123; String result = future.get(); System.out.println(result); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; Lambda表达式方式： 12345678910111213public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //使用Executors工厂类创建一个单线程池 ExecutorService es = Executors.newSingleThreadExecutor(); //使用这个单线程提交一个Callable接口线程服务，返回值为String //Callable接口是一个函数式接口，Java8开始可以直接使用Lambda表达式表示 //其内部实现了call()方法 V call() throws Exception; //并得到该结果值打印 System.out.println( es.submit(()-&gt;"使用lambda表达式的Callable接口").get()); es.shutdown(); //关闭该线程池 &#125;&#125; 实现callable接口，提交给ExecutorService返回值是异步执行的。 该方式的优缺点： 优点： 有返回值 可以抛出异常 缺点： 代码较复杂，需要利用线程池]]></content>
      <categories>
        <category>Java多线程基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
        <tag>线程池</tag>
        <tag>线程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础-互斥锁Lock和Condition]]></title>
    <url>%2F2018%2F06%2F20%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-%E4%BA%92%E6%96%A5%E9%94%81ReentrantLock%E5%92%8CCondition%2F</url>
    <content type="text"><![CDATA[互斥锁 JDK1.5版本提供了java.util.concurrent.locks包，该包中提供了锁和等待条件的接口和类，可以用于代替JDK1.5之前的synchronized同步和监视器机制。 互斥锁指的是一次最多只能有一个线程持有的锁。 互斥锁在Java中的体现是Lock接口和其实现类ReentrantLock。 Lock接口的出现主要替代了synchronized关键字的用处，其提供了一个比sychronized机制更广泛的锁定操作 Lock和sychronized机制的主要区别 synchronized机制提供了对于每个对象相关的隐式监视器锁的访问，并强制所有锁获取和释放都要出现在一个块结构中。 当获取了多个锁时（多个synchronized代码块嵌套时），它们必须以相反的顺序释放。 synchronized机制对锁的释放是隐式的，只要线程运行的代码超出了synchronized语句块范围，持有的锁对象就会自动释放。 锁定和取消锁定出现在不同作用范围中时，必须谨慎地确保保持锁定时所执行的所有代码用 try-finally 或 try-catch 加以保护，以确保在必要时释放锁 Lock机制必须是显式调用Lock对象的unlock()方法才能释放锁。 Lock机制可以不在同一个块结构中获取和释放锁，更加自由的释放锁。 Lock接口 Lock 实现提供了使用 synchronized 方法和语句所没有的其他功能，包括提供了一个非块结构的获取锁尝试 tryLock()、一个获取可中断锁的尝试 lockInterruptibly() 和一个获取超时失效锁的尝试 tryLock(long, TimeUnit)。 Lock 类还可以提供与隐式监视器锁完全不同的行为和语义，如保证排序、非重入用法或死锁检测。如果某个实现提供了这样特殊的语义，则该实现必须对这些语义加以记录。 注意，Lock 实例只是普通的对象，其本身可以在 synchronized 语句中作为目标使用。获取 Lock 实例的监视器锁与调用该实例的任何 lock()方法没有特别的关系。为了避免混淆，建议除了在其自身的实现中之外，决不要以这种方式使用 Lock 实例。 lockvoid lock() 获取锁 如果锁处于空闲状态，当前线程将直接获取该lock对象锁。 相反，如果锁已经被其他线程持有，将禁用当前线程，直到当前线程获取到锁. unlockvoid unlock() 释放锁 当前线程将释放持有的锁。 锁只能由持有者释放。 如果线程并不持有锁，却执行了该方法，可能会导致异常的发生。 tryLockboolean tryLock() 仅在调用时锁为空闲状态才获取该锁。 如果锁可用，则获取锁，并返回true 如果锁不可用，立即返回false 此方法可确保如果获取了锁，则会释放锁，如果未获取锁，则不会试图将其释放。即通常配合unlock()使用来释放锁。 1234567891011Lock lock = new ReentrantLock();if(lock.tryLock())&#123; try&#123; //获取到锁的一些操作 &#125;finally&#123; //确保了获取锁，才能释放 lock.unlock(); &#125;&#125;else&#123; //未获取到锁的一些操作&#125; tryLock()和lock()方法的区别： tryLock()方法只是试图获取锁，如果锁不可用，当前线程仍然可以继续往下执行. lock()方法是一定要获取到锁，如果锁不可用，就会一直等待下去，锁定当前线程，在未获取指定锁对象之前，当前线程不会继续向下执行。 Condition接口 - 条件 Condition将Object监视器方法wait、notify、notifyAll方法分解成不同的对象，为了方便通过将这些对象与任意Lock对象实现组合使用，为每个对象提供了多个等待set（wait-set）。其中，Lock替代了synchronized方法和语句的使用，Condition替代了Object监视器方法的使用。 使用Condition对象的相关方法，可以方便的挂起和唤醒线程，而且可以特定的唤醒其其中某个线程。这也是和Object对象的wait()、notify()、notifyAll()方法的区别。 Object对象的wait()、notify()、notifyAll()方法存在一个问题：如果多个线程调用了obj的wait()方法而挂起，那么我们无法做到调用obj的notify()和notifyAll()方法唤醒其中特定的一个线程，而Conditon对象就可以做到。 Condition对象只能通过Lock类的newCondition()方法获取，因此一个Condition对象必然会有一个与其绑定的Lock锁。 awaitvoid await() 造成当前线程再接到信号或被中断之前一直处于等待状态 将当前线程处于等待状态，并释放该Condition对象所绑定的锁. 使用await()方法前，当前线程必须持有与该Condition对象绑定的锁，否则程序可能会抛出异常。 signalvoid signal() 唤醒一个在该Condition对象上挂起的线程 如果存在多个线程同时等待该Condition对象的唤醒，则随机选择其中一个唤醒。 线程被唤醒之前，必须重新获取到锁，即与该Condition对象绑定的Lock对象。 signalAllvoid signalAll() 唤醒所有在该Condition对象上挂起的线程 所有被唤醒的线程将竞争与该Condition对象绑定的锁，只有获取到锁的线程才能恢复到运行状态。 一个实例1234567891011121314151617181920212223问题的描述:启动3个线程打印递增的数字, 线程1先打印1,2,3,4,5, 然后是线程2打印6,7,8,9,10,然后是线程3打印11,12,13,14,15.接着再由线程1打印16,17,18,19,20....以此类推,直到打印到75. 程序的输出结果应该为: 线程1: 1 线程1: 2 线程1: 3 线程1: 4 线程1: 5 线程2: 6 线程2: 7 线程2: 8 线程2: 9 线程2: 10 ... 线程3: 71 线程3: 72 线程3: 73 线程3: 74 线程3: 75 利用ReentrantLock和Condition接口组合，可以轻松指定和分配各个线程该完成的操作。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class ReentrantLockTest &#123; public static void main(String[] args) &#123; NumPrinter n = new NumPrinter(); //此处确定每个线程应该执行几次，总共75个数分3个线程，每个线程分25个数字， // 5*5=25，每个线程执行5次，每次打印5个数字 new Thread(()-&gt;&#123; //每个线程执行5次 for (int i = 0; i &lt; 5 ; i++) &#123; try &#123; n.print1(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt;5 ; i++) &#123; try &#123; n.print2(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 0; i &lt; 5 ; i++) &#123; try &#123; n.print3(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125;&#125;class NumPrinter&#123; private int num = 1; private int flag = 1; //使用ReentrantLock类和Condition接口来配合使用，指定唤醒哪个线程 private ReentrantLock lock = new ReentrantLock(); private Condition c1 = lock.newCondition(); private Condition c2 = lock.newCondition(); private Condition c3 = lock.newCondition(); public void print1() throws InterruptedException &#123; //三个线程同时占用临界区的资源，应该使用同步 lock.lock(); //获取锁 和 下面的 unlock 代替了 synchronized if(flag != 1) //当flag不为1时，c1进行等待，因为此时其他的线程正在执行他们的操作 c1.await(); if(num &lt;= 75) for (int i = 0; i &lt; 5; i++) &#123; System.out.println("1---"+num++); &#125; flag = 2; //标记指定为2，在print2中限制除了flag不为2时，c2进行等待 c2.signal(); //唤醒指定的c2 lock.unlock(); //释放锁 &#125; public void print2() throws InterruptedException &#123; lock.lock(); if(flag != 2) c2.await(); if(num &lt;= 75) for (int i = 0; i &lt; 5; i++) &#123; System.out.println("2---"+num++); &#125; flag = 3; c3.signal(); lock.unlock(); &#125; public void print3() throws InterruptedException &#123; lock.lock(); if(flag != 3) c3.await(); if(num &lt;= 75) for (int i = 0; i &lt; 5; i++) &#123; System.out.println("3---"+num++); &#125; flag = 1; c1.signal(); lock.unlock(); &#125;&#125;]]></content>
      <categories>
        <category>Java多线程基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
        <tag>互斥锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础-多线程同步]]></title>
    <url>%2F2018%2F06%2F20%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E9%A1%BE-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[同步代码需要同步的情况 当多线程并发，有多段代码同时执行时，希望某一段代码执行的过程中，CPU不要切换到其他线程上，此时就需要同步。 如果有两段代码是同步进行的，那么同一时间只能执行其中一段，在一段代码没执行结束之前，不会执行另外一段代码。 同步代码块操作 使用synchronized关键字加上一个锁对象来定义一段代码，这就称为同步代码块。 如果多个同步代码块使用同一个锁对象，那么他们就是同步的 同步代码块是锁机制，同一个锁对象，同步代码块是同步的。 锁对象是任意对象，但不能是匿名对象，因为匿名对象不是同一个对象。 当多个代码块使用了同一个锁对象的 synchronized 锁机制，只有当一个线程把 synchronized 代码块的代码全部执行完之后，才能去执行该同一锁对象的另一段代码。 即该多个代码块是同步的，同一时间只能执行其中一段，执行完之后，才能执行另一段。 若锁对象不一致，即不是同步的，会出现抢占线程执行的情况。 具体操作： 1234567891011121314151617181920212223242526272829303132333435363738394041public class SynchronizeTest &#123; public static void main(String[] args) &#123; Consumer con = new Consumer(); new Thread(()-&gt;&#123; while(true) con.print1(); &#125;).start(); new Thread(()-&gt;&#123; while(true) con.print2(); &#125;).start(); &#125;&#125;class Consumer &#123; //定义一个Object对象，作为锁对象 Object obj = new Object(); public void print1()&#123; //锁机制使用同一个锁对象 synchronized (obj)&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125; &#125; public void print2()&#123; //锁机制使用同一个锁对象，作为同步代码块 synchronized(obj)&#123; System.out.print("多"); System.out.print("线"); System.out.print("程"); System.out.println(); &#125; &#125;&#125; 同步方法 使用synchronized关键字修饰一个方法时，该方法中所有代码都是同步的。 123456789101112//同步方法只需在方法上加 synchronized public synchronized void print1()&#123; //锁机制使用同一个锁对象 synchronized (obj)&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125;&#125; 非静态同步函数的锁是this 1234567891011121314151617181920//同步方法只需在方法上加 synchronized public synchronized void print1()&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125;public void print2()&#123; //非静态的同步方法的锁对象是this synchronized(this)&#123; System.out.print("多"); System.out.print("线"); System.out.print("程"); System.out.println(); &#125;&#125; 此时 这两个方法时 同步的 静态同步函数的锁是字节码对象 静态域随着类的加载而加载，此时会产生该类的字节码对象，所以静态同步方法锁对象不能是this，而是产生的字节码对象 12345678910111213141516171819public static synchronized void print1()&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125;public static void print2()&#123; //静态的同步方法的锁对象是随着类加载而产生的类的字节码对象 synchronized(Customer.class)&#123; System.out.print("多"); System.out.print("线"); System.out.print("程"); System.out.println(); &#125;&#125; 同步方法和同步块，哪个是更好的选择 基本原则：同步的范围越小越好。 同步块之外的代码是异步执行的，比同步整个方法更有效率。]]></content>
      <categories>
        <category>Java多线程基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
        <tag>多线程同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础-线程的状态转换]]></title>
    <url>%2F2018%2F06%2F20%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E9%A1%BE-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[线程六大状态根据Thread类中定义的枚举类型State值，可以看出有6中状态： 1234567public enum State &#123; NEW, RUNNABLE, WAITING, TIMED_WAITING, TERMINATED;&#125; 新建状态 NEW 新建了Thread类对象，但是没有启动的线程。new Thread() 可运行状态 RUNNABLE 线程对象新建后，调用start()方法即处于了RUNNABLE状态。 此状态线程可能在Java虚拟机中运行； 可能在等待CPU处理器分配资源。 一个线程只有获取到CPU的资源后，才可以运行其run()方法执行代码，否则就会处于排队等待 阻塞状态 BLOCKED 该线程正在等待同步锁来进入一个同步代码块中来使用CPU资源，此时该线程就处于阻塞状态。 等待状态 WAITING 线程调用以下方法时，会自己进入等待状态： 不带超时的Object类中的wait()方法 不带超时的Thread类中的join()方法 LockSupport类中的park()方法 一直等待，直到手动唤醒 超时等待状态 TIMED_WAITING 线程调用带有正的等待时间参数的下列各方法时，会处于超时等待状态： Object中的wait() Thread中的join() Thread中的sleep() LockSupport中的parkNanos() LockSupport中的parkUntil() 终止状态 TERMINATED 线程执行完毕，或run()方法全部执行结束后，线程进入终止状态。 终止状态的线程不具备继续运行的能力。 线程状态图 锁池队列：当资源被一个线程访问时，上锁后，其他线程就会进入锁池队列，当锁释放后，其他线程获得了锁，就会变成可运行状态。 《Thinking in Java》中线程被阻塞的五种可能原因： 线程调用 sleep(ms) ，使线程睡眠，规定时间内，该线程不会运行。 使用suspend()暂停了线程的执行，除非收到resume()消息，否则不会进入可运行状态 线程正在等待一些IO操作完成 线程试图调用另一个对象的同步方法，但那个对象处于锁状态，暂时无法使用 调用wait()暂停了线程的执行，进入了等待队列。 怎么唤醒一个阻塞的线程 如果线程调用了 wait()、sleep()、join()方法而导致的阻塞，可以中断线程，并抛出InterruptedException来唤醒 如果该线程遇到了IO阻塞，只能等系统IO操作结束后，才能唤醒，Java代码无能为力，无法直接接触到底层操作系统的调度。 怎么检测一个线程是否持有对象监视器 Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true 1public static boolean holdsLock(Object obj)]]></content>
      <categories>
        <category>Java多线程基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
        <tag>线程状态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础-线程的实例方法]]></title>
    <url>%2F2018%2F06%2F20%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E9%A1%BE-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[线程相关实例方法获取线程ID- getId 在一个Java应用程序中，有一个long型的全局唯一的线程ID生成器threadSeqNumber，每new出来一个线程就会自增一次，从0开始，并且赋值给线程的tid属性。 用户只能获取ID，不能执行一个线程的ID，这是Thread类内部自己完成的。 获取和设置线程的名字 获取线程名 通过getName()方法获取线程对象名 123456new Thread()&#123; @Override public void run() &#123; System.out.println(this.getName());//Thread-0 &#125;&#125;.start(); 设置线程名 通过构造函数传入String类型名 12345678910111213new Thread("线程1")&#123; @Override public void run() &#123; System.out.println(this.getName());//线程1 &#125;&#125;.start();new Thread("线程2")&#123; @Override public void run() &#123; System.out.println(this.getName());//线程2 &#125;&#125;.start(); 12345//Lambda表达式的Runnable方式，Thread的构造函数Thread t2 = new Thread(() -&gt; System.out.println("线程5的执行方法体"),"线程5");t2.start();System.out.println(t2.getName());//线程5 通过setName(String name)方法设置 1234567new Thread()&#123; @Override public void run() &#123; this.setName("线程3"); System.out.println(this.getName());//线程3 &#125;&#125;.start(); 12345678Thread t1 = new Thread() &#123; @Override public void run() &#123; System.out.println(this.getName());//线程4 &#125;&#125;;t1.setName("线程4");t1.start(); 12345678Thread t1 = new Thread(()-&gt; System.out.println("线程4的执行方法体"));t1.setName("线程4");t1.start();System.out.println(t1.getName());//线程4/* 线程4 线程4的执行方法体 */ 线程对象是否处于活动状态 - isAlive t.isAlive() 测试线程t是否处于活动状态，只要线程启动并且没有终止，方法返回值就是true。 start()之前，线程不处于活动状态，之后就处于了活动状态。 获取当前线程的对象 Thread.currentThread() 静态方法，获取当前执行线程， 主线程也可以获取 1234//Runnable接口方式//new Thread(Runnable target,String threadName) 构造方法new Thread(()-&gt; System.out.println(Thread.currentThread().getName()),"线程6") .start();//线程6 在main方法中可以获取主线程对象并设置： 12Thread.currentThread().setName("我是主线程");System.out.println(Thread.currentThread().getName());//我是主线程 休眠线程-sleep Thread.sleep(毫秒) / Thread.sleep(毫秒，纳秒) 控制当前线程休眠若干毫秒 1秒 = 1000毫秒 1秒 = 1000 1000 1000 纳秒 （100,000,000） 12345678910new Thread(()-&gt;&#123; for(int i = 0; i &lt; 10 ;i++)&#123; System.out.println(Thread.currentThread().getName()); try&#123; Thread.sleep(1000); //每个线程休眠1秒（1000毫秒) &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;,"测试线程1").start(); sleep方法不会释放锁，wait方法会释放锁 加入线程-join join() 当前线程暂停，等待指定的线程执行结束后，当前线程才能再继续。即把指定的线程插队处理。 join(int ms) 可以等待指定的毫秒后再继续。 join()方法会使调用该方法的线程处于运行状态，让一开始所在的线程处于无限阻塞状态，直到调用了join方法的线程执行完毕，线程销毁为止。 下面这个例子中，t2线程处于了阻塞状态，直到t1线程的run()方法执行完，线程死亡状态，t2线程才可以运行。 123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; //Java8中 匿名内部类调用外接方法和变量时，外接变量可以不用final修饰，但是其值还是不能改变 Thread t1 = new Thread() &#123; //此时的t1在Java8之前必须用final修饰，是不可变的 @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "aaa"); &#125; &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 2) &#123; try &#123; //Java8中 匿名内部类调用外接方法和变量时，外接变量可以不用final修饰，但是其值还是不能改变 t1.join();//t1线程对象来插队了，t1执行完之后t2才能继续执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + "bbb"); &#125; &#125; &#125;; t1.start(); t2.start();&#125; 执行结果： 1234567891011121314151617181920Thread-1bbbThread-1bbbThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbb 结果显示：当t2线程执行两个后，t1使用join方法来插队，t1执行完之后，t2才继续执行完。 让出线程-yield Thread.yield() 使该线程让出cpu，给其他线程使用cpu执行 yield只会把时间片让给同优先级的线程 使CPU调度到其他线程，让该线程从运行状态回到可运行状态 设置线程优先级 thread.setPriority(int priority) 设置线程的优先级 Thread类源码中有三种优先级：(1,5,10) 1234567891011121314/** * The minimum priority that a thread can have. */public final static int MIN_PRIORITY = 1;/** * The default priority that is assigned to a thread. */public final static int NORM_PRIORITY = 5;/** * The maximum priority that a thread can have. */public final static int MAX_PRIORITY = 10; 优先级值：默认为5，最大为10，最小为1； 不能超过1~10这个范围。 12t1.setPriority(Thread.MIN_PRIORITY);//最小t1.setPriority(Thread.MAX_PRIORITY);//最大 中断线程-Interrupt 中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。 其他线程可以调用该线程的interrupt()方法对其进行中断操作，同时该线程可以调用isInterrupted()来感知其他线程对其是否进行了中断操作，从而做出相应。 也可以调用Thread中的静态方法interrupted()对当前线程进行中断操作，该方法会清除中断标志位。 当抛出InterruptedException时，会清除中断标志位，也就是说在调用isInterrupted会返回false。 如果线程调用了 wait()、sleep()、join()方法而导致的阻塞，可以中断线程，并抛出InterruptedException来唤醒 方法名 作用 备注 public void interrupt() 中断该线程对象 如果线程调用了 wait()、sleep()、join()方法而导致的阻塞，可以中断线程，并抛出InterruptedException来唤醒，并且中断标志位会被清除 public boolean isInterrupted() 测试该线程对象是否被中断 中断标志位不会被清除 public static boolean interrupted() 测试当前线程是否被中断 中断标志位会被清除 守护线程-Deamon setDaemon(boolean on) 设置一个线程作为守护线程。 守护线程为其他线程的运行提供便利的服务，最典型的应用便是GC线程 。 该线程不会单独执行，当其他非守护线程都执行结束后，守护线程就没有可服务的对象了，就会自动退出。 123456789101112131415161718public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt;&#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(Thread.currentThread().getName()+"非守护线程"); &#125; &#125;); Thread t2 = new Thread(()-&gt;&#123; for (int i = 0; i &lt; 30; i++) &#123; System.out.println(Thread.currentThread().getName()+"守护线程"); &#125; &#125;); t2.setDaemon(true);//将t2设置成守护线程 t1.start(); t2.start();&#125; 第一次执行结果： 123Thread-0非守护线程Thread-0非守护线程Thread-0非守护线程 说明：非守护线程直接执行完毕后，守护线程还未开启执行，就自动退出了。 第二次执行结果： 12345678910Thread-0非守护线程Thread-1守护线程Thread-1守护线程Thread-0非守护线程Thread-0非守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程 根据结果发现，守护线程和非守护线程穿插执行，非守护线程执行完之后，守护线程继续执行了，没有立即停止，该现象为线程缓冲，即守护线程正在执行，需要等到非守护线程的执行完毕信号后，才能停止下来，自动退出。 wait()和notify()/notifyAll()Object类中的wait()、notify()、notifyAll()三个方法，每个对象都是有的，结合多线程后可以起到很大的效果。 wait() wait()方法作用是使当前执行的代码的线程进行等待，当前线程会进入等待队列中。 wait()代码处会停止执行，直到接到通知（notify()）或者被中断（Interrupt()）。 在调用wait()之前，线程必须获取该对象的锁，因此wait()方法只能在同步代码中调用执行。 wait()方法可以使调用该线程的方法释放共享资源的锁，然后从运行状态退出，进入等待队列，直到再次被唤醒。 notify() 唤醒等待的线程，如果有多个线程在等待队列中，那么会随机挑选一个等待的线程，对其发出唤醒通知，并且使它等待获取该对象的对象锁。 等待获取对象锁说明了即使收到了通知，wait 的线程也不会马上获取对象锁，会在锁池中进行等待notify方法的线程释放锁才可以，获取了对象锁之后才能从锁池中出去进入可运行状态。 在调用notify()之前，和wait()一样，必须在同步代码中调用。因为有锁的操作。 notify()不释放锁 notifyAll() notifyAll()方法可以使所有正在等待队列中等待同一共享资源的全部线程从等待状态退出，随机进入锁池，等待拿到对象锁，进入可运行状态。 如果wait()方法和notify()/notifyAll()方法不在同步方法/同步代码块中被调用，那么虚拟机会抛出java.lang.IllegalMonitorStateException ☆ sleep()和wait()的区别 方法本质上： wait()方法时Object类中的实例方法。 而sleep()方法时Thread类中的静态方法 使用环境上： wait()方法必须要在同步方法或同步代码块中使用，因为它必须已经获得对象锁。 而sleep()方法没有这个限制，它可以在任何地方使用。 是否释放锁： wait()方法会释放占有的对象锁，使该线程进入等待池中。 而sleep()方法不会释放对象锁，只会让出CPU。 使其继续执行方式上： wait()方法必须等待 notify()/notifyAll()方法的唤醒通知后，才会离开等待池并且如果再次获得CPU时间片才会继续执行。 而sleep()方法在休眠时间到达后，如果再次获得CPU时间片就会继续执行。 Java中用到的线程调度算法 Java中用到的是抢占式的线程调度算法。一个线程用完CPU后，操作系统会根据线程优先级、线程饥饿程度等数据算出一个总的优先级并分配下一个时间片给某个线程。 Thread.sleep(0)的作用？ 平衡CPU控制权的一种操作： 由于Java采用的是抢占式线程调度算法，因此可能就会出现某条线程综合来看常常会获取到CPU的控制权的情况，为了让某些优先级较低的线程也能获得到CPU控制权，可以使用Thread.sleep(0)手动出发一次操作系统分配时间片的操作，来平衡控制权。]]></content>
      <categories>
        <category>Java多线程基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础-多线程的实现方式]]></title>
    <url>%2F2018%2F06%2F20%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E9%A1%BE-%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%92%8CCallable%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[多线程的实现方式方式一： 继承Thread类 Thread类实现了Runnable接口，在java.long包下。 创建执行线程方法一：将类继承Thread类，重写Thread类的run方法。接下来就可以分配并启动该子类的实例。 具体步骤： 继承Thread类 重写run方法 将执行的代码写在run方法中 创建Thread类的子类对象 使用start方法开启线程。 注意：调用run方法不能开启多线程。 只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。 一个线程不能多次开启是非法的 代码示例： 12345678910111213141516171819202122public class ThreadTest &#123; public static void main(String[] args) &#123; //4，创建Thread类的子类对象 MyThread mt = new MyThread(); mt.start();//5，使用start方法开启线程 for (int i = 0; i &lt; 10000; i++) &#123; System.out.println("main" + i); &#125; &#125;&#125;class MyThread extends Thread&#123; //1.继承Thread类 //2，重写run方法 @Override public void run()&#123; //3，将执行的代码写在run方法中 for (int i = 0; i &lt;10000 ; i++) &#123; System.out.println("mt"+i); &#125; &#125;&#125; 方式二：实现Runnable接口（常用，优点多） 声明实现Runnable接口的类，实现Runnable接口中仅有的run方法，然后分配实例对象，在创建Thread时作为一个参数来传递并启动。 具体步骤 1，定义类实现Runnable接口 2，在该类中实现Runnable接口中的run()方法 3，线程中具体要执行的东西写在run()方法中 4，创建Thread类的对象，并在该对象中传入该实现Runnable接口的对象作参数 5，Thread类的对象调用start()方法开启新线程，其内部会自动的调用run方法 12345678910111213141516171819202122public class RunnableTest &#123; public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); //4、创建自己定义的Runnable实现类的对象 Thread thread = new Thread(mr); //5、创建Thread类的对象，并将自定义Runnable实现类的对象作为参数传递给Thread的构造函数 thread.start(); //使用thread类的start方法开启线程。 for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("main+"+i); &#125; &#125;&#125;//1、定义一个Runnable实现类class MyRunnable implements Runnable&#123; //2、实现Runnable接口中的抽象方法 @Override public void run() &#123; //3、在run方法中写入要使用多线程的具体方法 for (int i = 0; i &lt;1000; i++) &#123; System.out.println("mr"+i); &#125; &#125;&#125; 实现Runnable接口方式的实现原理 1、查看Thread 类的构造函数，传递了Runnable接口的引用，直接调用了init方法。 123public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0); &#125; 2、追踪init方法，在init方法体中找到了传递的target参数，赋值给了Thread类的Runnable接口的成员变量的target 1this.target = target; 12/* What will be run. */ private Runnable target; 3、查看run方法时，发现run方法中有判断，如果target不为null就会调用实现Runnable接口子类对象的run方法 123456@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 为什么实例效果不明显？ 多线程指的是多个线程的代码块可以同时运行，而不必一个线程去等待另一个线程执行完才可以进行。 对于单核CPU来说，无法做到真正意义上的多线程特性。只能会让用户看起来像是同时执行的，因为每个时间点上，CPU都会执行特定的代码，由于CPU执行代码时间非常快，多个线程代码块就会轮询执行，速度很快，但是同一个线程进行的轮询操作。 具体执行某段代码多长时间和分时机制系统密切相关。 分时系统把CPU时间划分为多个时间片，操作系统以时间片为单位执行各个线程的代码，时间片越小，执行效率越高。 多线程的两种实现方式的区别 源码中的区别 继承Thread类方式：由于子类重写了Thread类的run()，当调用start()时，直接找子类的run()方法(Java虚拟机自动完成) 实现Runnable方式：构造函数中传入了Runnable的引用，传给了Thread类中的成员变量，start()调用了run()方法时的内部判断成员变量Runnable的引用是否为空，若不为空，编译时看的是Runnable的run()，运行时执行的是具体实现类中的run() 优缺点： 继承Thread类方式 好处：可以直接使用Thread类中的方法，代码简单 弊端：同样也是面向对象中的继承的缺点：如果该具体类已经有了其他的父类，那么就不能多重继承Thread类，就不能使用这种方法。此时面向接口编程的优势脱颖而出。 实现Runnable接口方式 好处：即继承的弊端：即使自己定义的线程类有了其他父类也可以实现该Runnable接口。Java中的接口是多实现的，继承是单继承，比较有局限性。 弊端：不能直接使用Thread类中的方法，需要先把Runnable具体实现类对象传递给Thread类并获取到线程对象后，才能得到Thread类的方法，代码相对复杂 匿名内部类实现线程的两种方式即直接使用匿名内部类的方式简化代码： 继承Thread类方式 123456789//匿名内部类new Thread()&#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("t+"+i); &#125; &#125;&#125;.start(); 实现Runnable接口方式 123456789//匿名内部类new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt;1000; i++) &#123; System.out.println("mr"+i); &#125; &#125;&#125;).start(); Runnable接口是一个函数式接口，可以直接用Lambda表达式代替: 123456//Lambda表达式new Thread(()-&gt;&#123; for (int i = 0; i &lt;1000; i++) &#123; System.out.println("mr"+i); &#125;&#125;).start(); 方式三：实现Callable接口 步骤： 创建实体类，实现Callable接口 实现接口中的call()方法 利用 ExecutorService线程池对象 的 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task()方法提交该Callable接口的线程任务。 123456789101112131415161718192021222324252627282930// 创建线程池ExecutorService pool = Executors.newFixedThreadPool(2);// 可以执行Runnable对象或者Callable对象代表的线程Future&lt;Integer&gt; f1 = pool.submit(new MyCallable(100));Future&lt;Integer&gt; f2 = pool.submit(new MyCallable(200));// V get()Integer i1 = f1.get();Integer i2 = f2.get();System.out.println(i1);System.out.println(i2);// 结束pool.shutdown();public class MyCallable implements Callable&lt;Integer&gt; &#123; private int number; public MyCallable(int number) &#123; this.number = number; &#125; @Override public Integer call() throws Exception &#123; int sum = 0; for (int x = 1; x &lt;= number; x++) &#123; sum += x; &#125; return sum; &#125;&#125; 利用匿名内部类方式： 123456789101112131415ExecutorService service = Executors.newSingleThreadExecutor(); Future&lt;String&gt; future = service.submit(new Callable() &#123; @Override public String call() throws Exception &#123; return "通过实现Callable接口"; &#125; &#125;); try &#123; String result = future.get(); System.out.println(result); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; Lambda表达式方式： 12345678910111213public class CallableTest &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; //使用Executors工厂类创建一个单线程池 ExecutorService es = Executors.newSingleThreadExecutor(); //使用这个单线程提交一个Callable接口线程服务，返回值为String //Callable接口是一个函数式接口，Java8开始可以直接使用Lambda表达式表示 //其内部实现了call()方法 V call() throws Exception; //并得到该结果值打印 System.out.println( es.submit(()-&gt;"使用lambda表达式的Callable接口").get()); es.shutdown(); //关闭该线程池 &#125;&#125; 实现callable接口，提交给ExecutorService返回值是异步执行的。 该方式的优缺点： 优点： 有返回值 可以抛出异常 缺点： 代码较复杂，需要利用线程池]]></content>
      <categories>
        <category>Java多线程基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础-线程安全和死锁问题]]></title>
    <url>%2F2018%2F06%2F20%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E9%A1%BE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%92%8C%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[线程安全 如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的 线程安全级别 1、不可变 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 2、绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的。不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet 3、相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。 4、 线程非安全 ArrayList、LinkedList、HashMap等都是线程非安全的类 常见的线程安全类 线程安全类 线程不安全类 Vector ArrayList StringBuffer StringBuilder Hashtable HashMap … LinkedList … … StringBuffer 线程安全（其append方法中加了synchronized修饰 vector add、remove方法都是原子操作,加了synchronized修饰 但是Collections集合工具类中提供了静态方法synchronizedXXX(XXX)，分别对应着线程不安全的那些集合类，可以让他们转换成线程安全的集合，所以Vector类淘汰了… 方法摘要 方法说明 static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) 返回指定 collection 支持的同步（线程安全的）collection。 static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) 返回指定列表支持的同步（线程安全的）列表。 static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) 返回由指定映射支持的同步（线程安全的）映射。 static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) 返回指定 set 支持的同步（线程安全的）set。 static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m) 返回指定有序映射支持的同步（线程安全的）有序映射。 static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s) 返回指定有序 set 支持的同步（线程安全的）有序 set。 多线程中的线程安全问题 多线程并发操作同一共享数据时，就会可能出现线程安全问题。 使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 就不会多个线程同时执行 多窗口卖票问题 如果不开启锁同步 ，就会出现卖出票号为负数的现象 在循环中使用锁同步，让各个线程进入循环之后进行同步，一个线程把ticketNum–后，其他线程再执行 使用Runnable方式实现： 123456789101112131415161718192021222324252627282930313233public class SynchronizeTicketTest &#123; public static void main(String[] args) &#123; new Thread(new TicketSeller()).start(); new Thread(new TicketSeller()).start(); new Thread(new TicketSeller()).start(); new Thread(new TicketSeller()).start(); &#125;&#125;class TicketSeller implements Runnable&#123; private static int tikcetNum = 10000;//总共10000张票，放到静态池中共享 @Override public void run() &#123; while(true)&#123; //在循环中使用锁同步，让各个线程进入循环之后进行同步，一个线程把ticketNum--后，其他线程再执行 synchronized(TicketSeller.class)&#123; if(tikcetNum &lt;= 0) break; try &#123; //让线程睡10ms 如果不开启锁同步 就会出现票号为负数的现象 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "...这是第" + tikcetNum-- + "号票"); &#125; &#125; &#125;&#125; 死锁问题 线程A和线程B相互等待对方持有的锁导致程序无限死循环下去 线程A持有锁H并且想获取锁W，此时线程B持有锁W并且想获取锁H，那么这两个线程AB就会永远等待下去，产生最简单的死锁。 一个类可能发生死锁，并不意味着每次都会发生，往往在高并发、高负载的情况下，死锁出现概率高很多。 多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁 写一个死锁程序 哲学家进餐问题，使用同步代码块嵌套，互相先持有对方需要的锁对象 写一个死锁程序步骤： 定义两个对象分别代表两个线程一开始就持有的锁对象 在run方法中使用 synchronized 同步代码块嵌套 外层synchronized锁对象是对方所需求的，自己所持有的，内层synchronized锁对象是对方所持有，自己所需要的 。 当一个线程中的锁对象是自己持有的，还未走出外层代码块，需要对方所持有的锁对象时，cpu调度到了另一个线程，另一个线程正好也是这种情况，此时双方都持有了对方所需要的锁对象，发生了死锁。 1234567891011121314151617181920212223242526272829303132333435public class DeadLockTest &#123; private static String left = "left one"; private static String right = "right one"; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; while(true)&#123; synchronized (right)&#123; System.out.println(Thread.currentThread().getName()+"--持有了right,想得到left"); synchronized(left)&#123; System.out.println(Thread.currentThread().getName()+"--得到了left,可以开吃了"); &#125; &#125; &#125; &#125;).start(); new Thread(() -&gt; &#123; while(true)&#123; synchronized (left)&#123; System.out.println(Thread.currentThread().getName()+"--持有了left,想得到right"); synchronized(right)&#123; System.out.println(Thread.currentThread().getName()+"--得到了right,可以开吃了"); &#125; &#125; &#125; &#125;).start(); /* Thread-1--持有了left,想得到right Thread-0--持有了right,想得到left 执行到此时，就会发现这两个线程的锁对象谁都不想放，就会产生死锁。 */ &#125;&#125; 结果： 123上方结果省略....Thread-1--持有了left,想得到rightThread-0--持有了right,想得到left 执行到此时，就会发现这两个线程的锁对象谁都不想放，就会产生死锁。 避免死锁的方式 注意和减少同步代码块嵌套问题 设计时考虑清楚锁的顺序，尽量减少嵌套加锁交互数量 由于死锁是因为两个或多个线程之间无限时间等待对方持有的锁对象而形成的，那么给同步代码块加个等待时间限制。 synchronized 关键字 不具备这个功能，使用Lock类中的tryLock方法，指定一个超时时限，在等待时，若超过该时限，就返回一个失败信息结束阻塞。 单例模式的线程安全问题单例模式 单例设计模式：保证一个类在内存中只有一个对象，内存唯一。 保证类在内存中只有一个对象： 1、控制类的创建，不让其他类来创建本类的对象，将本类的构造函数私有private 2、在本类中定义一个本类的对象，并且外界无法修改。 3、在本类中提供一个唯一的公共访问方法，可获取本类的对象。 饿汉式-线程安全 在类中直接创建一个不可修改的对象引用，不管有没有调用，都创建，空间换时间。 饿汉式在多线程环境下是线程安全的。 123456789101112class Singleton &#123; //1.将本类的构造函数私有private private Singleton ()&#123;&#125; //2. 在本类中定义一个本类的对象，并且外界无法修改。 private static Singleton s = new Singleton(); //3. 在本类中提供一个唯一的公共访问方法，可获取本类的对象 //饿汉式 public static Singleton getInstance()&#123; return s ; &#125;&#125; 另一种饿汉式，利用final直接修饰 1234567class Singleton &#123; //1.将本类的构造函数私有private private Singleton ()&#123;&#125; //2. 在本类中定义一个本类的对象，并且外界无法修改。 public final static Singleton s = new Singleton() ;&#125; 懒汉式-非线程安全 在类中获取对象时加以判断，为空时才创建，即用到该类对象时才创建，时间换空间。 懒汉式单例模式在多线程下是非线程安全的。 当线程A判断为null时，正准备new，此时，被另一个线程B抢占了CPU资源，线程B也判断为null，new了之后，第一个线程A又抢回了CPU资源，此时线程A又new了。此时这两个线程就new了两次，就不是唯一的内存引用了。 1234567891011121314class Singleton &#123; //1.将本类的构造函数私有private private Singleton ()&#123;&#125; //2. 在本类中定义一个本类的对象，并且外界无法修改。 private static Singleton s ; //3. 在本类中提供一个唯一的公共访问方法，可获取本类的对象 //懒汉式 对象引用为空 才创建， public static Singleton getInstance()&#123; //用到时创建，用不到时不创建 if(s == null) s = new Singleton() ; return s; &#125;&#125; 饿汉式和懒汉式的区别 线程安全上： 饿汉式线程安全，多线程下也不会创建多个对象 懒汉式非线程安全，多线程下可能会创建多个对象 执行效果： 饿汉式是 空间换时间，执行速度快。 懒汉式是 时间换空间，延迟加载。]]></content>
      <categories>
        <category>Java多线程基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
        <tag>线程安全</tag>
        <tag>死锁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机操作系统常用知识]]></title>
    <url>%2F2018%2F06%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[计算机操作系统常用知识进程和线程的具体含义，作用和区别进程 进程是具有一定功能的程序关于某个数据集合上的一次运行活动 进程是系统进行资源调度和分配的一个独立单位。 进程是正在运行的程序 线程 线程是进程的实体 线程是CPU调度和分派的基本单位。 线程是比进程更小的，能独立运行的基本单位。 区别一个进程可以有多个线程（至少一个），多个线程也可以并发执行。 进程作为资源（如内存）分配的基本单位，其线程都是可以享用被分配的资源的，但是线程可以共享一块内存的资源，而进程则不能分享彼此间的资源的，进程只能通过进程间的通信机制来完成进程间通信。 进程间的通信机制有以下几种 管道（pipe 半双工），流管道（s_pipe，全双工），命名管道（name_pipe，半双工） 管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程。 命名管道： 半双工通信方式，它允许无亲缘关系的进程间进行通信 信号量 ： 是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。 信号：是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存： 共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。 共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。 套接字（socket）：套接字是一种进程间的通信机制，与其他通信机制不同的是，它可以用于不同及其间的进程通信。 程序 程序是一个静态概念，它是指在计算机的文件系统里以文件形式存储的一段可运行代码。 程序和进程的区别 进程是个动态的概念，它通常是指操作系统里一个程序在一个数据集合上一次运行过程的体现。即进程是程序的运行逻辑实际运作起来的载体。 进程同步 进程同步机制的主要任务是对多个相关进程在执行次序上进行协调，是并发执行的进程之间能按照一定规则共享系统资源，并能很好地相互合作，从而是程序的执行具有可再现性。 并发的线程在一些关键点上可能需要相互等待与互通信息，这种相互制约的等待与互通信息称为线程同步 临界资源 指一次仅仅允许一个线程使用的资源，许多物理设备，如打印机都有这种性质。除了物理设备外，还有一些软件资源，若被多线程所共享也具有这一特点，如变量、数据、表格、队列等。它们虽可以为若干线程所共享，但一次只能为一个线程所利用。 临界区 临界区指的是一段访问共享资源（被多个线程共享的临界资源）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待。 同步机制遵循的规则 空闲让进 当没有进程进入临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效利用临界资源。 忙则等待 当已有进程进入临界区时，表明临界资源正在被访问，因而其他试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。 有限等待 对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入死等状态 让权等待 当进程不能进入自己的临界区时，应立即释放处理机，以免线程陷入忙等状态。 线程同步的方式 互斥量 Mutex：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。 信号量 Semaphore：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。 事件（信号）Event：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。 什么是缓冲区溢出？有什么危害？其原因是什么？ 缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。 危害： 程序崩溃，导致拒绝服务 跳转并且执行一段恶意代码 造成溢出的原因：程序中没有仔细检查用户输入。 什么是死锁？死锁产生的条件？ 在两个或多个并发进程中，如果每个进程持有某种资源而又等待其他进程释放它或它们现在保持的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。 通俗讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。 死锁产生的四个条件（有一个条件不成立，则不会产生死锁） 互斥条件：一个资源一次只能被一个进程使用 请求与保持条件：一个进程因请求资源而阻塞时，对已经获取资源保持不放。 不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系 进程的状态 就绪：进程已经获得除处理机以外的所需资源，等待分配处理机资源 运行：占用处理机资源运行，处于此状态的进程数小于等于CPU数 阻塞状态：进程等待某种条件，在满足条件之前无法执行 分页和分段区别 段是信息的逻辑单位，它是根据用户的需要划分的，因此段对用户是可见的；页是信息的物理单位，是为了管理主存的方便而划分的，对用户是透明的； 段的大小不固定，有它所完成的功能决定；页的大小固定，由系统决定。 段向用户提供二维地址空间；页向用户提供是一维地址空间 段是信息的逻辑单位，便于存储保护和信息共享，页的保护和共享收到限制。 进程同步机制 原子操作 信号量机制 自旋锁管程 会合 分布式系统 进程调度策略 FCFS 优先级 时间片轮转 多级反馈 常见调度算法 先来先服务调度算法（FCFS）:就是按照各个作业进入系统的自然次序来调度作业。这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。不利于短作业； 短作业优先调度算法 (SPF): 就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。 最高响应比优先算法(HRN)：FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择响应比最高的作业运行。响应比=1+作业等待时间/作业处理时间。 基于优先数调度算法(HPF)：每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择优先数最高的作业。 自底向上的分析技术 有：（ 1 ）简单优先分析法 （ 2 ）算符优先分析法 （ 3 ）优先函数 （ 4 ） LR 分析法 曼彻斯特编码的编码规则:在信号位中电平从低到高跳变表示1在信号位中电平从高到低跳变表示0差分曼彻斯特编码的编码规则是:在信号位开始时改变信号极性，表示辑”1”在信号位开始时不改变信号极性，表示逻辑”0” 中间件中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。 时间重叠 让多个处理过程在时间上错开，轮流重叠的使用同一套硬件设备的各个部分，加快硬件使用的周转来赢得速度。——流水线处理机 资源重叠 通过重复设置硬件资源来提高性能或可靠性。——并行处理机、相联处理机 资源共享 用软件的方法让多个用户公用同一套资源，通过提高系统资源的利用率来提高系统的效率和性能。——多处理机** 阵列处理机 单指令流多数据流； 采用资源重复技术。 采用流水结构的单机系统 单指令流多数据流； 采用时间重复技术。 时间并行性概念的实现方式就是采用流水处理部件。这是一种非常经济而实用的 并行技术 ，能保证计算机系统具有较高的性能价格比。目前的高性能微型机几乎无一例外地使用了流水技术。 悲观锁和乐观锁悲观锁 总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿数据就会阻塞直到它拿到锁。传统关系型数据库就用到了很多这种锁机制：行锁，表锁等，读锁，写锁等，都在做操作之前先上锁。再比如Java里的synchronized关键字的实现也是悲观锁。 乐观锁 想象着情况很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。 乐观锁适用于多读的应用类型，这样可以提高吞吐量，想数据库提供的类似于write_condition机制，其实都是提供的乐观锁。 两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适]]></content>
      <categories>
        <category>理论</category>
      </categories>
      <tags>
        <tag>计算机操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程基础-线程的实例方法]]></title>
    <url>%2F2018%2F06%2F20%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9B%9E%E9%A1%BE-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[线程相关实例方法获取线程ID- getId 在一个Java应用程序中，有一个long型的全局唯一的线程ID生成器threadSeqNumber，每new出来一个线程就会自增一次，从0开始，并且赋值给线程的tid属性。 用户只能获取ID，不能执行一个线程的ID，这是Thread类内部自己完成的。 获取和设置线程的名字 获取线程名 通过getName()方法获取线程对象名 123456new Thread()&#123; @Override public void run() &#123; System.out.println(this.getName());//Thread-0 &#125;&#125;.start(); 设置线程名 通过构造函数传入String类型名 12345678910111213new Thread("线程1")&#123; @Override public void run() &#123; System.out.println(this.getName());//线程1 &#125;&#125;.start();new Thread("线程2")&#123; @Override public void run() &#123; System.out.println(this.getName());//线程2 &#125;&#125;.start(); 12345//Lambda表达式的Runnable方式，Thread的构造函数Thread t2 = new Thread(() -&gt; System.out.println("线程5的执行方法体"),"线程5");t2.start();System.out.println(t2.getName());//线程5 通过setName(String name)方法设置 1234567new Thread()&#123; @Override public void run() &#123; this.setName("线程3"); System.out.println(this.getName());//线程3 &#125;&#125;.start(); 12345678Thread t1 = new Thread() &#123; @Override public void run() &#123; System.out.println(this.getName());//线程4 &#125;&#125;;t1.setName("线程4");t1.start(); 12345678Thread t1 = new Thread(()-&gt; System.out.println("线程4的执行方法体"));t1.setName("线程4");t1.start();System.out.println(t1.getName());//线程4/* 线程4 线程4的执行方法体 */ 线程对象是否处于活动状态 - isAlive t.isAlive() 测试线程t是否处于活动状态，只要线程启动并且没有终止，方法返回值就是true。 start()之前，线程不处于活动状态，之后就处于了活动状态。 获取当前线程的对象 Thread.currentThread() 静态方法，获取当前执行线程， 主线程也可以获取 1234//Runnable接口方式//new Thread(Runnable target,String threadName) 构造方法new Thread(()-&gt; System.out.println(Thread.currentThread().getName()),"线程6") .start();//线程6 在main方法中可以获取主线程对象并设置： 12Thread.currentThread().setName("我是主线程");System.out.println(Thread.currentThread().getName());//我是主线程 休眠线程-sleep Thread.sleep(毫秒) / Thread.sleep(毫秒，纳秒) 控制当前线程休眠若干毫秒 1秒 = 1000毫秒 1秒 = 1000 1000 1000 纳秒 （100,000,000） 12345678910new Thread(()-&gt;&#123; for(int i = 0; i &lt; 10 ;i++)&#123; System.out.println(Thread.currentThread().getName()); try&#123; Thread.sleep(1000); //每个线程休眠1秒（1000毫秒) &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;,"测试线程1").start(); sleep方法不会释放锁，wait方法会释放锁 加入线程-join join() 当前线程暂停，等待指定的线程执行结束后，当前线程才能再继续。即把指定的线程插队处理。 join(int ms) 可以等待指定的毫秒后再继续。 join()方法会使调用该方法的线程处于运行状态，让一开始所在的线程处于无限阻塞状态，直到调用了join方法的线程执行完毕，线程销毁为止。 下面这个例子中，t2线程处于了阻塞状态，直到t1线程的run()方法执行完，线程死亡状态，t2线程才可以运行。 123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; //Java8中 匿名内部类调用外接方法和变量时，外接变量可以不用final修饰，但是其值还是不能改变 Thread t1 = new Thread() &#123; //此时的t1在Java8之前必须用final修饰，是不可变的 @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "aaa"); &#125; &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 2) &#123; try &#123; //Java8中 匿名内部类调用外接方法和变量时，外接变量可以不用final修饰，但是其值还是不能改变 t1.join();//t1线程对象来插队了，t1执行完之后t2才能继续执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + "bbb"); &#125; &#125; &#125;; t1.start(); t2.start();&#125; 执行结果： 1234567891011121314151617181920Thread-1bbbThread-1bbbThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbb 结果显示：当t2线程执行两个后，t1使用join方法来插队，t1执行完之后，t2才继续执行完。 让出线程-yield Thread.yield() 使该线程让出cpu，给其他线程使用cpu执行 yield只会把时间片让给同优先级的线程 使CPU调度到其他线程，让该线程从运行状态回到可运行状态 设置线程优先级 thread.setPriority(int priority) 设置线程的优先级 Thread类源码中有三种优先级：(1,5,10) 1234567891011121314/** * The minimum priority that a thread can have. */public final static int MIN_PRIORITY = 1;/** * The default priority that is assigned to a thread. */public final static int NORM_PRIORITY = 5;/** * The maximum priority that a thread can have. */public final static int MAX_PRIORITY = 10; 优先级值：默认为5，最大为10，最小为1； 不能超过1~10这个范围。 12t1.setPriority(Thread.MIN_PRIORITY);//最小t1.setPriority(Thread.MAX_PRIORITY);//最大 中断线程-Interrupt 中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。 其他线程可以调用该线程的interrupt()方法对其进行中断操作，同时该线程可以调用isInterrupted()来感知其他线程对其是否进行了中断操作，从而做出相应。 也可以调用Thread中的静态方法interrupted()对当前线程进行中断操作，该方法会清除中断标志位。 当抛出InterruptedException时，会清除中断标志位，也就是说在调用isInterrupted会返回false。 如果线程调用了 wait()、sleep()、join()方法而导致的阻塞，可以中断线程，并抛出InterruptedException来唤醒 方法名 作用 备注 public void interrupt() 中断该线程对象 如果线程调用了 wait()、sleep()、join()方法而导致的阻塞，可以中断线程，并抛出InterruptedException来唤醒，并且中断标志位会被清除 public boolean isInterrupted() 测试该线程对象是否被中断 中断标志位不会被清除 public static boolean interrupted() 测试当前线程是否被中断 中断标志位会被清除 守护线程-Deamon setDaemon(boolean on) 设置一个线程作为守护线程。 守护线程为其他线程的运行提供便利的服务，最典型的应用便是GC线程 。 该线程不会单独执行，当其他非守护线程都执行结束后，守护线程就没有可服务的对象了，就会自动退出。 123456789101112131415161718public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt;&#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(Thread.currentThread().getName()+"非守护线程"); &#125; &#125;); Thread t2 = new Thread(()-&gt;&#123; for (int i = 0; i &lt; 30; i++) &#123; System.out.println(Thread.currentThread().getName()+"守护线程"); &#125; &#125;); t2.setDaemon(true);//将t2设置成守护线程 t1.start(); t2.start();&#125; 第一次执行结果： 123Thread-0非守护线程Thread-0非守护线程Thread-0非守护线程 说明：非守护线程直接执行完毕后，守护线程还未开启执行，就自动退出了。 第二次执行结果： 12345678910Thread-0非守护线程Thread-1守护线程Thread-1守护线程Thread-0非守护线程Thread-0非守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程 根据结果发现，守护线程和非守护线程穿插执行，非守护线程执行完之后，守护线程继续执行了，没有立即停止，该现象为线程缓冲，即守护线程正在执行，需要等到非守护线程的执行完毕信号后，才能停止下来，自动退出。 wait()和notify()/notifyAll()Object类中的wait()、notify()、notifyAll()三个方法，每个对象都是有的，结合多线程后可以起到很大的效果。 wait() wait()方法作用是使当前执行的代码的线程进行等待，当前线程会进入等待队列中。 wait()代码处会停止执行，直到接到通知（notify()）或者被中断（Interrupt()）。 在调用wait()之前，线程必须获取该对象的锁，因此wait()方法只能在同步代码中调用执行。 wait()方法可以使调用该线程的方法释放共享资源的锁，然后从运行状态退出，进入等待队列，直到再次被唤醒。 notify() 唤醒等待的线程，如果有多个线程在等待队列中，那么会随机挑选一个等待的线程，对其发出唤醒通知，并且使它等待获取该对象的对象锁。 等待获取对象锁说明了即使收到了通知，wait 的线程也不会马上获取对象锁，会在锁池中进行等待notify方法的线程释放锁才可以，获取了对象锁之后才能从锁池中出去进入可运行状态。 在调用notify()之前，和wait()一样，必须在同步代码中调用。因为有锁的操作。 notify()不释放锁 notifyAll() notifyAll()方法可以使所有正在等待队列中等待同一共享资源的全部线程从等待状态退出，随机进入锁池，等待拿到对象锁，进入可运行状态。 如果wait()方法和notify()/notifyAll()方法不在同步方法/同步代码块中被调用，那么虚拟机会抛出java.lang.IllegalMonitorStateException ☆ sleep()和wait()的区别 方法本质上： wait()方法时Object类中的实例方法。 而sleep()方法时Thread类中的静态方法 使用环境上： wait()方法必须要在同步方法或同步代码块中使用，因为它必须已经获得对象锁。 而sleep()方法没有这个限制，它可以在任何地方使用。 是否释放锁： wait()方法会释放占有的对象锁，使该线程进入等待池中。 而sleep()方法不会释放对象锁，只会让出CPU。 使其继续执行方式上： wait()方法必须等待 notify()/notifyAll()方法的唤醒通知后，才会离开等待池并且如果再次获得CPU时间片才会继续执行。 而sleep()方法在休眠时间到达后，如果再次获得CPU时间片就会继续执行。 Java中用到的线程调度算法 Java中用到的是抢占式的线程调度算法。一个线程用完CPU后，操作系统会根据线程优先级、线程饥饿程度等数据算出一个总的优先级并分配下一个时间片给某个线程。 Thread.sleep(0)的作用？ 平衡CPU控制权的一种操作： 由于Java采用的是抢占式线程调度算法，因此可能就会出现某条线程综合来看常常会获取到CPU的控制权的情况，为了让某些优先级较低的线程也能获得到CPU控制权，可以使用Thread.sleep(0)手动出发一次操作系统分配时间片的操作，来平衡控制权。]]></content>
      <categories>
        <category>Java多线程基础</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Java中的多态和instanceof]]></title>
    <url>%2F2018%2F06%2F16%2F%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%E5%92%8Cinstanceof%2F</url>
    <content type="text"><![CDATA[多态 事物 存在的多种形态 多态的前提 有继承关系 有方法重写 有父类引用指向子类对象 多态成员访问特点 成员变量 编译看左边（父类），运行看左边（父类）。 成员方法 编译看左边（父类），运行看右边（子类）。动态绑定 静态方法 编译看左边（父类），运行看左边（父类）。 静态和类相关，算不上重写，只是子类运行时覆盖了父类的静态方法，所以访问还是看父类。 只有非静态成员方法，编译看左边，运行看右边。 父类引用指向子类对象，就是向上转型。 Animal a = new Dog(); 指向子类对象的父类引用，强转成子类类型，使用子类中特有的方法。向下转型。把一个父类对象赋给子类引用变量时，就需要进行强制类型转换。 12Animal a = new Dog();Dog dog = (Dog)a; 引用变量的强制类型转换 引用变量只能调用它编译时类型的方法，而不能调用它运行时类型的方法，即使他实际所引用的对象确实包含该方法。 如果需要让这个引用变量调用它运行时类型的方法，则必须把它强制类型转换成运行时类型。 当进行强制类型转换时需要注意： 基本类型之间的转换只能在数值类型之间进行，这里所说的数值类型包括整型，浮点型，字符型。但数值类型和布尔类型之间不能进行类型转换。 引用类型之间的转换只能在具有继承关系的两个类型之间进行，如果是两个没有任何继承关系的类型，则无法进行类型转换，否则编译时就会出现错误。 如果试图把一个父类实例转换成子类类型，则这个对象必须实际上是子类实例才行（即编译时为父类类型，而运行时类型是子类），否则将在运行时引发ClassCastException异常。 123456789101112131415161718192021222324public class ConversionTest&#123; public static void main(String[] args) &#123; double d = 13.4; long l = (long)d; System.out.println(l); int in = 5; // 试图把一个数值类型的变量转换为boolean类型，下面代码编译出错 // 编译时候会提示: 不可转换的类型 // boolean b = (boolean)in; Object obj = "Hello"; // obj变量的编译类型为Object，Object与String存在继承关系，可以强制类型转换 // 而且obj变量实际上类型是String类型，所以运行时也可通过 String objStr = (String)obj; System.out.println(objStr); // 定义一个objPri变量，编译类型为Object，实际类型为Integer Object objPri = Integer.valueOf(5); // objPri变量的编译时类型为Object，objPri的运行时类型为Integer，Object与Integer存在继承关系 // 可以强制类型转换，而objPri变量实际上类型是Integer类型， // 所以下面代码运行时引发ClassCastException异常 String str = (String)objPri; &#125;&#125; 当把子类对象赋给父类引用变量时，称为向上转型（upcasting），向上转型总是可以成功的，因为子类是一种特殊的父类。这种转型只是表明这个引用变量的编译类型是父类，但实际执行它的方法时，依然表现出子类对象的行为方式。 使用instanceof运算符，可以判断是否可以成功转换，从而避免出现转换异常。 123if (obj instanceof String)&#123; String str = (String)obj;&#125; instanceof 运算符 instanceof运算符前一个操作数通常是一个引用类型变量，后一个操作数通常是一个类，也可以是一个接口，用于判断前面的对象是否是后面的类，或者其子类、实现类的实例。 instanceof运算符前面操作数的编译时类型要么与后面的类相同，要么与后面的类具有父子继承关系，否则编译错误。 123456789101112131415161718192021222324public class InstanceofTest&#123; public static void main(String[] args) &#123; // 声明hello时使用Object类，则hello的编译类型是Object， // Object是所有类的父类, 但hello变量的实际类型是String Object hello = "Hello"; // String与Object类存在继承关系，可以进行instanceof运算。返回true。 System.out.println("字符串是否是Object类的实例：" + (hello instanceof Object)); System.out.println("字符串是否是String类的实例：" + (hello instanceof String)); // 返回true。 // Math与Object类存在继承关系，可以进行instanceof运算。返回false。 System.out.println("字符串是否是Math类的实例：" + (hello instanceof Math)); // String实现了Comparable接口，所以返回true。 System.out.println("字符串是否是Comparable接口的实例：" + (hello instanceof Comparable)); String a = "Hello";// // String类与Math类没有继承关系，所以下面代码编译无法通过// System.out.println("字符串是否是Math类的实例："// + (a instanceof Math)); &#125;&#125; instanceof运算符的作用：在进行强制类型转换之前，首先判断前一个对象是否是后一个类的实例，是否可以成功转换，从而保证代码健壮性。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些缓存问题]]></title>
    <url>%2F2018%2F06%2F16%2F%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[缓存问题缓存的雪崩场景 原因： 缓存大面积的同时失效 解决：避免缓存设置相近的有效期 为有效期增加随机值 统一规划有效期，失效时间均匀分布 如果是热点信息，持续高并发 增加互斥锁（Jvm锁机制，分布式锁机制） 实现缓存永不过期，异步更新 优点：不阻塞线程，用户体验好，不会出现雪崩场景 缺点：不保证一致性，代码复杂度增大（每个value都要维护异步更新代码），容易堆积垃圾数据 使用缓存主要解决数据同步，并减少对数据库访问次数。因此，通常解决方案往往是使用互斥锁，让一个线程访问数据库，并将数据更新到缓存中，其他线程访问缓存中数据。如果是基于jvm锁机制的话，只能解决单机问题，也就是只让本机一个线程访问缓存，但是分布式条件下是不能使用的。所以，要基于缓存的分布式锁来实现。 以redis为例解释下实现分布式锁的原理: 获取锁： 所有线程操作一个共同的key比如lock，如果redis中不存在key为lock的值，那么当前线程获取锁并为lock设置一个随机值。如果lock已经存在了，说明已经有线程获取锁，该线程不能再获取了。 释放锁： 获取锁的线程操作执行完毕后，清除lock的值，这样锁就释放了。所以，对锁的操作就是通过对同一个key值的添加和删除操作。]]></content>
      <categories>
        <category>缓存</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel和CSV类型数据文件自动录入重构封装]]></title>
    <url>%2F2018%2F06%2F13%2FJava%20Excel%E5%92%8CCSV%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E8%87%AA%E5%8A%A8%E5%BD%95%E5%85%A5%E5%B0%8F%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Excel和CSV类型数据文件自动录入重构封装GitHub链接jar包和依赖包链接：https://pan.baidu.com/s/1QsA6wzu1ofIBbXQbXm9TAw 密码：tdop 依赖包 java8 dom4j-1.6.1.jar poi-3.7-20101029.jar （POI Excel文件处理） poi-ooxml-3.7-20101029.jar poi-ooxml-schemas-3.7-20101029.jar super-csv-2.4.0.jar （csv文件类型） xmlbeans-2.3.0.jar 实体类中在实体类中字段上方@ExportColumn注解指定需要通过数据文件录入字段 @ExportColumn注解的value值为该字段对应的数据文件中对应的中文名 下方代码中，@Data注解为lombok的注解，也可不用 不用后，需加入无参构造 setter 和 getter最好重写toString、hashcode、equals方法，使用lombok的Data注解这些事情可省去，其自动完成 1234567891011121314@Data public class Student &#123; @ExportColumn("学号") private String xh; @ExportColumn("年龄") private String nl; @ExportColumn("姓名") private String xm; private String lj; private String nj;&#125; 客户端使用Excel文件类型 xlsx 和 xls 均可 主类 ExcelScanner 直接调用ExcelScanner类中的静态方法scanAndSave 123456789/** * 读取Excel数据源的信息存入数据库中 excel文件中的工作表默认为0 * @param filePath Excel文件路径 * @param entityClazz 具体实体类class对象 * @param dao 存入数据库的dao接口 * @return ResultMap */public static &lt;T&gt; ResultMap scanAndSave(String filePath, Class&lt;T&gt; entityClazz, SaveListDao&lt;T&gt; dao) throws ReflectiveOperationException 指定读取Excel工作表号的数据源的信息存入数据库中1234567891011 /** * 读取Excel数据源的信息存入数据库中 * @param filePath Excel文件路径 * @param entityClazz 具体实体类class对象 * @param dao 存入数据库的dao接口 * @param sheetAt excel文件中的工作表号 * @return * @throws ReflectiveOperationException */public static &lt;T&gt; ResultMap scanAndSave(String filePath, Class&lt;T&gt; entityClazz, SaveListDao&lt;T&gt; dao, int sheetAt) throws ReflectiveOperationException 12345678910111213141516@Test public void test3() throws ReflectiveOperationException &#123; String filePath = "D://123.xlsx"; // 主方法 指定文件路径 录入对应的实体类class对象 DAO接口 ExcelScanner.scanAndSave(filePath, Student.class, //模拟DAO接口 存入数据库数据 (list) -&gt; &#123; int i = 0; for (Student s : list) &#123; System.out.println(s.toString()); i++; &#125; return i; &#125;).forEach((k, v)-&gt; System.out.println(k+"---"+v)); &#125; csv文件类型主类 CsvScanner直接调用CsvScanner类中的静态方法scanAndSave12345678910 /** * * @param filePath 文件绝对路径 * @param entityClazz 实体类class对象 * @param dao 导入数据接口 * @param cellProcessor csv文件单元处理器 * @param &lt;T&gt; * @return ResultMap 结果Map extends HashMa */public static &lt;T&gt; ResultMap scanAndSave(String filePath, Class&lt;T&gt; entityClazz, SaveListDao&lt;T&gt; dao, CellProcessor[] cellProcessor) 123456789101112131415161718@Test public void test2() throws ReflectiveOperationException &#123; String filePath = "F:/123.csv"; CsvScanner.scanAndSave(filePath, //文件路径 Xsxk.class, //实体类class对象 (list) -&gt; &#123; //DAO数据接口 int i = 0; for (Xsxk s : list) &#123; System.out.println(s.toString()); i++; &#125; return i; &#125;,new CellProcessor[]&#123; //csv文件对应的实体的单元处理器 null, null, null, null, null, null, null, null, null, null, null, null, null,null,null &#125;).forEach((k, v)-&gt; System.out.println(k+"---"+v)); &#125; 效果错误提示 文件中缺少指定字段 12 msg---未检测到字段名:[学号, 年龄, 姓名],请核对code---500 文件后缀名错误 文件类型不匹配 正确提示12msg---本次读取了4条数据,共导入了4条,相差0条未导入，请核对！code---200 待完善…]]></content>
      <categories>
        <category>重构</category>
      </categories>
      <tags>
        <tag>重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存不可变类]]></title>
    <url>%2F2018%2F06%2F11%2FJava-%E7%BC%93%E5%AD%98%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[不可变类 不可变类的意思是创建该类实例后，该实例的实例变量是不可改变的。 Java中的8个包装类和java.lang.String类都是不可变类，当创建它们的实例后，其实例变量不可改变。 如果需要创建自定义的不可变类，遵循以下规则： 使用private和final修饰符来修饰该类的成员变量 提供带参数构造器，用于根据传入参数来初始化类中的成员变量 仅为该类的成员变量提供getter方法，不要为该类的成员变量提供setter方法，因为普通方法无法修改final修饰的成员变量 如果有必要，重写hashCode()和equals()。 equals()方法根据关键成员变量来作为两个对象是否相等的标准 应保证两个用equals()方法判断为相等的对象的hashCode()也相等 例如String类对象里的字符序列作为相等的标准，其hashCode()方法也是根据字符序列计算得到的。 String类中的equals()方法源码 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; String类中的hashCode()方法的源码： 123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 可变类的含义是该类的实例变量是可变的。大部分创建的类都是可变类，特别是JavaBean，因为总是为其实例变量提供了setter和getter方法。 与可变类相比，不可变类的实例在整个生命周期中永远处于初始化状态，它的实例变量不可改变。因此对不可变类的实例的控制将更加简单。 如果需要设计一个不可变类，尤其要注意其引用类型的成员变量，如果引用类型的成员变量的类是可变的，就必须采取必要的措施来保护该成员变量所引用的对象不会被修改，这样才能创建真正的不可变类。 缓存不可变类 不可变类的实例状态不可改变，可以很方便的被多个对象共享。如果程序经常使用相同的不可变实例，就应该考虑缓存这种不可变类的实例。毕竟重复创建相同的对象没有意义，而且会加大系统开销。 用数组创建缓存池，用于缓存实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class CacheImmutale&#123; private static int MAX_SIZE = 10; // 使用数组来缓存已有的实例 private static CacheImmutale[] cache = new CacheImmutale[MAX_SIZE]; // 记录缓存实例在缓存中的位置,cache[pos-1]是最新缓存的实例 private static int pos = 0; private final String name; private CacheImmutale(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public static CacheImmutale valueOf(String name) &#123; // 遍历已缓存的对象， for (int i = 0 ; i &lt; MAX_SIZE; i++) &#123; // 如果已有相同实例，直接返回该缓存的实例 if (cache[i] != null &amp;&amp; cache[i].getName().equals(name)) &#123; return cache[i]; &#125; &#125; // 如果缓存池已满 if (pos == MAX_SIZE) &#123; //先进先出 // 把缓存的第一个对象覆盖，即把刚刚生成的对象放在缓存池的最开始位置。 cache[0] = new CacheImmutale(name); // 把pos设为1 pos = 1; &#125; else &#123; // 把新创建的对象缓存起来，pos加1 cache[pos++] = new CacheImmutale(name); &#125; return cache[pos - 1]; &#125; public boolean equals(Object obj) &#123; if(this == obj) &#123; return true; &#125; if (obj != null &amp;&amp; obj.getClass() == CacheImmutale.class) &#123; CacheImmutale ci = (CacheImmutale)obj; return name.equals(ci.getName()); &#125; return false; &#125; public int hashCode() &#123; return name.hashCode(); &#125;&#125;public class CacheImmutaleTest&#123; public static void main(String[] args) &#123; CacheImmutale c1 = CacheImmutale.valueOf("hello"); CacheImmutale c2 = CacheImmutale.valueOf("hello"); // 下面代码将输出true System.out.println(c1 == c2); &#125;&#125; 是否需要隐藏缓存池类的构造器完全取决于系统需求。盲目乱用缓存也可能导致系统性能下降，缓存的对象会占用系统内存，如果某个对象只使用一次，重复使用的概率不大，缓存该实例就弊大于利；反之，如果某个对象需要频繁地重复使用，缓存该实例就利大于弊。 Java中Integer类就采取了上述CacheImmutale类相同的处理策略，如果采用new构造器来创建Integetr对象，则每次返回全新的Integer对象；如果采用valueOf()方法来创建Integer对象，则会缓存该方法创建的对象。 由于new构造器方式创建Integer对象不会启用缓存，因此性能较差，所以Java9中已经将该构造器标记为过时，全面采用valueOf()方法创建。 12345678910111213141516171819public class IntegerCacheTest&#123; public static void main(String[] args) &#123; // 生成新的Integer对象 Integer in1 = new Integer(6); // 生成新的Integer对象，并缓存该对象 Integer in2 = Integer.valueOf(6); // 直接从缓存中取出Ineger对象 Integer in3 = Integer.valueOf(6); System.out.println(in1 == in2); // 输出false System.out.println(in2 == in3); // 输出true // 由于Integer只缓存-128~127之间的值， // 因此200对应的Integer对象没有被缓存。 Integer in4 = Integer.valueOf(200); Integer in5 = Integer.valueOf(200); System.out.println(in4 == in5); //输出false &#125;&#125; 由于Integer只缓存-128~127之间的Integer对象，因此两次通过Integer.valueOf(200)方法生成的Integer对象不是同一个。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>不可变类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解Java中的final]]></title>
    <url>%2F2018%2F06%2F11%2F%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3Java%E4%B8%AD%E7%9A%84final%E4%BF%AE%E9%A5%B0%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[final修饰符 final 可用于修饰类、变量和方法，用于表示它修饰的类、方法和变量不可改变。 final修饰的大都应用于基本类型域，或不可变类。 不可变类：如果类中的每个方法都不会改变其对象，这种类是不可变的类。例如String类。 对于可变类，使用final修饰只是表示存储在对象变量中的对象引用不会再指向其他对象，不过这个对象中的属性可以更改。 final修饰特点 修饰类时，类不能被继承。 修饰变量时，变量就变成了常量，表示该变量一旦获取了初始值就不可被改变，就不能被重新赋值。包括类变量（静态）和实例变量（非静态）。一般与 public static 配合使用。 修饰方法时，方法不能被重写。 final修饰局部变量时： 方法内部或者方法声明上 基本类型：值不能被改变 引用类型：地址引用不能被改变，不会再指向其他对象，但是对象中的属性可以改变。会报 “无法为最终变量x分配值” 的错误 final变量的初始化时机final成员变量 final修饰的成员变量必须显式的进行初始化赋值来指定初始值，否则默认值的是个无效值，会报“可能尚未初始化变量xxx”的错误。 1234567//方式1：直接进行显式得初始化赋值，不进行赋值，会报错Class Demo&#123; final int num ; //没有显式赋值，报错 final int num = 10； //进行显式得初始化赋值 public Demo()&#123; &#125;&#125; 也可以在构造方法执行完毕前对其进行初始化赋值 1234567//方式2：在构造方法执行完毕之前进行赋值初始化Class Demo&#123; final int num; public Demo()&#123; num = 10; //在构造方法执行完毕之前进行赋值初始化 &#125;&#125; 当类初始化时，系统会为类的类变量分配内存并分配默认值；当创建对象时，系统会为该对象的实例变量分配内存，并分配默认值。也就是说，当执行静态初始化块是可以对类变量赋初始化值，当执行普通初始化块、构造器时可对实例变量赋初始化值。即成员变量的初始化值可以在定义该变量时指定默认值，可以在初始化块、构造器中初始化值。 为什么final修饰的成员变量必须显式的进行初始化呢？ 对于final修饰的成员变量而言，一旦有了初始化值，就不能被重新赋值。如果既没有在定义成员变量时指定初始值，也没有在初始化、构造器中为成员变量指定初始值，那么这些成员变量的值就会一直是系统默认值，即系统默认分配的0、’\u0000’、false或null，那么这么成员变量就无任何意义。所以final修饰的成员变量必须由程序员显式的指定初始化值。 归纳一下final修饰的类变量、实例变量能指定初始值的地方： 类变量：必须在静态初始化块中指定初始值或在声明定义该变量时指定初始值，并且只能在这两处的其中之一指定。 实例变量：必须在非静态初始化块中、声明该实例变量时或构造器中指定初始值，并且只能在三个地方之一指定。 final实例变量 不能在静态代码块中指定初始值 因为静态代码块是静态成员，不能访问非静态成员。 final类变量（静态变量）不能放在普通初始化块中指定初始值 因为类变量在类初始化时已经被初始化了，普通初始化块不能再对其重新赋值了。 final成员变量都不能在普通方法中初始化值。 以下代码示例为final成员变量初始化总结： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class FinalVariableTest&#123; // 定义成员变量时指定默认值，合法。 final int a = 6; // 下面变量将在构造器或初始化块中分配初始值 final String str; final int c; final static double d; // 既没有指定默认值，又没有在初始化块、构造器中指定初始值， // 下面定义的ch实例变量是不合法的。 // final char ch; // 初始化块，可对没有指定默认值的实例变量指定初始值 &#123; //在初始化块中为实例变量指定初始值，合法 str = "Hello"; // 定义a实例变量时已经指定了默认值， // 不能为a重新赋值，因此下面赋值语句非法 // a = 9; &#125; // 静态初始化块，可对没有指定默认值的类变量指定初始值 static &#123; // 在静态初始化块中为类变量指定初始值，合法 d = 5.6; &#125; // 构造器，可对既没有指定默认值、有没有在初始化块中 // 指定初始值的实例变量指定初始值 public FinalVariableTest() &#123; // 如果在初始化块中已经对str指定了初始化值， // 构造器中不能对final变量重新赋值，下面赋值语句非法 // str = "java"; c = 5; &#125; public void changeFinal() &#123; // 普通方法不能为final修饰的成员变量赋值 // d = 1.2; // 不能在普通方法中为final成员变量指定初始值 // ch = 'a'; &#125; public static void main(String[] args) &#123; FinalVariableTest ft = new FinalVariableTest(); System.out.println(ft.a); System.out.println(ft.c); System.out.println(ft.d); &#125;&#125; final成员变量在显式初始化之前不能直接访问，但可以通过方法来间接访问，但建议开发者尽量避免在final变量显式初始化之前访问它，此时访问，其值是系统默认值。 123456789101112131415161718192021public class FinalErrorTest&#123; // 定义一个final修饰的实例变量 // 系统不会对final成员变量进行默认初始化 final int age; &#123; System.out.println("初始化块执行"); // age没有初始化，所以此处代码将引起错误。// System.out.println(age); printAge(); //合法，会访问到age变量，值为默认值0 age = 6; System.out.println(age); &#125; public void printAge()&#123; System.out.println(age); &#125; public static void main(String[] args) &#123; new FinalErrorTest(); &#125;&#125; final局部变量 系统不会对局部变量就行初始化，局部变量必须由程序员显式初始化。 如果final局部变量在定义时没有指定初始值，则可以在后面代码中对其赋初值，但只能一次，不能重复赋值。 如果在定义时已经指定初始值，那么在后面代码中不能再对该变量赋值。 final修饰形参，形参在调用该方法时，由系统根据传入的参数来完成初始化，因此使用final修饰的形参不能再被赋值。 123456789101112131415161718192021public class FinalLocalVariableTest&#123; public void test(final int a) &#123; // 不能对final修饰的形参赋值，下面语句非法 // a = 5; &#125; public static void main(String[] args) &#123; // 定义final局部变量时指定默认值，则str变量无法重新赋值 final String str = "hello"; // 下面赋值语句非法 // str = "Java"; // 定义final局部变量时没有指定默认值，则d变量可被赋值一次 final double d; // 第一次赋初始值，成功 d = 5.6; // 对final变量重复赋值，下面语句非法 // d = 3.4; &#125;&#125; 可执行“宏替换”的final变量 对于一个final变量，只要满足三个条件，这个final变量就不再是一个变量，而是相当于一个直接量。 使用final修饰 在定义该final变量时指定了初始值 该初始值可以在编译时就被确定下来 举个示例： 123456public class FinalTest&#123; public static void main(String[] args)&#123; final int a = 5; System.out.println(a); &#125;&#125; 上面示例中，final变量在定义时就指定了初始化值为5。在程序执行过程中，变量a其实根本不存在，当程序执行到 System.out.println(a);时，实际转换为执行 System.out.println(5);。此时这个现象就被称为宏替换。 当定义final变量时就为该变量指定了初始值，而且该初始值可以在编译时就确定下来，那么这个final变量本质上就是一个宏变量，编译器会把程序中所有用到该变量的地方直接替换成该变量的值。 如果被赋的表达式只是基本的算术表达式或字符串连接运算，没有访问普通变量，调用方法，Java编译器同样会将这种final变量当成“宏变量”处理。示例如下： 123456789101112131415public class FinalReplaceTest&#123; public static void main(String[] args) &#123; // 下面定义了4个final“宏变量” final int a = 5 + 2; final double b = 1.2 / 3; final String str = "胡" + "啊呦"; final String book = "Java核心技术：" + 99.0; // 下面的book2变量的值因为调用了方法，所以无法在编译时被确定下来 final String book2 = "Java核心技术：" + String.valueOf(99.0); //① System.out.println(book == "Java核心技术：99.0"); //true System.out.println(book2 == "Java核心技术：99.0"); //false &#125;&#125; 示例中，即使字符串连接运算中包含隐式类型（将数值转换成字符串）转换，编译器依然可以在编译时就确定a，b，str，book这4个变量的值，因此它们都是“宏变量”。 定义book2变量时显式使用方法将数值99.0转换为字符串，但由于该变量的值需要调用String类的方法，因此编译器无法编译时确定book2的值，book2不会被当成宏变量处理。 book是一个宏变量，他将被直接替换成&quot;Java核心技术：99.0&quot;，所以第一个判断为true，相等。book2则不相等。 Java中会使用常量池来管理曾经用过的字符串直接量，例如执行String a = &quot;java&quot;; 语句之后，常量池中就会缓存一个字符串&quot;java&quot;；如果程序再次执行String b = &quot;java&quot;；系统将会让b直接指向常量池中的&quot;java&quot;字符串。因此a==b将返回true。 分析以下代码： 1234567891011121314151617public class StringJoinTest&#123; public static void main(String[] args) &#123; String s1 = "疯狂Java"; // s2变量引用的字符串可以编译时就确定出来， // 因此s2直接引用常量池中已有的"疯狂Java"字符串 String s2 = "疯狂" + "Java"; System.out.println(s1 == s2); // 输出true // 定义2个字符串直接量 String str1 = "疯狂"; //① String str2 = "Java"; //② // 将str1和str2进行连接运算 String s3 = str1 + str2; System.out.println(s1 == s3); // 输出false &#125;&#125; s2在编译时期就能确定值，系统会让s2直接指向常量池中已经缓存的“疯狂Java”字符串。 str1、str2只是两个普通变量，编译器不会执行宏替换，所以在编译时无法确定s3的值，就无法让其指向字符串池中的已有值，所以s1==s3为false；只有它们用final修饰后，才能够宏替换，这样编译器即可在编译阶段就确定s3的值，就让让s3指向常量池中的值，那么就会变成true。 final方法 不希望子类重写父类的某个方法，则可以使用final修饰该方法，如果子类试图重写该方法，就会引发编译错误。 Object类中就有个一个final方法：getClass()，因为Java不希望任何类重写这个方法，所以使用final把这个方法密封起来。 即使使用final修饰一个private访问权限的方法，依然可以在其子类中定义与该方法具有相同方法名、相同形参列表、相同返回值类型的方法。该方法不是重写，只是子类中的方法定义与其恰巧相同。 1234567public class PrivateFinalTest&#123; private final void test()&#123;&#125;&#125;class Sub extends PrivateFinalTest&#123; //该方法不是重写，而是一个新的子类中的方法，只是一样 public void test()&#123;&#125;&#125; final方法仅仅是不能被重写，可以被重载。 123456public class FinalOverload&#123; //final修饰的方法，可以被重载，不能被重写 public final void test()&#123;&#125; public final void test(String str)&#123;&#125; &#125; final类 final修饰的类不可以有子类，不能被继承。final类试图被其他类继承，那么会发生编译错误。 为了安全因素，保证某个类不可被继承，则可以使用final修饰这个类。 不可变类 不可变类的意思是创建该类实例后，该实例的实例变量是不可改变的。 Java中的8个包装类和java.lang.String类都是不可变类，当创建它们的实例后，其实例变量不可改变。 如果需要创建自定义的不可变类，遵循以下规则： 使用private和final修饰符来修饰该类的成员变量 提供带参数构造器，用于根据传入参数来初始化类中的成员变量 仅为该类的成员变量提供getter方法，不要为该类的成员变量提供setter方法，因为普通方法无法修改final修饰的成员变量 如果有必要，重写hashCode()和equals()。 equals()方法根据关键成员变量来作为两个对象是否相等的标准 应保证两个用equals()方法判断为相等的对象的hashCode()也相等 例如String类对象里的字符序列作为相等的标准，其hashCode()方法也是根据字符序列计算得到的。 String类中的equals()方法源码 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; String类中的hashCode()方法的源码： 123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; 可变类的含义是该类的实例变量是可变的。大部分创建的类都是可变类，特别是JavaBean，因为总是为其实例变量提供了setter和getter方法。 与可变类相比，不可变类的实例在整个生命周期中永远处于初始化状态，它的实例变量不可改变。因此对不可变类的实例的控制将更加简单。 如果需要设计一个不可变类，尤其要注意其引用类型的成员变量，如果引用类型的成员变量的类是可变的，就必须采取必要的措施来保护该成员变量所引用的对象不会被修改，这样才能创建真正的不可变类。 缓存不可变类 不可变类的实例状态不可改变，可以很方便的被多个对象共享。如果程序经常使用相同的不可变实例，就应该考虑缓存这种不可变类的实例。毕竟重复创建相同的对象没有意义，而且会加大系统开销。 用数组创建缓存池，用于缓存实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class CacheImmutale&#123; private static int MAX_SIZE = 10; // 使用数组来缓存已有的实例 private static CacheImmutale[] cache = new CacheImmutale[MAX_SIZE]; // 记录缓存实例在缓存中的位置,cache[pos-1]是最新缓存的实例 private static int pos = 0; private final String name; private CacheImmutale(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public static CacheImmutale valueOf(String name) &#123; // 遍历已缓存的对象， for (int i = 0 ; i &lt; MAX_SIZE; i++) &#123; // 如果已有相同实例，直接返回该缓存的实例 if (cache[i] != null &amp;&amp; cache[i].getName().equals(name)) &#123; return cache[i]; &#125; &#125; // 如果缓存池已满 if (pos == MAX_SIZE) &#123; //先进先出 // 把缓存的第一个对象覆盖，即把刚刚生成的对象放在缓存池的最开始位置。 cache[0] = new CacheImmutale(name); // 把pos设为1 pos = 1; &#125; else &#123; // 把新创建的对象缓存起来，pos加1 cache[pos++] = new CacheImmutale(name); &#125; return cache[pos - 1]; &#125; public boolean equals(Object obj) &#123; if(this == obj) &#123; return true; &#125; if (obj != null &amp;&amp; obj.getClass() == CacheImmutale.class) &#123; CacheImmutale ci = (CacheImmutale)obj; return name.equals(ci.getName()); &#125; return false; &#125; public int hashCode() &#123; return name.hashCode(); &#125;&#125;public class CacheImmutaleTest&#123; public static void main(String[] args) &#123; CacheImmutale c1 = CacheImmutale.valueOf("hello"); CacheImmutale c2 = CacheImmutale.valueOf("hello"); // 下面代码将输出true System.out.println(c1 == c2); &#125;&#125; 是否需要隐藏缓存池类的构造器完全取决于系统需求。盲目乱用缓存也可能导致系统性能下降，缓存的对象会占用系统内存，如果某个对象只使用一次，重复使用的概率不大，缓存该实例就弊大于利；反之，如果某个对象需要频繁地重复使用，缓存该实例就利大于弊。 Java中Integer类就采取了上述CacheImmutale类相同的处理策略，如果采用new构造器来创建Integetr对象，则每次返回全新的Integer对象；如果采用valueOf()方法来创建Integer对象，则会缓存该方法创建的对象。 由于new构造器方式创建Integer对象不会启用缓存，因此性能较差，所以Java9中已经将该构造器标记为过时，全面采用valueOf()方法创建。 12345678910111213141516171819public class IntegerCacheTest&#123; public static void main(String[] args) &#123; // 生成新的Integer对象 Integer in1 = new Integer(6); // 生成新的Integer对象，并缓存该对象 Integer in2 = Integer.valueOf(6); // 直接从缓存中取出Ineger对象 Integer in3 = Integer.valueOf(6); System.out.println(in1 == in2); // 输出false System.out.println(in2 == in3); // 输出true // 由于Integer只缓存-128~127之间的值， // 因此200对应的Integer对象没有被缓存。 Integer in4 = Integer.valueOf(200); Integer in5 = Integer.valueOf(200); System.out.println(in4 == in5); //输出false &#125;&#125; 由于Integer只缓存-128~127之间的Integer对象，因此两次通过Integer.valueOf(200)方法生成的Integer对象不是同一个。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的组合关系]]></title>
    <url>%2F2018%2F06%2F09%2FJava%E4%B8%AD%E7%BB%84%E5%90%88%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[组合组合关系概述 实现类的复用除了继承外，还可以使用组合的方式，把该类当成另一个类的组合成分，从而允许新类直接复用该类的public方法。 不管继承还是组合，都允许在新类（对于继承就是子类）中直接复用旧类的方法。 组合是把旧类对象作为新类的成员变量组合起来，用以实现新类的功能，用户看到的是新类的方法，而不能看到被组合对象的方法。因此，通常要在新类里使用private修饰被组合的旧类对象。 组合和继承 从类的复用角度看，父类的功能等同于组合中被组合的类，都将自身的方法提供给新类使用；子类和组合关系里的整体类，都可复用原有类的方法，用于实现自身的功能。 继承关系中从多个子类抽象出共有父类的过程，类似于组合关系中多个整体类里提取被组合类的过程；继承关系中从父类派生子类的过程，则类似于组合关系中被组合类组合到整体类的过程。 使用继承实现： 12345678910111213141516171819202122232425262728293031323334353637383940class Animal&#123; private void beat() &#123; System.out.println("心脏跳动..."); &#125; public void breath() &#123; beat(); System.out.println("吸一口气，吐一口气，呼吸中..."); &#125;&#125;// 继承Animal，直接复用父类的breath()方法class Bird extends Animal&#123; public void fly() &#123; System.out.println("我在天空自在的飞翔..."); &#125;&#125;// 继承Animal，直接复用父类的breath()方法class Wolf extends Animal&#123; public void run() &#123; System.out.println("我在陆地上的快速奔跑..."); &#125;&#125;public class InheritTest&#123; public static void main(String[] args) &#123; Bird b = new Bird(); b.breath(); b.fly(); Wolf w = new Wolf(); w.breath(); w.run(); &#125;&#125; 上述继承关系也可以使用组合实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Animal&#123; private void beat() &#123; System.out.println("心脏跳动..."); &#125; public void breath() &#123; beat(); System.out.println("吸一口气，吐一口气，呼吸中..."); &#125;&#125;class Bird&#123; // 将原来的父类组合到原来的子类，作为子类的一个组合成分 private Animal a; public Bird(Animal a) &#123; this.a = a; &#125; // 重新定义一个自己的breath()方法 public void breath() &#123; // 直接复用Animal提供的breath()方法来实现Bird的breath()方法。 a.breath(); &#125; public void fly() &#123; System.out.println("我在天空自在的飞翔..."); &#125;&#125;class Wolf&#123; // 将原来的父类组合到原来的子类，作为子类的一个组合成分 private Animal a; public Wolf(Animal a) &#123; this.a = a; &#125; // 重新定义一个自己的breath()方法 public void breath() &#123; // 直接复用Animal提供的breath()方法来实现Wolf的breath()方法。 a.breath(); &#125; public void run() &#123; System.out.println("我在陆地上的快速奔跑..."); &#125;&#125;public class CompositeTest&#123; public static void main(String[] args) &#123; // 此时需要显式创建被组合的对象 Animal a1 = new Animal(); Bird b = new Bird(a1); b.breath(); b.fly(); // 此时需要显式创建被组合的对象 Animal a2 = new Animal(); Wolf w = new Wolf(a2); w.breath(); w.run(); &#125;&#125; 何时使用组合或者继承 组合是“有 has-a”关系，继承是“是 is-a”关系。 比如Dog和Animal类应该使用继承关系，因为用一个动物组合成一个狗毫无意义，狗不是由动物组成的，反而狗是动物（is-a关系）； 比如Person类和Head类就应该使用组合关系，因为一个人由头组合（has-a关系），而不是头是人。]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8-Lambda表达式-函数式接口]]></title>
    <url>%2F2018%2F05%2F13%2FJava%E5%86%85%E7%BD%AE%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1. Java内置的四大核心函数式接口12345678Consumer&lt;T&gt; 消费型接口 消费对象 void accept(T t);Supplier&lt;T&gt; 供给型接口 生成对象 T get();Function&lt;R,T&gt; 函数型接口 指定特定功能 R apply(T t);Predicate&lt;T&gt; 断言型接口 进行条件判断 boolean test(T t); 1.1. 消费型接口 void accept(T t);Consumer 消费型接口 12345678910111213// Consumer&lt;T&gt; 消费型接口 @Test public void testConsumer()&#123; //此时的（d） 小括号里有参数 //原因是因为 Consumer接口有参数 //void accept(T t); consume(1000,(d)-&gt; System.out.println(d)); &#125; public void consume(Integer n , Consumer&lt;Integer&gt; con)&#123; //函数接口接收 消费 形参n con.accept(n); &#125; 1.2. 供给型接口 Supplier 供给型接口 T get(); 小括号无参数 1234567891011121314151617181920// Supplier&lt;T&gt; 供给型接口 @Test public void testSupplier()&#123; //T get(); 小括号无参数 List&lt;Integer&gt; numList = getNumList(10,() -&gt; (int)(Math.random()*101)); for ( Integer i: numList ) &#123; System.out.println(i); &#125; &#125; //调用此方法时，第二个参数提供一个数字集合 public List&lt;Integer&gt; getNumList(int n, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; numList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++)&#123; numList.add(sup.get()); //通过get方法得到数字 存到numList &#125; return numList; &#125; 1.3. 函数型接口 Function&lt;R,T&gt; 函数型接口 特定功能 12345678910111213//Function&lt;R,T&gt; 函数型接口 特定功能 @Test public void testFunction()&#123; //将字符串转成大写 String str1 = strHandler("ghslkajh", (s) -&gt; s.toUpperCase()); System.out.println(str1); &#125; // Function&lt;R,T&gt; 函数型接口 //定义一个处理字符串功能型接口函数 public String strHandler(String str, Function&lt;String,String&gt; fun)&#123; return fun.apply(str); &#125; 1.4. 断言型接口 Predicate boolean test(T t); 返回boolean 123456789101112131415161718192021222324//断言型接口 Predicate&lt;T&gt; // boolean test(T t); 返回boolean @Test public void testPredicate()&#123; //返回长度大于3的字符串 List&lt;String&gt; s1 = strFilter(Arrays.asList("huzhiqi", "adaad", "1231", "414441", "gagsgasg"), (s) -&gt; s.length() &gt; 3); System.out.println(s1); //[huzhiqi, adaad, 1231, 414441, gagsgasg] //返回包含d的字符串 List&lt;String&gt; s2 = strFilter(Arrays.asList("huzhiqi", "adaad", "1231", "414441", "gagsgasg"), (s) -&gt; s.contains("d")); System.out.println(s2); // [adaad] &#125; //使用断言型接口过滤字符串 public List&lt;String&gt; strFilter(List&lt;String&gt; strs, Predicate&lt;String&gt; pred)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String s:strs ) &#123; //利用断言型接口进行指定功能判断 即一个功能性条件判断 if(pred.test(s))&#123; //过滤功能 list.add(s); &#125; &#125; return list; &#125;]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Lambda表达式</tag>
        <tag>函数式接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8-方法引用和构造器引用]]></title>
    <url>%2F2018%2F05%2F12%2FJava8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 方法引用 若lambda体中的内容有方法已经实现了，我们可以使用‘方法引用’，可以理解为方法引用是lambda表达式的另外一种表现形式。双冒号形式主要有三种语法格式 使用要求（注意点）： Lambda体中调用方法的参数列表、返回值类型 ，必须要和接口实现方法的参数列表、返回值保持一致 1.1. 对象::实例方法名123456789101112131415//1.1. 对象::实例方法名@Testpublic void test1()&#123; Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x); con.accept("hxh");//hxh Consumer&lt;String&gt; con1 = System.out::println; con1.accept("hxh");//hxh 结果一致 //Consumer&lt;T&gt; 接口中的方法为： void accept(T t); // println()方法实现为： public void println(String x) /** * 此处可以使用方法引用是因为 引用的方法println()的参数列表和返回值的类型 void println(String x) * 与 Consumer&lt;String&gt; 接口实现的方法中的 void accept(String t) 的参数列表和返回值的类型 */&#125; 1.2. 类::静态方法名1234567891011121314@Testpublic void test2()&#123; Supplier&lt;String&gt; sup = () -&gt; new Object().toString(); System.out.println(sup.get()); //java.lang.Object@7d6f77cc Supplier&lt;String&gt; sup1 = new Object()::toString; System.out.println(sup1.get()); // java.lang.Object@6f75e721 Supplier&lt;Double&gt; sup2 = () -&gt; Math.random(); System.out.println(sup2.get()); // 0.3782071825902372 Supplier&lt;Double&gt; sup3 = Math::random; System.out.println(sup3.get()); // 0.1516143754943341&#125; 1.3. 类::实例方法名该类型使用条件： 第一个参数是实例方法的调用者，第二个参数是实例方法的参数 12345678910//类::实例方法名@Testpublic void test3()&#123; //BiPredicate&lt;T,U&gt; 俩参数的断言型接口 BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y); System.out.println(bp.test("hxh","hxh")); //true //(x,y) 括号里俩参数 第一个参数是调用方法对象，第二个参数是方法参数 BiPredicate&lt;String,String&gt; bp1 = String::equals; System.out.println(bp1.test("hxh", "aaj"));//false&#125; 2. 构造器引用 构造器，创建对象，自动匹配类中对应的构造器(参数不定) 需要调用的构造器的参数列表要和函数式接口中的抽象方法参数列表保持一致 语法： ClassName::new; 实体类 Stu1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Stu &#123; private Integer id; private String name; private Integer age; public Stu() &#123; &#125; public Stu(Integer id) &#123; this.id = id; &#125; public Stu(Integer id, Integer age) &#123; this.id = id; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Stu&#123;" + "id=" + id + ", name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 测试用例：123456789101112131415161718192021222324@Testpublic void test4()&#123; //无参构造 Supplier&lt;Stu&gt; stuSupplier = ()-&gt; new Stu(); System.out.println(stuSupplier.get()); //自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（无参构造器） Supplier&lt;Stu&gt; stuSupplier1 = Stu::new; System.out.println(stuSupplier1.get()); //Stu&#123;id=null, name='null', age=null&#125; //有一个参数的构造 Function&lt;Integer,Stu&gt; s1 = (x) -&gt; new Stu(x); System.out.println(s1.apply(1)); //Stu&#123;id=1, name='null', age=null&#125; //自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（单个Integer的构造器） Function&lt;Integer,Stu&gt; s2 = Stu::new; System.out.println(s2.apply(2)); //Stu&#123;id=2, name='null', age=null&#125; //有两个参数的构造 BiFunction&lt;T, U, R&gt; R apply(T t, U u); BiFunction&lt;Integer,Integer,Stu&gt; bf = (x,y) -&gt; new Stu(x,y); System.out.println(bf.apply(3,44)); //Stu&#123;id=3, name='null', age=44&#125; //自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（两个个Integer的构造器） BiFunction&lt;Integer,Integer,Stu&gt; bf1 = Stu::new; System.out.println(bf1.apply(4,55));//Stu&#123;id=4, name='null', age=55&#125;&#125; 3. 数组引用 语法： Type[]::new; 123456789//数组引用 Type[]::new@Testpublic void test5()&#123; //创建指定长度的字符串数组 Function&lt;Integer,String[]&gt; f1 = (x) -&gt; new String[x]; System.out.println(f1.apply(10).length); //10 Function&lt;Integer,String[]&gt; f2 = String[]::new;//数组引用 可以直接代替 System.out.println(f2.apply(20).length); //20&#125;]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>方法引用</tag>
        <tag>构造器引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8-StreamAPI常用知识]]></title>
    <url>%2F2018%2F05%2F11%2FJava8-StreamAPI%2F</url>
    <content type="text"><![CDATA[流（Stream）1. 流的概念 流是数据渠道，用于操作数据源，所生成一种新的元素序列。集合讲的是数据，流讲的是计算,是操作。 Stream是Java8中处理集合的关键抽象概念，它可以指定希望对集合的操作，可以执行复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合的数据进行操作，类似于SQL执行的数据库查询，也可以用来并行执行操作，其提供了一种高效且易于使用的处理数据方式。 注意点： Stream自身不会存储元素 Stream不会改变数据源对象，相反会返回产生一个持有结果的新Stream Steam操作是延迟执行的，这意味着他们会等到需要结果的时候才执行。 2. 流的操作步骤三步走 2.1. 创建Stream获取一个数据源（集合，数组），从而获取一个流产生方式： 2.1.1 通过Collection 系列集合提供的串行流：stream()、并行流： paralleStream()12List&lt;String&gt; list = new ArrayList&lt;&gt;();Stream&lt;String&gt; stream1 = list.stream(); 2.1.2 通过Arrays中的静态方法stream(T[] array) 获取数组流Arrays.stream(T[] array)的源码: 123public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) &#123; return stream(array, 0, array.length); &#125; 用例： 1234567Stu[] stus = new Stu[10];Stream&lt;Stu&gt; stream2 = Arrays.stream(stus);/* public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) &#123; return stream(array, 0, array.length); &#125; */ 2.1.3 通过Stream类中的静态方法 of()Stream.of() 源码： 12345678910//1.单参泛型of public static&lt;T&gt; Stream&lt;T&gt; of(T t) &#123; return StreamSupport.stream(new Streams.StreamBuilderImpl&lt;&gt;(t), false);&#125;//2.可变参数@SafeVarargs@SuppressWarnings("varargs") // Creating a stream from an array is safepublic static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123; return Arrays.stream(values);&#125; 用例：1Stream&lt;String&gt; stream3 = Stream.of("hxh", "aj", "hhh"); 2.1.4 使用Stream类的静态方法 iterate 创建无限流iterate方法： Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) 参数 seed 种子起始值，UnaryOperator 函数式接口 继承Function&lt;T,T&gt; 此时参数类型符合返回值类型一致 用例：12345678910111213//4.使用Stream类的静态方法 iterate 创建无限流//Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) //参数 seed 种子起始值，// UnaryOperator 函数式接口 继承Function&lt;T,T&gt; 此时参数类型符合返回值类型一致Stream&lt;Integer&gt; stream4 = Stream.iterate(0, (x) -&gt; x + 2);//中间操作和终止操作stream4.limit(5).forEach(System.out::println);//0//2//4//6//8 2.1.5 使用Stream类的静态方法 generate创建无限流generate方法参数为Supplier&lt;T&gt; 供给型接口 123456789//5.使用Stream类的静态方法 generate 创建无限流//参数为Supplier&lt;T&gt; 供给型接口Stream&lt;Double&gt; generateStream = Stream.generate(() -&gt; Math.random());generateStream.limit(5).forEach(System.out::println);//0.4762976596937549//0.08577913333772513//0.32149010682857515//0.31059489250233197//0.45181354173159927 2.2. 用Stream中间操作一个中间操作链，用Stream API 对数据源数据进行操作处理 注意点： 若只有中间操作，则不会执行 只有终止操作执行后，所有的中间操作一次执行，此时就称为延迟加载或者惰性求值 验证是否是延迟加载： 1234567891011@Testpublic void test2()&#123; //取age&gt;30的Stu元素 //若只有中间操作，则不会执行 Stream&lt;Stu&gt; stuStream = stuList.stream().filter((i) -&gt; &#123; System.out.println(&quot;验证是否是延迟加载&quot;); return i.getAge() &gt; 40; &#125;); //此时只有中间操作，无终止操作，无结果，控制台无输出 &#125; 此时只有中间操作，无终止操作，无结果，控制台无输出。 此时加上终止操作后： 1234567891011@Testpublic void test2()&#123; //取age&gt;30的Stu元素 //若只有中间操作，则不会执行 Stream&lt;Stu&gt; stuStream = stuList.stream().filter((i) -&gt; &#123; System.out.println("验证是否是延迟加载"); return i.getAge() &gt; 40; &#125;); //终止操作 执行后，所有的中间操作一次执行，此时就称为延迟加载或者惰性求值 stuStream.forEach(System.out::println);&#125; 此时结果为： 1234567验证是否是延迟加载验证是否是延迟加载验证是否是延迟加载验证是否是延迟加载Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;验证是否是延迟加载Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125; 结论：若只有中间操作，则不会执行中间操作。终止操作 执行后，所有的中间操作一次执行。最后流中只有经过操作过滤后的元素。 2.2.1 筛选与切片迭代： 内部迭代：迭代过程操作由Stream API 内部自主完成，无需自行再次编写。 外部迭代：由程序编写人员自己通过一些迭代方法进行的迭代操作。 2.2.1.1 filter-过滤Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)断言型接口参数 即条件判断过滤 用例：先创建一个Stu类List集合1234567List&lt;Stu&gt; stuList = Arrays.asList( new Stu(1,"hh",22), new Stu(2,"aa",22), new Stu(3,"bb",32), new Stu(4,"cc",42), new Stu(5,"dd",52)); filter过滤实现：123456//取age&gt;30的Stu元素//若只有中间操作，则不会执行Stream&lt;Stu&gt; stuStream = stuList.stream() .filter((i) -&gt; i.getAge() &gt; 40);//终止操作 执行后，所有的中间操作一次执行，此时就称为延迟加载或者惰性求值stuStream.forEach(System.out::println); 结果：12Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125; 2.2.1.2 limit-限定元素数量limit(n) 通过截断流，使流中元素个数不超过指定数量 12345stuList.stream() .filter((s) -&gt;&#123; System.out.println("测试迭代几次"); return s.getAge()&gt;40; &#125;).limit(1).forEach(System.out::println); 结果： 12345测试迭代几次测试迭代几次测试迭代几次测试迭代几次Stu&#123;id=4, name='cc', age=42&#125; 结果发现：先通过filter()过滤，迭代到想要的过滤结果后，再根据limit(n)，直接截断流，后续操作不继续，限制其流中元素个数为n，此操作称为短路操作，短路操作也用于提高效率； 所以前3次元素不在结果中，但都进行迭代判断，打印了3次后后面的元素再次进行迭代，发现元素满足过滤条件，但limit限制只要一个，即最后一次迭代后直接截断流，结果为第一个满足过滤条件的元素。 2.2.1.3 skip-跳过元素skip(n) 返回一个跳过前n个元素的流，若流中元素不足n个，则返回一个空流。其与limit(n)互补 12345678910//skip(n) 跳过前n个元素stuList.stream() .skip(2).forEach(System.out::println);/* 结果： Stu&#123;id=3, name='bb', age=32&#125; Stu&#123;id=4, name='cc', age=42&#125; Stu&#123;id=5, name='dd', age=52&#125; */stuList.stream().skip(6).forEach(System.out::println);//流中元素个数总数为5，小于6，则返回空流，没有结果值 2.2.1.4 distinct-去重 通过流所生成元素的hashCode()和equals()来去除重复元素 先在stuList中添加几个重复元素用于测试：12345678910List&lt;Stu&gt; stuList = Arrays.asList( new Stu(1,"hh",22), new Stu(2,"aa",22), new Stu(3,"bb",32), new Stu(4,"cc",42), new Stu(4,"cc",42), new Stu(4,"cc",42), new Stu(4,"cc",42), new Stu(5,"dd",52)); 此时的Stu类中没有生成重写hashCode()和equals()方法，测试:12//distinct 去重stuList.stream().distinct().forEach(System.out::println); 但是结果发现，并没有去重:12345678Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125; 此时，在Stu类中生成重写hashCode()和equals()方法： 123456789101112131415@Overridepublic boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Stu stu = (Stu) o; return Objects.equals(id, stu.id) &amp;&amp; Objects.equals(name, stu.name) &amp;&amp; Objects.equals(age, stu.age);&#125;@Overridepublic int hashCode() &#123; return Objects.hash(id, name, age);&#125; 再次测试用例后，发现结果已经去重：12345Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125; 结论： distinct()去重原理为通过流所生成元素的hashCode()和equals()来去除重复元素 2.2.2 映射2.2.2.1 map映射&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) 接收Lambda，将元素转换成其他形式或提取信息。 接收一个Function&lt;? super T, ? extends R&gt; mapper函数作为参数，该函数会被应用到每个元素上，并将其映射到一个新的元素。 123456//map映射List&lt;String&gt; stringList = Arrays.asList("aa", "bb", "cc", "dd");stringList.stream() .map((x)-&gt;x.length()).forEach(System.out::println);stringList.stream() .map((x)-&gt;x.toUpperCase()).forEach(System.out::println); 结果:123456782222AABBCCDD 从结果看出，流中的每个元素都应用了map()里的参数中的Function函数，并返回经过Function处理的元素。 map映射的重要应用为：即类似SQL中的映射，获取对象中的某些属性（即数据库中的某些字段） 例如：获取Stu中的name属性1stuList.stream().map(Stu::getName).forEach(System.out::println); 测试结果：12345678hhaabbccccccccdd 2.2.2.2 flatMap映射 接收一个函数作为参数，将流中的每个值都转换成另一个流，然后把所有流连接成一个流。每个部分流中的每个值成单独小流，再串成一个整体流。 对比map映射： map映射是将集合中的部分流添加到整体流中，而flatMap映射是将集合中的部分流中的每个元素单独一个个地添加到整体流中。 map映射: Stream&lt;Stream&lt;Character&gt;&gt; , flatMap映射：Stream&lt;Character&gt; 测试用例： 写一个函数用于flatMap映射 12345678910111213/** * 字符串拆分成字符后组成一个字符类型的流 * @param str * @return */public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; characterList = new ArrayList&lt;&gt;(); for (Character ch: str.toCharArray() ) &#123; characterList.add(ch); &#125; return characterList.stream();&#125; 用该函数分别测试map映射类型和flatMap映射类型 12345678910111213141516171819202122232425262728List&lt;String&gt; stringList = Arrays.asList("aa", "bb", "cc", "dd");Stream&lt;Stream&lt;Character&gt;&gt; st1 = stringList.stream() .map(TestStream::filterCharacter);//此时流的内容为 &#123;&#123;"aa"&#125;,&#123;"bb"&#125;,&#123;"cc"&#125;,&#123;"dd"&#125;&#125; 4个单独的字符流对象组成的流st1.forEach(System.out::println);/* 再次遍历后 结果：4个流对象 即 Stream&lt;Character&gt; &#123;&#123;"aa"&#125;,&#123;"bb"&#125;,&#123;"cc"&#125;,&#123;"dd"&#125;&#125; java.util.stream.ReferencePipeline$Head@470e2030 java.util.stream.ReferencePipeline$Head@3fb4f649 java.util.stream.ReferencePipeline$Head@33833882 java.util.stream.ReferencePipeline$Head@200a570f */System.out.println("----------------");Stream&lt;Character&gt; st2 = stringList.stream().flatMap(TestStream::filterCharacter);//此时流的内容为&#123;"a","a","b","b","c","c","d","d"&#125;st2.forEach(System.out::println);/* 再次遍历后 结果直接返回了单个的字符流 a a b b c c d d */ 2.2.3 排序2.2.3.1 自然排序sorted() 自然排序(Comparable方式)，按照字典顺序进行排序 按照实现的Comparable中的compare to()方法 1234List&lt;String&gt; stringList = Arrays.asList("ee", "bb", "ff", "dd","哈哈","啊");//根据String类中Comparable方式进行默认排序，即compare to()方法stringList.stream() .sorted().forEach(System.out::println); 结果：123456bbddeeff哈哈啊 2.2.3.2 指定排序sorted(Comparator com) 根据实现Comparator接口的指定方法进行排序 123456789stuList.stream().sorted( (a,b) -&gt;&#123; if (a.getAge().equals(b.getAge()))&#123; return a.getName().compareTo(b.getName()); &#125;else&#123; return a.getAge().compareTo(b.getAge()); &#125; &#125; ).forEach(System.out::println); 2.3. 终止Stream操作终止操作，执行中间链操作，并产生结果 2.3.1. 查找与匹配 匹配 match 利用断言型函数接口，返回boolean值 是否匹配 查找返回容器类 Optional类型 避免空指针异常 2.3.1.1 allMatch-检查是否匹配所有元素返回结果： true 匹配到了所有的元素 注意：和noneMatch()的false 结果代表集合不同 false 没有匹配到所有的元素 说明匹配到条件集合中的真子集 1234567891011boolean b = stuList.stream() .allMatch((e) -&gt; e.getAge() &gt; 20);System.out.println(b);//trueboolean b1 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 20);System.out.println(b1);//flaseboolean b2 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 40);System.out.println(b2);//flase 2.3.1.2 anyMatch-检查是否至少匹配一个元素返回结果： true 匹配到了条件集合中的真子集元素，一个或者多个 false 一个元素都没有匹配到，空集1234567boolean hhh = stuList.stream() .anyMatch((e) -&gt; e.getName().equals("hhh"));System.out.println(hhh);//falseboolean hh = stuList.stream() .anyMatch((e) -&gt; e.getName().equals("hh"));System.out.println(hhh);//true 2.3.1.3 noneMatch-检查是否所有元素都没有匹配到返回结果： true 所有元素都没有匹配到，空集 false 不是所有的元素都没有匹配到 即匹配到了元素,有匹配到的元素即返回false，真子集123456789101112131415boolean b1 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 20);System.out.println(b1);//flaseboolean b2 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 40);System.out.println(b2);//flaseboolean b3 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 50);System.out.println(b3);//此时集合中只有一个元素能匹配到，返回了falseboolean b4 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 60);System.out.println(b3);//所有的元素都没有匹配到 返回了true 2.3.1.4 findFirst-返回第一个元素Optional&lt;T&gt; findFirst(); 12Optional&lt;Stu&gt; first = stuList.stream().findFirst();System.out.println(first.get());// Stu&#123;id=1, name='hh', age=22&#125; 返回第一个元素，用Optional集合类来封装，避免了空指针异常 2.3.1.5 findAny-返回当前流中的任意一个元素Optional&lt;T&gt; findAny(); 1234567//从集合中随便找个age&gt;30的Stu对象 可以使用串行流stream,也可以使用parallelStream 并行流Optional&lt;Stu&gt; any = stuList.parallelStream() .filter((e) -&gt; e.getAge() &gt; 30).findAny();System.out.println(any.get());//Stu&#123;id=4, name='cc', age=42&#125;Optional&lt;Stu&gt; any1 = stuList.stream() .filter((e) -&gt; e.getAge() &gt; 30).findAny();System.out.println(any1.get());//Stu&#123;id=3, name='bb', age=32&#125; 2.3.1.6 count-返回流中元素总个数long count(); 12long count = stuList.stream().count();System.out.println(count);//8 2.3.1.7 max-返回流中的最大值Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator); 123456789//根据年龄大小进行正序排序找出最大值Optional&lt;Stu&gt; max = stuList.parallelStream() .max((a, b) -&gt; Integer.compare(a.getAge(), b.getAge()));System.out.println(max.get()); //Stu&#123;id=5, name='dd', age=52&#125;//根据年龄大小进行倒序排序找出最大值Optional&lt;Stu&gt; max1 = stuList.parallelStream() .max((a, b) -&gt; Integer.compare(b.getAge(), a.getAge()));System.out.println(max1.get()); //Stu&#123;id=1, name='hh', age=22&#125; 12345//提取最大年龄 先映射提取集合中每个对象的年龄 再直接进行max方法比较 最后返回一个年龄值Optional&lt;Integer&gt; maxAge = stuList.parallelStream() .map(Stu::getAge) .max(Integer::compare);System.out.println(maxAge.get()); //52 2.3.1.8 min-返回流中的最小值Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator); 123456789//根据年龄大小进行正序排序找出最小值Optional&lt;Stu&gt; min = stuList.parallelStream() .min((a, b) -&gt; Integer.compare(a.getAge(), b.getAge()));System.out.println(min.get());//Stu&#123;id=1, name='hh', age=22&#125;//根据年龄大小进行倒序排序找出最小值Optional&lt;Stu&gt; min1 = stuList.parallelStream() .min((a, b) -&gt; Integer.compare(b.getAge(), a.getAge()));System.out.println(min1.get()); //Stu&#123;id=5, name='dd', age=52&#125; 2.3.2. 归约与收集2.3.2.1 reduce-将流中元素反复结合起来，得到一个值12345List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);//利用reduce归约函数，可以指定归约规则，将集合中的元素数值进行求和操作等//以0为起始值，对集合中的各个值进行相加Integer sum = list.stream().reduce(0, (x, y) -&gt; x + y);System.out.println(sum);//45 12345678//求出stuList集合中的年龄总和//此时利用Integer类中的静态方法sum求和 无起始值，有可能为空，// 则返回值自动变为Optional容器类封装过后的值Optional&lt;Integer&gt; ageSumOp = stuList.stream() .map(Stu::getAge) .reduce(Integer::sum);System.out.println(ageSumOp.get());//296 此时利用Integer类中的静态方法sum求和 无起始值,有可能为空，则返回值自动变为Optional容器类封装过后的值 2.3.2.2 collect-将流转换为其他形式 接收一个Collector接口的实现，用于Stream中元素做汇总的方法 利用Collectors实用工具类中提供的很多静态实现Collector接口的方法，进行相应的转换收集操作。 1234567891011121314151617181920212223242526//收集stuList集合中的所有name值，转换为list集合List&lt;String&gt; nameList = stuList.stream().map(Stu::getName) .collect(Collectors.toList());nameList.forEach(System.out::println);/* 结果： hh aa bb cc cc cc cc dd *///获取年龄转化成set集合 去掉了重复值Set&lt;Integer&gt; ageSet = stuList.stream().map(Stu::getAge) .collect(Collectors.toSet());ageSet.forEach(System.out::println);/* 结果： 32 52 22 42 */ 如果想转换成其他没有的现成静态方法的数据结构集合，就使用Collectors.toCollection()方法，该方法具体参数和返回值为：Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) 使用Collectors.toCollection(HashSet::new)方法 转换成HashSet集合,该方法参数为Supplier供给型函数接口，传给一个构造函数， 用例如下： 123456789101112//使用`Collectors.toCollection()`方法 转换成`其他没有的现成静态方法`的数据结构集合 比如HashSetHashSet&lt;String&gt; nameHashSet = stuList.stream().map(Stu::getName) .collect(Collectors.toCollection(HashSet::new));nameHashSet.forEach(System.out::println);/* result: hh aa bb cc dd */ 2.3.3. Collectors类中的常用方法2.3.3.1 counting-统计数量Long count() 统计元素个数123Long count = stuList.stream() .collect(Collectors.counting());System.out.println(count);//8 2.3.3.2 averagingDouble-求平均值并转换成Double类型&lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper) &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper) &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper) 测试用例：求年龄的平均值123Double ageAve = stuList.stream() .collect(Collectors.averagingDouble(Stu::getAge));System.out.println(ageAve);//37.0 2.3.3.3 summingDouble-求和并转换成Double类型&lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper) &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper) &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper) 测试用例：求年龄之和123Double ageSum = stuList.stream() .collect(Collectors.summingDouble(Stu::getAge));System.out.println(ageSum);//296.0 2.3.3.4 maxBy-根据函数条件求最大值&lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator) 测试用例：根据年龄找出最大年龄值的stu对象1234//根据年龄找出最大年龄值的stu对象Optional&lt;Stu&gt; stuOptional = stuList.stream() .collect(Collectors.maxBy((a, b) -&gt; Double.compare(a.getAge(), b.getAge())));System.out.println(stuOptional.get());//Stu&#123;id=5, name='dd', age=52&#125; 2.3.3.5 groupingBy-分组 单级分组 &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier) 测试用例：根据年龄分组1234//根据年龄分组Map&lt;Integer, List&lt;Stu&gt;&gt; ageGroup = stuList.stream() .collect(Collectors.groupingBy(Stu::getAge));System.out.println(ageGroup); 结果：1234&#123;32=[Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;],52=[Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125;],22=[Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;, Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;],42=[Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;]&#125; 多级分组 两个参数，第二个参数为Collector，即实现无限分组&lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream) 先根据name分组，再根据年龄分组123456789101112//先根据name分组，再根据年龄分组Map&lt;String, Map&lt;String, List&lt;Stu&gt;&gt;&gt; groupmap = stuList.stream() .collect(Collectors.groupingBy(Stu::getName, Collectors.groupingBy((e) -&gt; &#123; if (e.getAge() &lt;= 20) &#123; return "年轻人"; &#125; else if (e.getAge() &lt;= 50) &#123; return "中年人"; &#125; else &#123; return "老年人"; &#125; &#125;)));System.out.println(groupmap); 结果：12345&#123;dd=&#123;老年人=[Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125;]&#125;, cc=&#123;中年人=[Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;]&#125;, bb=&#123;中年人=[Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;]&#125;, aa=&#123;中年人=[Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;]&#125;, hh=&#123;中年人=[Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;]&#125;&#125; 2.3.3.6 partitioningBy-分区满足条件的分到一个区，不满足条件分到另一个区 true , false Map&lt;Boolean,List&lt;&gt;&gt; 测试用例：是否年龄大于40，分两个区123Map&lt;Boolean, List&lt;Stu&gt;&gt; booleamGroup = stuList.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getAge() &gt; 40));System.out.println(booleamGroup); 结果：1234567891011121314&#123; false=[ Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;, Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;, Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125; ], true=[ Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125; ]&#125; 2.3.3.7 summarizingDouble-计算方法总括函数&lt;T&gt; Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper) summarizingDouble返回 DoubleSummaryStatistics 类型 可以直接调用各种计算方法 summarizingInt summarizingLong 实例：1234567DoubleSummaryStatistics ageSummaryStatis = stuList.stream() .collect(Collectors.summarizingDouble(Stu::getAge));ageSummaryStatis.getAverage();ageSummaryStatis.getCount();ageSummaryStatis.getMax();ageSummaryStatis.getMin();ageSummaryStatis.getSum(); 2.3.3.7 joining-连接字符串Collector&lt;CharSequence, ?, String&gt; joining() 测试用例：将stuList集合中所有的名字连接在一起1234//将集合中所有的名字连接在一起String allNameStr = stuList.stream().map(Stu::getName) .collect(Collectors.joining());System.out.println(allNameStr);//hhaabbccccccccdd 测试用例：将stuList集合中所有的名字连接在一起，并使用逗号分割 12345 //将集合中所有的名字连接在一起,并逗号分割String allNameStr1 = stuList.stream().map(Stu::getName) .collect(Collectors.joining(","));System.out.println(allNameStr1);//hh,aa,bb,cc,cc,cc,cc,dd 2.3.3.8 toList- 返回集合1List kcResList = kcResInKkxyList.stream().filter((e) -&gt; kssj.equals(e.getKssj())).collect(Collectors.toList());]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>StreamAPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8-Lambda表达式基础知识]]></title>
    <url>%2F2018%2F05%2F11%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Lambda表达式 Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递），其可以代替实现接口中的抽象方法时的书写匿名内部类的繁琐代码。 举个栗子： Java中有个Runnable接口，直接使用该接口，需要重写实现其接口内部中的抽象方法。如下： 1234567Runnable run = new Runnable() &#123; @Override public void run() &#123; System.out.println("old run"); &#125;&#125;;run.run(); 该代码可以使用lambda表达式简化为：12Runnable run1 = () -&gt; System.out.println("lambda run");run1.run(); 1. 基础语法 java8中引入了一个新的操作符”-&gt;”，该操作符称为箭头操作符或Lambda操作符，该箭头符号将整个Lambda表达式拆分成两部分： 左侧：Lambda表达式的参数列表，即接口中对应抽象方法的参数列表。 右侧：Lambda表达式中所需要执行的功能，即Lambda表达式体。即需要实现的抽象方法的功能体。 1.1. 语法格式一 无参数,无返回值 对应格式为: () -&gt; 方法体… 括号内无参数 例如:() -&gt; Sysout… 12345678910111213141516171819@Testpublic void test1 ()&#123; //无参数 , 无返回值 对应格式为: () -&gt; 方法体... 括号内无参数 Runnable run = new Runnable() &#123; @Override public void run() &#123; System.out.println("old run"); &#125; &#125;; run.run(); System.out.println("-----------"); Runnable run1 = () -&gt; System.out.println("lambda run"); run1.run();&#125;/*result: old run ----------- lambda run*/ 1.2. 语法格式二 有一个参数,无返回值 对应语法格式为 (x) -&gt; 无返回值的方法体 例如: (x) -&gt; System.out.println(x) 若有且只有一个参数,左侧的小括号可以省略不写 例如: x -&gt; System.out.println(x) 12345678910111213141516// 有一个参数 , 无返回值@Testpublic void test2()&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Consumer&lt;String&gt; consumer = (s) -&gt; list.add(s);//将consumer接收到的对象进行具体的功能的消费 consumer.accept("ddd"); consumer.accept("aaa"); consumer.accept("ccc"); list.forEach(System.out::println); /* Result: ddd aaa ccc */&#125; 1.3. 语法格式三 有两个或两个以上参数,有返回值 有两个或两个以上参数,有返回值,并且 lambda 体中有多条语句 12345678910111213语法为: (x,y) -&gt; &#123; 方法体 return 返回值&#125;多条语句必须使用大括号包括在内,有返回值,需要使用return 返回返回值. Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123; System.out.println(&quot;x为&quot;+x); System.out.println(&quot;y为&quot;+y); return Integer.compare(x,y); &#125;; 123456789101112如果lambda体中只有一条语句,那么大括号&#123;&#125;可以省略,return关键字也可以省略例如: Comparator&lt;Integer&gt; com = (x,y) -&gt; &#123; return Integer.compare(x,y);&#125;就可以简写成:Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y); 12345678 Lambda表达式的参数列表的 数据类型可以省略不写,因为JVM编译器可以通过上下文推断出数据类型,即&apos;类型推断&apos;.即: (Integer x,Integer y) -&gt; Integer.compare(x,y);简化成:(x,y) -&gt; Integer.compare(x,y); 123456789101112@Testpublic void test3()&#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123; System.out.println("x为"+x); System.out.println("y为"+y); return Integer.compare(x,y); &#125;; System.out.println(com.compare(1111,111)); // x为1111 // y为111 // 1&#125; 利用用Java内置的Comparator接口（比较器）比较两个字符串的长度，可用lambda表达式表示为： 使用Lambda表达式直接进行该接口的核心方法体的重写 1234567891011121314//使用Lambda表达式直接进行该接口的核心方法体的重写Comparator&lt;String&gt; com1 = (x,y) -&gt; &#123; if(x.length() == y.length())&#123; return 0; &#125;else&#123; if(x.length() &gt; y.length())&#123; return 1; &#125;else return -1; &#125;&#125;;System.out.println(com1.compare("aa","aaaaa"));// -1 2. 函数式接口 Lambda表达式需要函数式接口的支持 函数式接口定义: 接口中只有一个抽象方法的接口,称为函数式接口。 可以使用注解 @FuncitonalInterface 修饰，其修饰作用为：限定该接口必须为函数式接口,即该接口中有且只有一个抽象方法。否则无法通过编译。即可以检查是否为函数式接口。 2.1. 自定义一个函数式接口：1234@FunctionalInterfacepublic interface Operation&lt;T,R&gt; &#123; public R operation(T t1, T t2);&#125; 2.1.1 方案一：写具体实现方法再直接使用12345678public void op (Long l1, Long l2, Operation&lt;Long,Long&gt; operation)&#123; System.out.println(operation.operation(l1,l2)); &#125;@Testpublic void testMyOperation()&#123; op(10l,10l,(x,y) -&gt; x*y);//100 op(100l,200l,(x,y)-&gt; x+y);//300&#125; 2.1.2 方案二： 先使用lambda表示具体实现方法体，再进行接口中的方法调用，传入具体值：12345@Testpublic void testMyOperation()&#123; Operation&lt;Integer,Integer&gt; op = (x,y) -&gt; x*y; System.out.println(op.operation(10,10)); //100&#125; 实际使用时，大多数情况下直接使用Java8内置四大函数式接口，并不要进行自己写函数式接口。]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础知识]]></title>
    <url>%2F2018%2F04%2F03%2FGit%2F</url>
    <content type="text"><![CDATA[一、Git1. Git的常用操作1.1 本地库初始化 进入自己创建的git仓库目录下，使用命令git init 123hxhaaj@DESKTOP-CP80SC0 MINGW64 /d/code/GitSpace/testGit (master)$ git initInitialized empty Git repository in D:/code/GitSpace/testGit/.git/ 此时就会提示在该目录下初始化了一个空的Git仓库 Initialized empty Git repository in D:/code/GitSpace/testGit/.git/ 使用命令ll -la 显示所有含有隐藏目录.git 查看.git/目录下的目录结构： 123456789$ lltotal 7-rw-r--r-- 1 hxhaaj 197121 130 6月 22 17:12 config-rw-r--r-- 1 hxhaaj 197121 73 6月 22 17:12 description-rw-r--r-- 1 hxhaaj 197121 23 6月 22 17:12 HEADdrwxr-xr-x 1 hxhaaj 197121 0 6月 22 17:12 hooks/drwxr-xr-x 1 hxhaaj 197121 0 6月 22 17:12 info/drwxr-xr-x 1 hxhaaj 197121 0 6月 22 17:12 objects/drwxr-xr-x 1 hxhaaj 197121 0 6月 22 17:12 refs/ 1.2 设置签名1.2.1 项目级/仓库级别签名 仅仅在当前本地库范围内有效 命令：git config user.name xxx 设置项目级用户名称 命令：git config user.email xxx 设置项目级用户email 信息保存在 .git/config文件中 1.2.2 系统用户级签名 登录当前操作系统的用户范围 命令：git config --global user.name xxx 设置系统用户级用户名称 命令：git config --global user.email xxx 设置系统用户级用户email 签名信息保存在 系统用户目录下的 ~/.gitconfig文件中 1234$ cat .gitconfig[user] name = hxhaaj_glb email = hxhaaj_glb@163.com 1.2.3 级别优先级 项目级别优先于系统用户级别，二者都有时采用项目级别的签名 如果只有系统用户级别的签名，就以系统用户级别的签名为准 二者都没有不允许这种情况 1.3 基本操作 1.3.1 状态查看操作命令： git status 查看工作区、暂存区状态1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) t1.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 1.3.2 添加操作git add [file name]将工作区的新建或者修改后的文件添加到暂存区1$ git add t1.txt 执行后，查看状态：123456789$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: t1.txt 1.3.3 暂存区删除操作git rm --cache [filename]将暂存区中的文件，移除暂存区，避免误添加操作12$ git rm --cached t1.txtrm &apos;t1.txt&apos; 删除后，回到原状态：查看状态：1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) t1.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 1.3.4 提交操作命令： git commit 将暂存区的内容提交到本地库 提交并直接写入本次提交提示信息 git commit -m &quot;xxx提交提示信息&quot; [文件名] 12345$ git commit -m &quot;new file t1 and insert some ..&quot; t1.txtwarning: LF will be replaced by CRLF in t1.txt.The file will have its original line endings in your working directory.[master b4b7b3e] new file t1 and insert some .. 1 file changed, 3 insertions(+) 1.3.5 查看日志git log 最完整的形式123456789101112$ git logcommit b4b7b3ecb73218f06a882363ea8982e78aea59b6 (HEAD -&gt; master)Author: hxhaaj &lt;hxhaaj@163.com&gt;Date: Fri Jun 22 22:33:57 2018 +0800 new file t1 and insert some ..commit 55afec262bc7db58f8307f788dc57f3118e0d3d1Author: hxhaaj &lt;hxhaaj@163.com&gt;Date: Fri Jun 22 22:28:49 2018 +0800 new t1` git log --pretty=oneline 以一条信息一行的简洁状态显示日志123$ git log --pretty=onelineb4b7b3ecb73218f06a882363ea8982e78aea59b6 (HEAD -&gt; master) new file t1 and insert some ..55afec262bc7db58f8307f788dc57f3118e0d3d1 new t1` git log --oneline 哈希值简短显示的简洁状态 更简洁 只显示过去版本123$ git log --onelineb4b7b3e (HEAD -&gt; master) new file t1 and insert some ..55afec2 new t1` git reflog 增加了头指针移动次数信息 HEAD@{x} x为移动到当前版本需要的次数 常用，新老版本都能全部显示123$ git reflogb4b7b3e (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: new file t1 and insert some ..55afec2 HEAD@&#123;1&#125;: commit (initial): new t1` 多屏显示控制方式： 空格向下翻页 b向上翻页 q退出 1.3.6 前进后退 本质：根据最新版本为HEAD指针，即HEAD指针到旧版本所需要移动的次数,如下HEAD@{0}为最新版本 12b4b7b3e (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: new file t1 and insert some ..55afec2 HEAD@&#123;1&#125;: commit (initial): new t1` 基于索引值操作（推荐）git reset --hard [局部索引值(55afec2)]回到或者前进到索引值代表的那个版本 12$ git reset --hard 55afec2HEAD is now at 55afec2 new t1` 此时回到了55afec2这个版本，再使用 git reflog 查看日志1234$ git reflog55afec2 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 55afec2b4b7b3e HEAD@&#123;1&#125;: commit: new file t1 and insert some ..55afec2 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): new t1` 使用 ^ 符号形式 只能后退git reset --hard HEAD[^]一个^符号，退一个版本，n个^符号，退n个版本 12$ git reset --hard HEAD^HEAD is now at 55afec2 new t1` 使用 ~ 符号形式git reset --hard HEAD~n n代表后退多少步，同样也只能后退 1.3.7 reset命令的三个参数对比 --soft 参数仅仅在本地库移动HEAD指针 --mixed 参数在本地库移动HEAD指针，重置暂存区 --hard 参数在本地库移动HEAD指针，重置暂存区，重置工作区 1.3.7 删除文件并找回 前提：删除前，文件存在时的状态提交到了本地库。 命令：git reset --hard [指针位置]删除操作已经提交到本地库：指针位置指向历史记录删除操作没有提交到本地库：指针位置使用HEAD 1.3.8 比较文件差异 git diff [文件名]不带参数，将工作区中的文件和暂存区进行比较 git diff[本地库中历史版本] [文件名]将工作区中的文件和本地库历史记录进行比较git diff HEAD t1.txtgit diff HEAD^ t1.txt 不指定文件名，比较多个文件 1.4 分支1.4.1 分支的好处 同时并行推进多个功能开发，提高开发效率 各个分支在开发过程中，如果某个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。 1.4.2 分支操作 创建分支git branch [分支名] 查看分支git branch -v 切换分支git checkout [分支名] 合并分支第一步：切换到接受修改的分支（被合并的，增加新内容的分支）上git checkout [被合并分支名]第二步：执行merge命令git merge [有新内容的分支名] 解决冲突 合并后有冲突的分支的表现： 解决方式： 第一步：编辑文件，删除特殊符号 第二步：把文件修改到满意的程序，去掉冲突，保存退出 第三步：git add [文件名] 第四步：git commit -m &quot;日志信息&quot; 注意点：此时commit 一定不能带具体文件名 2. Git的基本原理2.1 哈希哈希是一系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下几个共同点： 不管输入数据的数据量有多大，输入同一个哈希算法，得到加密结果长度固定。 哈希算法确定，输入数据确定，输出数据能够保证不变。 哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大 哈希算法是不可逆的 Git底层采用的是SHA-1算法。 哈希算法常常被用来验证文件的完整性，确定性。 Git底层就是根据这种验证机制保证了数据的完整性。 2.2 Git保存版本的机制2.2.1 集中式版本控制工具的文件管理机制 以文件变更列表的方式存储信息。这类系统将他们保存的信息看做是一组基本文件和每个文件随时间逐步累积的差异。 2.2.2 Git的文件管理机制 Git把数据看做是小型文件系统的一组快照。每次提交更新时Git都会对当前的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git不再重新存储该文件，而是只保留一个链指向之前存储的文件。所以Git的工作方式可以称之为快照流。 2.2.3 Git文件管理机制细节 Git的“提交对象“ 提交对象及其父对象所形成的链条 2.3 Git分支管理机制2.3.1 分支的创建 2.3.1 分支的切换实质上是指针指向的对象变了，改变指针的指向，快速做到切换。 仅仅移动了指针，切换了版本 此时开始有了分支，都基于f30ab版本 所有操作都是基于链条指针的移动和切换。 3. Git的远程操作3.1 在本地初始化本地仓库，将文件提交到本地库3.2 在远程代码托管中心创建好仓库3.3 在git上给远程仓库地址起个别名 起别名：git remote add [别名] [仓库地址] 1$ git remote add git_note https://github.com/hxhaaj/Git_note.git 查看远程仓库信息以及别名：git remote -v 123$ git remote -vgit_note https://github.com/hxhaaj/Git_note.git (fetch)git_note https://github.com/hxhaaj/Git_note.git (push) 3.4 推送到远程库git push [仓库地址别名] [创建的分支名] 测试后，弹出登陆窗口，登陆后显示提交进度。 12345678$ git push git_note masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (19/19), done.Writing objects: 100% (20/20), 829.22 KiB | 12.02 MiB/s, done.Total 20 (delta 0), reused 0 (delta 0)To https://github.com/hxhaaj/Git_note.git* [new branch] master -&gt; master 3.5 克隆远程库git clone [远程库地址] 123456$ git clone https://github.com/hxhaaj/Git_note.gitCloning into &apos;Git_note&apos;...remote: Counting objects: 23, done.remote: Compressing objects: 100% (22/22), done.remote: Total 23 (delta 1), reused 19 (delta 0), pack-reused 0Unpacking objects: 100% (23/23), done. 克隆的效果 完整的把远程库下载到了本地 创建了远程地址别名 初始化了本地库，一条龙解决3.6 邀请他人加入团队后，其才可以进行推送写入仓库 3.7 pull拉取操作 pull = fetch + merge 即为pull操作是fetch操作和merge操作的组合，仅仅是fetch操作，不改变本地库，merge操作之后改变本地库里的文件 git fetch [远程库地址别名][远程分支名] 12345678$ git fetch git_note masterremote: Counting objects: 6, done.remote: Compressing objects: 100% (5/5), done.remote: Total 6 (delta 2), reused 3 (delta 1), pack-reused 0Unpacking objects: 100% (6/6), done.From https://github.com/hxhaaj/Git_note * branch master -&gt; FETCH_HEAD 8228eff..aeda745 master -&gt; git_note/master git merge [远程库地址别名]/[远程分支名] 12345$ git merge git_note/masterUpdating 8228eff..aeda745Fast-forward Git.md | 79 +++++++++++++++++++++++++++++++++++++++++++++++++++++------------- 1 file changed, 64 insertions(+), 15 deletions(-) pull 操作可以直接更新本地库,是fetch和merge的一次性操作git pull [远程库地址别名] [远程分支名] 3.8 冲突解决注意点： 如果不是基于GitHub远程库的最新版本所做的修改，不能进行push推送，必须先进行pull操作拉取下来。 拉取下来后如果进入冲突状态，则先解决冲突，去掉冲突标记，选用合适的内容，冲突解决后才能push操作。 3.9 跨团队协作 在他人的远程库地址上点击fork，就可以fork到自己的远程库上 在自己的远程库上，使用git中的git clone [远程库地址]操作，克隆到自己的本地库 自己在本地进行修改，push推送到远程库中 在远程库的项目中找到 并点击 pull requests -&gt; new pull requests -&gt; create pull request,然后发送该pull request的信息 ，此时在被fork的原始项目中的 pull requests一栏中就可以看到pull request的信息，并可以进行对话。 合并代码，在对话框中就可以点击 merge pull request进行合并，点击之后填写合并信息 被fork的用户就可以将已经更新修改的远程库就可以拉取到本地 3.10 SSH连接方式 ssh-keygen -t rsa -C [将要的登陆用户的邮箱] 执行后会生成SSH目录 .ssh/ 在.ssh/目录下 ，cat id_rsa.pub 获取该id的SSH-RSA的公钥复制到GitHub上的SSH Keys中 在GitHub上添加SSH key 新建使用SSH连接的远程地址别名git remote add [别名] [ssh方式的连接地址] 使用ssh连接进行push操作 4. Git在eclipse中的应用4.1 忽略推送配置文件 在网址https://github.com/github/gitignore/blob/master/Java.gitignore 找到Java.gitignore文件，此文件为GitHub已经整理好的忽略配置文件。 在自己的用户目录，把Java.gitignore文件和.gitconfig文件放在一块。 在Java.gitignore文件中加入以下内容：添加过滤项 1234.classpath.project.settingstarget Java.gitignore文件内容信息为： 12345678910111213141516171819202122232425262728# Compiled class file*.class# Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.classpath.project.settingstarget 在.gitconfig配置文件中加入以下内容： 12[core] excludesfile = C:/Users/hxhaaj/Java.gitignore 此时注意，该路径内容为Java.gitignore文件路径信息，同时，路径分割符必须为正斜线&#39;/&#39;，不能为反斜线&#39;\&#39;。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git基础</tag>
        <tag>GitHub使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaNIO]]></title>
    <url>%2F2018%2F03%2F10%2FJava-NIO%2F</url>
    <content type="text"><![CDATA[Java NIO1. Java NIO 概念 Java NIO（New IO） 是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。 2. NIO与IO的主要区别 IO NIO 面向流 面向缓冲区 阻塞IO 非阻塞IO 无 选择器 NIO面向缓冲区数据流通图 通道负责连通，搭建缓冲区流通路径 缓冲区用于来回运送数据 NIO核心在于：通道（Channel）和缓冲区（Buffer）。通道表示打开到IO设备（例如：文件、套接字）的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。 3. 缓冲区 （Buffer） 缓冲区就是数组，用于存储不同数据类型的数据。 3.1 缓冲区的类型根据数据类型不同（除了boolean类型）,提供了相应类型的缓冲区：1234567ByteBufferCharBufferShortBufferIntBufferLongBufferFloatBufferDoubleBuffer 上述各类型缓冲区管理方式几乎一致，通过allocate()获取缓冲区1ByteBuffer buf = ByteBuffer.allocate(1024); 3.2 缓冲区存取数据的两个核心方法 put() 存入数据到缓冲区中 get() 获取缓冲区中的数据 3.3 缓冲区中的四个核心属性 capacity 容量，表示缓冲区中最大存储数据的容量。一旦声明不能改变，即为数组长度。 limit 界限，表示缓冲区中可以操作数据的大小。limit值后面的数据不能进行读写。 position 位置，表示缓冲区中正在操作数据的位置。 mark 标记 ， 表示记录当前position的位置，可以通过reset()恢复到mark的位置。 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity 3.3.1 position、limit、capacity 值的关系 当allocate(10)分配10个字节大小的缓冲区后，position的位置为0，capacity(容量)的值为10，limit（界限）值为10。 当使用put(5)方法进入写数据模式时，position指针的位置在填入数据后的第一个空闲位置，此时位置为5，capacity总容量值不变，依然为10，limit界限值还是为10。 当使用方法flip()后进入读数据模式，此时的position指针的位置为使用区的开始位置，即为0。limit界限的值则为5，因为在读取模式中，读取的应为使用区，所以界限为5，超过5就是空闲区了，最多取到5。capacity总容量的值依然为10变。 3.4 缓冲区Buffer类中的常用方法 Modifier and Type Method and Description abstract Object array()返回支持此缓冲区的数组 （可选操作） 。 abstract int arrayOffset()返回该缓冲区的缓冲区的第一个元素的背衬数组中的偏移量 （可选操作） 。 int capacity()返回此缓冲区的容量。 Buffer clear()清除此缓冲区。但是其中的元素并没有消失，只是处于在 被遗忘状态,因为position、limit 值全部归零，和刚刚分配时一致。 Buffer flip()翻转这个缓冲区。 abstract boolean hasArray()告诉这个缓冲区是否由可访问的数组支持。 boolean hasRemaining()告诉当前位置和极限之间是否存在任何元素。 abstract boolean isDirect()告诉这个缓冲区是否为 direct 。 abstract boolean isReadOnly()告知这个缓冲区是否是只读的。 int limit()返回此缓冲区的限制。 Buffer limit(int newLimit)设置此缓冲区的限制。 Buffer mark()将此缓冲区的标记设置在其位置。 int position()返回此缓冲区的位置。 Buffer position(int newPosition)设置这个缓冲区的位置。 int remaining()返回当前位置和限制之间的元素数。 Buffer reset()将此缓冲区的位置重置为先前标记的位置。 Buffer rewind()倒带这个缓冲区。 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556String str = "hxh";//定义缓冲区，指定缓冲区类型和大小ByteBuffer bf = ByteBuffer.allocate(1024);System.out.println("--allocate()---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());/*--allocate()---capacity---1024limit---1024position---0*///利用put() 装入缓冲区,进去写模式bf.put(str.getBytes());System.out.println("--put()---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());/*--put()---capacity---1024limit---1024position---3*///使用flip()进入读数据模式bf.flip();System.out.println("--flip()---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());/*--flip()---capacity---1024limit---3position---0*///使用get(byte []) 读取缓冲区中的数据byte[] dst = new byte[bf.limit()];bf.get(dst);//此方法将字节从此缓冲区传输到给定的目标数组System.out.println(new String(dst,0,dst.length));//打印字节数组中的数据System.out.println("--get()---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());/* hxh --get()--- capacity---1024 limit---3 position---3 */ 测试结果：如上图一致 123456789101112131415161718--allocate()---capacity---1024limit---1024position---0--put()---capacity---1024limit---1024position---3--flip()---capacity---1024limit---3position---0 hxh--get()---capacity---1024limit---3position---3 rewind()，实现可重复读 123456789101112131415//使用rewind方法，实现可重复读bf.rewind();System.out.println("--rewind() 重复读取，指针归0---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());/* --rewind() 重复读取，指针归0--- capacity---1024 limit---3 position---0 */ clear()清除此缓冲区1234567891011121314151617181920//clear()清除此缓冲区。但是其中的元素并没有消失，// 只是处于在 被遗忘状态,// 因为position、limit 值全部归零，和刚刚分配时一致。bf.clear();System.out.println("--clear()---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());System.out.println("依然可以取到值，测试："+(char) bf.get());/* --clear()--- capacity---1024 limit---1024 position---0 依然可以取到值，测试：h */ 注意点：clear()清除此缓冲区。但是其中的元素并没有消失，只是处于在 被遗忘状态,因为position、limit、capacity 值全部归零，和刚刚分配时一致。如果直接bf.get()取值，当然也是可以取到。 mark()和 reset() 12345678910111213141516171819String str = "abcdefg";ByteBuffer bf = ByteBuffer.allocate(1024);bf.put(str.getBytes());bf.flip();byte[] dst = new byte[bf.limit()];bf.get(dst,0,2);System.out.println(new String(dst,0,2)); // abSystem.out.println("position---"+bf.position()); //2//此时标记一下position的位置bf.mark();System.out.println("此时mark一下");bf.get(dst,2,2);System.out.println(new String(dst,2,2)); //cdSystem.out.println("position---"+bf.position()); //4bf.reset(); //重置到标记位置System.out.println("reset 重置后---");System.out.println("position---"+bf.position()); //2 又回到了mark标记的位置 结果： 1234567abposition---2此时mark一下cdposition---4reset 重置后---position---2 hasRemainin 和 remaining 12345//hasRemaining 当前位置和极限位置之间是否还有元素if(bf.hasRemaining())&#123; //有元素， 返回当前位置和极限位置之间的元素数量 System.out.println(bf.remaining());&#125; 3.5 继承Buffer类的各具体类型缓冲区中的常用方法(以ByteBuffer类为例)3.5.1 allocate 分配缓冲区1public static ByteBuffer allocate(int capacity) 分配一个新的字节缓冲区 新缓冲区的位置将为零，其限制将为其容量，其标记将不定义，并且其每个元素将被初始化为零。 它将有一个backing array ，其array offset将为零。 参数 capacity - 新的缓冲区的容量，以字节为单位 结果 新的字节缓冲区 3.5.2 put 存入 ，写入缓冲区 1public abstract ByteBuffer put(byte b) 相对放置法（可选操作） 。 将给定字节写入当前位置的缓冲区，然后增加位置。 参数 b - 要写入的字节 结果 这个缓冲区 12public abstract ByteBuffer put(int index, byte b) 绝对put方法（可选操作） 。 将给定字节写入给定索引的缓冲区。 参数 index - 要写入字节的索引 b - 要写入的字节值 结果 这个缓冲区 123public ByteBuffer put(byte[] src, int offset, int length) 相对大容量put方法（可选操作） 。 此方法将字节从给定的源数组传输到此缓冲区。 如果要从数组中复制的字节多于保留在此缓冲区中的字节数，也就是说，如果length &gt; remaining() ，则不会传输任何字节，并抛出BufferOverflowException 。 否则，该方法将给定数组中的length个字节复制到此缓冲区中，从阵列中的给定偏移量和该缓冲区的当前位置开始。 此缓冲区的位置然后增加length 。 换言之，所述表格dst.put(src, off, len)的这种方法的调用具有完全一样的环相同的效果 1for (int i = off; i &lt; off + len; i++) dst.put(a[i]); 除了它首先检查这个缓冲区中是否有足够的空间，并且它可能更有效率。 参数 src - 要读取字节的数组 offset - 要读取的第一个字节的数组内的偏移量; 必须是非负数，不得大于array.length length - 要从给定数组读取的字节数; 必须是非负数，不得大于array.length - offset 结果 这个缓冲区 1public ByteBuffer put(ByteBuffer src) 相对大容量put方法（可选操作） 。 此方法将给定源缓冲区中剩余的字节传输到此缓冲区。 如果源缓冲区中剩余的字节多于此缓冲区，即src.remaining() &gt; remaining() ，则不会传输任何字节，并抛出BufferOverflowException 。 否则，该方法将n = src.remaining()个字节从给定缓冲区复制到此缓冲区中，从每个缓冲区的当前位置开始。 然后将两个缓冲器的位置递增n 。 换句话说，调用此方法的形式dst.put(src)具有与循环完全相同的效果 12while (src.hasRemaining()) dst.put(src.get()); 除了它首先检查这个缓冲区中是否有足够的空间，并且它可能更有效率。 参数 src - 读取字节的源缓冲区; 不能是这个缓冲区 结果 这个缓冲区 3.5.3 get 获取 ，读取缓冲区 1public abstract byte get() 相对获取方法。 读取该缓冲区当前位置的字节，然后增加位置。 结果 缓冲区当前位置的字节 1public abstract byte get(int index) 绝对获取方法。 读取给定索引处的字节。 参数 index - 读取字节的索引 结果 给定索引的字节 1public ByteBuffer get(byte[] dst) 相对批量获取方法。 此方法将字节从此缓冲区传输到给定的目标数组。 调用此方法的形式为src.get(a)的行为方式与调用完全相同 1src.get(a, 0, a.length) 参数 dst - 目的地阵列 结果 这个缓冲区 ​ 123public ByteBuffer get(byte[] dst, int offset, int length) 相对批量获取方法。 此方法将字节从此缓冲区传输到给定的目标数组。 如果缓冲区中剩余的字节比满足请求所需的字节少，也就是说，如果length &gt; remaining() ， 则不 传输任何字节并抛出BufferUnderflowException 。 否则，该方法将length字节从该缓冲区复制到给定的数组中，从该缓冲区的当前位置开始，并在数组中给定的偏移量。 然后将该缓冲区的位置增加length 。 换句话说，调用此方法的形式src.get(dst, off, len)具有与循环完全相同的效果 1for (int i = off; i &lt; off + len; i++) dst[i] = src.get(): 除了它首先检查这个缓冲区中是否有足够的字节，并且它可能更有效率。 参数 dst - 要写入字节的数组 offset - 要写入的第一个字节的数组中的偏移量; 必须是非负数，不得大于dst.length length - 要写入给定数组的最大字节数; 必须是非负数，不得大于dst.length - offset 结果 这个缓冲区 4. 非直接缓冲区和直接缓冲区4.1 概念区分 非直接缓冲区：通过allocate()方法分配缓冲区，将缓冲区建立在JVM的内存中. 直接缓冲区：通过allocateDirect()方法分配直接缓冲区，将缓冲区建立在物理内存中。操作系统的内存中，可以提升效率。 4.2 直接缓冲区的相对优缺点 直接缓冲区利用了操作系统中直接映射方式，在物理内存中初始化一个物理内存映射文件，省去了非直接缓冲区的中间多余的内容复制步骤，让应用程序和物理磁盘直接面对。 优点：简化步骤，直接映射，提升效率。 缺点： 初始化物理内存映射文件时，耗费较大物理内存，并且不会直接用完释放，必须通过垃圾回收机制进行释放。 直接操作物理内存和磁盘，不安全，不易控制。 适合：数据长时间在内存中操作，大量数据直接在物理内存中存放，不存放在jvm中。 直接缓冲区，Java虚拟机会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容），即省去了中间内容复制操作。而是直接在此缓冲区上执行本机IO操作。 直接缓冲区，通过Buffer类中的allocateDirect()工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。 5. 通道（Channel）5.1 通道概念 用于源节点和目标节点的连接。NIO中负责缓冲区中数据的传输。Channel类似于传统的“流”。但是Channel本身不存储数据，因此需要配合缓冲区进行传输。 5.2 Channel的主要实现类12345java.nio.channels.Channel 接口 |-- FileChannel |-- SocketChannel |-- ServletSocketChannel |-- DatagramChannel 5.3 Channel的获取 Java对于支持通道的类都提供了getChannel()方法。 本地IO： FileInputStream FileOutputStream RandomAccessFile 网路IO： Socket ServerSocket DatagramSocket Java7中的NIO 2 对于各个通道提供了静态方法open() Java7中的NIO 2 的Files工具类提供的方法 newByteChannel()]]></content>
      <categories>
        <category>JavaSE回顾</category>
      </categories>
      <tags>
        <tag>JavaNIO</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE回顾-基础语法]]></title>
    <url>%2F2018%2F01%2F12%2FJavaSE%E5%9B%9E%E9%A1%BE-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaSE 回顾-基础语法1. Java语言的特性1.1 简单性 java剔除了C++中许多很少使用、难以理解、易混淆的特性。尽可能的简单化。 1.2 面向对象 java是基于面向对象的程序设计技术设计的，将重点放在数据（即对象）和对象的接口上。 1.3 分布式 java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。 java 应用能通过URL打开和访问网络上的对象，其便捷程度就行访问本地文件一样。 1.4 健壮性 java程序具有多方面的可靠性，Java编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题。 1.5 安全性 Java适用于网络/分布式环境，为了达到这个目标，安全方面投入很大。使用java可以构建防病毒、防篡改的系统。 不可信的代码在一个沙箱环境中执行，在这里不会影响主系统。Java代码不论来自哪里，都不会脱离沙箱。 1.6 体系结构中立 编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要Java运行时系统，这些编译后的代码可以在许多处理器上运行。 Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。 字节码文件可以容易的在任何机器上解释执行，而且还可以动态翻译成本地机器码。 Java虚拟机可以将执行最频繁的字节码序列翻译成机器吗，该过程为即时编译。 Java虚拟机可以检测指令序列，增强其安全性。 1.7 可移植性 数据类型规定具有固定的大小。例如：Java中的int类型永远为32为的整数，不会随着操作系统或编译器不同而改变。 二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。 字符串是用标准的Unicode格式存储的。 作为系统组成部分的类库，定义了可移植的接口。例如：有一个抽象的Window类，并给出了在UNIX、Windows和Macintosh环境下的不同实现。 除了用户界面有关的部分外，所有其他Java库都能很好的支持平台独立性，不用操心底层的操作系统。 不仅程序是可移植的，Java API 往往也比原生的API质量更高。 1.8 解释型 Java解释器可以在任何移植了解释器的机器上执行Java字节码。 1.9 高性能 字节码可以在运行时动态翻译成对应运行这个应用的特定CPU的机器码。 即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。 1.10 多线程 Java支持多线程和并发性,可以带来更好的交互响应和实时行为。 1.11 动态性 适应不断发展的环境，在类库中可以自由的添加新方法和实例变量，而对客户端不产生任何影响。 2. Java 基本语法注意点2.1 类名 关键字class 后面紧跟类名。 类名命名规则： 必须以字母或下划线开头，后面可以跟字母和数字的任意组合。 注意：Java中的字母和数字的范围更大。字母包括&#39;A&#39;~&#39;Z&#39;、&#39;a&#39;~&#39;z&#39;、&#39;_&#39;、&#39;$&#39;或者在某种语言中表示字母的任何Unicode字符。 长度基本上没限制。 不能使用Java保留字作为类名。 12345678public class $Test1 &#123; //类名还可以是 _Test 以下划线开头 public static void main(String[] args) &#123; int _a = 1; int $a = 1; System.err.println(_a); System.out.println($a); &#125;&#125; 源代码的文件名必须与公共类名相同，并用.java作为拓展名。 类名命名规范： 类名以大写字母开头名词 骆驼命名法。 2.2 main方法 Java语言规范，main 方法 必须声明为 public。 Java SE 1.4及以后版本强制 main 方法一定是public修饰的。 main 方法 必须为 public static void main(String[] args) ，缺少public 、static、以及String[] args 参数，都不能成为class 的入口，运行不了。 2.3 注释 Java一共3种注释方式： // xxxxx 单行注释 多行注释 ，形成一个注释块 1234/* xxxx xxx */ 注意： /* xxx*/ 注释不能嵌套使用。 文档注释 可以用来自动地生成文档。 1234/** * @version * @author hxh */ 2.4 数据类型Java是强类型语言。每一个变量声明一种类型。一共有8种基本类型。 4种整型 int short long byte 2种浮点类型 float double 1种用于表示Unicode编码的字符单元类型 char 1种用于表示真值 类型 boolean 注意： Java 有一个能够表示任意精度的算术包，通常被称为“大数值” (big number)。它只是一个Java对象，不是一个数据类型。 2.4.1 整型 整型用于表示没有小数部分的数值，它可以是负数据。 类型 字节数 int 4 short 2 long 8 byte 1 整型的范围与运行Java代码的机器无关。 长整型数值有一个后缀L或l,如：1111L 十六进制数值有一个前缀0x或0X，如 0xCAFE 八进制有一个前缀0 Java7开始，加上前缀0b或0B就可以写二进制数。如：0b1001就是9。 Java7开始，还可以为数字字面量加下划线。如 1_000_00（0b1111_0100_0010_0100_0000）表示一百万。注意：这些下划线只是为了让人易读，Java编译器会自动去除这些下划线。 2.4.2 浮点类型 浮点类型用于表示有小数部分的数值。 类型 字节数 float 4 double 8 double类型数值精度是float类型的两倍，称为双精度数值。 float类型数值有一个后缀F或f（3.14f），没有后缀F的浮点数值（3.14）默认为double类型。 所有浮点数值计算都遵循IEEE 754规范。用于表示溢出或出错情况的三个特殊浮点数值： 正无穷大 负无穷大 NaN(不是一个数字) 例如： 一个正整数除以0的结果为正无穷大。 计算0/0或者负数的平方根结果为NaN。 浮点数值不适用于无法接受舍入误差的金融计算中。 例如： System.out.println(2.0-1.1); 结果为 0.8999999999999999 而不是正确结果0.9。 这种舍入误差原因是 浮点数值采用二进制系统表示，二进制系统中无法精确地表示分数1/10。就像十进制无法精确表示分数1/3一样。 如果数值计算中不允许出现这种舍入误差，就应该采用BigDecimal类。 2.4.3 char类型 char占2字节，16位。可在存放汉字，只能放单个字符。 12345char a='h'; //任意单个字符，加单引号。char a='中'; //任意单个中文字char a = 111; //整数。0~65535。十进制、八进制、十六进制均可。输出字符编码表中对应的字符。 char 类型原本用于表示单个字符。但是现在有所改变，有些Unicode字符可以用一个char值描述，另一些Unicode字符则需要两个char值。 char类型字面量值要用单引号括起来。 例如：’A’是编码值为65所对应的字符常量。它和 “A” 不同，”A” 是包含一个字符A的字符串。 对char类型字符运行时，直接当做ASCII表对应的整数来对待。 12345678910111213141516171819202122232425char m='a'; //a。char m='a'+'b'; // Ã。 //char类型相加，提升为int类型，输出对应的字符。int m='a'+'b'; //195没有超出int范围，直接输出195。char m='a'+b; //报错。 因为b是一个赋值的变量。char m=197; //输出字符编码表中对应的字符。 ——Ã。char m='197; //因为有单引号，表示是字符，只允许放单个字符。 ——报错。char m='a'+1; //提升为int，计算结果98对应的字符是b。——b。char m='中'+'国'; // 42282。char m='中'+'国'+'国'+'国'; // 报错。int转char有损失。因为结果已经超出char类型的范围。int m='中'+'国'+'国'+'国'; //86820char m='中'+1; //1是int，结果提升为int，输出对应的字符。 ——丮。char m='中'+"国"; // 报错。String无法转换为char。System.out.println('中'+"国"); //没有变量附值的过程。String与任何字符用“+”相连，转换为String。——中国。 char+char，char+int ， 类型均提升为int，赋值给char变量后，输出字符编码表中对应的字符(char h = 97 a)。 char类型的值可以表示为十六进制值，范围从\u0000到 \uffff。 除了转义序列\u之外，还有其他用于表示特殊字符的转义序列。 所有转义序列都可以出现在加引号的字符字面量或字符串中。例如： &#39;\u2122&#39; &quot;hello\n&quot; 转义序列\u还可以出现在加引号的字符常量或者字符串之外。其他转义序列不可以。 Unicode转义序列会在解析代码之前得到处理。 例如： &quot;\u0022+\u0022&quot;并不是一个由引号包围加号构成的字符串。实际上，\u0022会在解析之前转换为&quot;，这样就会得到&quot;&quot;+&quot;&quot;，也就是一个空串。 当心注释中的\u。 // Look inside C:\users 会产生一个语法错误，因为\u后面并未跟着4个十六进制数。 12345public class Test1 &#123; public static void main(String[] args) &#123; System.err.println("1");// Look inside C:\users &#125;&#125; 语法出错： 编译都通不过: 12Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: Invalid unicode 在Java中，char类型描述了UTF-16编码中的一个代码单元。建议不要在程序中使用char类型，除非缺失需要处理UTF-16代码单元。最好将字符串作为抽象画数据类型处理。 2.4.4 boolean类型 只有两个值： flase 和 true 用来判断逻辑条件 整型值和布尔值之间无法相互转换 2.5 变量2.5.1 变量命名规定 变量名必须是一个以字母、下划线、$符号开头并由字母或数字构成的序列。一般来说，在Java中，下划线和$均属于字母。π 、 其他国家的字母 也可以。 不能出现 其他符号 例如 + 、 @ 这样的符号 以及 空格 不能出现在变量名中。 大小写敏感 长度基本没有限制 尽管$是一个合法的Java字符，但是最好不要出现在自己的代码中使用这个字符。它只用在Java编译器或者其他工具生成的名字中。 不能使用Java保留字 1234int _a = 1;int $a = 1;System.err.println(_a);System.out.println($a); 2.5.2 变量初始化 声明后的一个变量，不能直接使用未初始化的变量。必须使用赋值语句对变量进行显式初始化。 2.6 常量 利用关键字final 指示常量。 final修饰的变量只能被赋值一次，一旦赋值一次后，不能再更改。 习惯上常量名使用全大写 若某个常量经常被一个类中的多个方法中使用，通常称该常量为类常量。可以使用static final 设置一个类常量。定义在main方法的外部。 2.7 运算符 当参与/运算的两个操作数都是整数时，表示整数除法；否则表示浮点除法。 例如 ： 15.0/2 等于 7.5 而 15/2 等于 7 整数被0除将会产生一个异常，而浮点数被0除将会得到一个无穷大或NaN结果。 2.8 数值类型之间的转换 小字节类型转换成大字节类型无信息丢失转换，相反，可能会有精度损失。 下图中，6个实心箭头表示无信息丢失的转化，3个虚线箭头表示可能有精度损失。 二元运算时，注意：先将两个操作数转换为同一种类型，然后再进行计算。 若 两个中有一个是double类型，另一个将会转换为double类型； 否则，若 两个中有一个是float类型，另一个将会转换成float类型； 否则，若 两个中有一个是long类型，另一个将会转换成long类型； 否则，两个都将会转换成int类型。 2.9 强制类型转换 强制类型转换通过截断小数部分将浮点值转换成整型。 如果想对浮点数进行舍入运算，就需要用Math.round()方法，该方法返回值为long类型，所以只有使用显式的强制转换才能将long类型转换成int类型。 12345678double x = 9.999;System.err.println((int)x);//9Long hh = Math.round(x);System.err.println(hh);//10int h = (int) Math.round(x);System.err.println(h); //10 需要注意目标类型的表示范围： 如果试图将一个数值从一种类型强制转换成为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值。例如：(byte)300 实际值 却只为 44。 12int a = 300;System.out.println((byte)a); //44 2.10 空串与Null串 空串是长度为0的字符串，是一个Java对象，有自己的串长度（0）和内容 （空）。 String h = null; 表示一个Null串，目前没有任何对象与该变量关联，无引用。 检查一个字符串，要检查它既不是null也不为空串：if(str != null &amp;&amp; str.length() != 0) 2.11 switch语句 switch语句将会从与选项值相匹配的case标签处开始执行直到遇到break语句，或者执行到switch语句的结束处为止。 如果没有匹配case分支，而有default子句，就执行default子句。 很有可能触发多个分支： 如果在case分支语句的末尾没有break语句，那么就会接着执行下一个case分支语句。 case标签可以是： 类型为 char 、byte 、short 、 int 的常量表达式 枚举常量 Java SE 7开始，case标签还可以是字符串字面量。 2.12 大数值 如果基本的整数和浮点值精度不够，那么可以使用java.math包中的两个类：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值。 BigInteger类实现了任意精度的整型运算。 BigDecimal类实现了任意精度的浮点数运算。 使用静态的valueOf()方法可以将普通的数值转换成大数值。 2.12.1 BigDecimal 浮点数值不适用于无法接受舍入误差的金融计算中。 例如： System.out.println(2.0-1.1); 结果为 0.8999999999999999 而不是正确结果0.9。 12System.out.println(1.01 + 2.02);//3.0300000000000002System.out.println(3.0 - 2.1);//0.8999999999999999 这种舍入误差原因是 浮点数值采用二进制系统表示，二进制系统中无法精确地表示分数1/10。就像十进制无法精确表示分数1/3一样。 如果数值计算中不允许出现这种舍入误差，就应该采用BigDecimal类。用来对超过16位有效位的数进行精确的运算。 双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。 创建BigDecimal对象主要有两种: 12BigDecimal b1= new BigDecimal("3.0");//new BigDecimal(Double.toString(3.0))BigDecimal b2 = BigDecimal.valueOf(2.1); b1也可以写成new BigDecimal(Double.toString(3.0))，直接用new BigDecimal(3.0)，就会出现精度问题。 12BigDecimal x1 = new BigDecimal(1.34);//1.3400000000000000799360577730112709105014801025390625BigDecimal x2 = new BigDecimal("1.34");//1.34 除了这两种外，特殊的像0、1、10可以这样写 123BigDecimal zero = BigDecimal.ZERO;BigDecimal one = BigDecimal.ONE;BigDecimal ten = BigDecimal.TEN; BigDecimal所创建的是对象，不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。 1234public BigDecimal add(BigDecimal value);//加法public BigDecimal subtract(BigDecimal value);//减法 public BigDecimal multiply(BigDecimal value);//乘法public BigDecimal divide(BigDecimal value);//除法 BigDecimal的运算不对原值进行操作，而是返回一个新的BigDecimal对象。 BigDecimal的比较用的是BigDecimal的compareTo方法，将此 BigDecimal 与指定的 BigDecimal 比较。 注意：值相等但具有不同标度的两个BigDecimal对象（如，2.0 和 2.00）被认为是相等的。 BigDecimal 在数字上小于、等于或大于比较对象时，返回 -1、0 或 1。 123456BigDecimal a = BigDecimal.valueOf(1);BigDecimal b = BigDecimal.valueOf(20);BigDecimal c = a.add(b);int i1 = a.compareTo(b);//-1int i2 = b.compareTo(b);//0int i3 = c.compareTo(b);//1]]></content>
      <categories>
        <category>JavaSE回顾</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
</search>
