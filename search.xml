<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaSE回顾-多线程]]></title>
    <url>%2F2018%2F06%2F20%2FJavaSE%E5%9B%9E%E9%A1%BE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JavaSE回顾多线程基本概念程序(program) 为了完成特定任务、用某种语言编写的一组指令的集合。即一段静态的代码，静态对象。 进程(process) 程序的一次执行过程，或者是正在运行的一个程序，是动态过程。 动态过程：有自身的产生、存在和消亡的过程。 程序是静态的，而进程是动态的。 线程(thread) 进程可以进一步细化为线程，是一个程序内部的一条执行路径。 若一个程序可同一时间执行多个线程，那么这个程序就支持多线程。 Java中的线程 Java线程是依附于Java虚拟机中的本地线程来运行的，实际上是本地线程在执行Java线程代码，只有本地线程才是真正的线程实体。 Java代码中创建一个thread，虚拟机在运行期就会创建一个对应的本地线程，而这个本地线程才是真正的线程实体 多线程的用处 发挥多核CPU的优势，大大提高效率 防止多余的阻塞 单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率 ，但是单核CPU我们还是要应用多线程，就是为了防止阻塞 。 多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行 方便进行业务拆分，提升应用性能 时间片 时间片是CPU调度给各个线程的时间。 并行和并发 并行：多个任务同时进行，必须有多核CPU的支持 并发：指多个任务都请求运行，而处理器只能接受一个任务，就是把多个任务轮流进行，由于轮转时间间隔过短，让人感觉是多个任务都在同时运行。 同步和异步 同步和异步通常用来形容一次方法调用。 同步方法调用一开始，调用者必须等待被调用的方法执行结束后，才能执行后面的代码。 异步方法调用后，调用者不用理会调用方法是否执行完毕，都会继续执行后面的代码，当被调用的方法完成之后会通知调用者。 临界区 临界区表示一种公共资源，共享数据，可以被多个线程使用。 一旦临界区资源被一个线程占用时，其他线程必须等待其使用完毕后才能使用。 阻塞和非阻塞 阻塞和非阻塞通常用来形容多线程之间的相互影响。 当一个线程占用了临界区资源，那么其他线程需要这个资源就必须等待该资源被那个线程释放，这就会导致等待的线程挂起，这种情况就是阻塞。 非阻塞强调没有一个线程可以阻塞到其他线程，所有的线程都会尝试地往前运行。和阻塞正好相反。 问题引入 Java程序的运行原理？ Java命令会启动Java虚拟机，启动JVM，等于启动了一个应用程序，也就是启动了一个进程。这个进程会自动的启动一个主线程，然后主线程调用类中的main方法。 实际上java程序天生就是一个多线程程序，包含了： （1）分发处理发送给给JVM信号的线程 （2）调用对象的finalize方法的线程 （3）清除Reference的线程； （4）main线程，用户程序的入口 JVM的启动是多线程吗？ JVM的启动至少启动了主线程和垃圾回收线程，所以是多线程的。 多线程的实现方式方式一： 继承Thread类 Thread类实现了Runnable接口，在java.long包下。 创建执行线程方法一：将类继承Thread类，重写Thread类的run方法。接下来就可以分配并启动该子类的实例。 具体步骤： 继承Thread类 重写run方法 将执行的代码写在run方法中 创建Thread类的子类对象 使用start方法开启线程。 注意：调用run方法不能开启多线程。 只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。 一个线程不能多次开启是非法的 代码示例： 12345678910111213141516171819202122public class ThreadTest &#123; public static void main(String[] args) &#123; //4，创建Thread类的子类对象 MyThread mt = new MyThread(); mt.start();//5，使用start方法开启线程 for (int i = 0; i &lt; 10000; i++) &#123; System.out.println("main" + i); &#125; &#125;&#125;class MyThread extends Thread&#123; //1.继承Thread类 //2，重写run方法 @Override public void run()&#123; //3，将执行的代码写在run方法中 for (int i = 0; i &lt;10000 ; i++) &#123; System.out.println("mt"+i); &#125; &#125;&#125; 方式二：实现Runnable接口（常用，优点多） 声明实现Runnable接口的类，实现Runnable接口中仅有的run方法，然后分配实例对象，在创建Thread时作为一个参数来传递并启动。 具体步骤 1，定义类实现Runnable接口 2，在该类中实现Runnable接口中的run()方法 3，线程中具体要执行的东西写在run()方法中 4，创建Thread类的对象，并在该对象中传入该实现Runnable接口的对象作参数 5，Thread类的对象调用start()方法开启新线程，其内部会自动的调用run方法 12345678910111213141516171819202122public class RunnableTest &#123; public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); //4、创建自己定义的Runnable实现类的对象 Thread thread = new Thread(mr); //5、创建Thread类的对象，并将自定义Runnable实现类的对象作为参数传递给Thread的构造函数 thread.start(); //使用thread类的start方法开启线程。 for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("main+"+i); &#125; &#125;&#125;//1、定义一个Runnable实现类class MyRunnable implements Runnable&#123; //2、实现Runnable接口中的抽象方法 @Override public void run() &#123; //3、在run方法中写入要使用多线程的具体方法 for (int i = 0; i &lt;1000; i++) &#123; System.out.println("mr"+i); &#125; &#125;&#125; 实现Runnable接口方式的实现原理 1、查看Thread 类的构造函数，传递了Runnable接口的引用，直接调用了init方法。 123public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0); &#125; 2、追踪init方法，在init方法体中找到了传递的target参数，赋值给了Thread类的Runnable接口的成员变量的target 1this.target = target; 12/* What will be run. */ private Runnable target; 3、查看run方法时，发现run方法中有判断，如果target不为null就会调用实现Runnable接口子类对象的run方法 123456@Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 为什么实例效果不明显？ 多线程指的是多个线程的代码块可以同时运行，而不必一个线程去等待另一个线程执行完才可以进行。 对于单核CPU来说，无法做到真正意义上的多线程特性。只能会让用户看起来像是同时执行的，因为每个时间点上，CPU都会执行特定的代码，由于CPU执行代码时间非常快，多个线程代码块就会轮询执行，速度很快，但是同一个线程进行的轮询操作。 具体执行某段代码多长时间和分时机制系统密切相关。 分时系统把CPU时间划分为多个时间片，操作系统以时间片为单位执行各个线程的代码，时间片越小，执行效率越高。 多线程的两种实现方式的区别 源码中的区别 继承Thread类方式：由于子类重写了Thread类的run()，当调用start()时，直接找子类的run()方法(Java虚拟机自动完成) 实现Runnable方式：构造函数中传入了Runnable的引用，传给了Thread类中的成员变量，start()调用了run()方法时的内部判断成员变量Runnable的引用是否为空，若不为空，编译时看的是Runnable的run()，运行时执行的是具体实现类中的run() 优缺点： 继承Thread类方式 好处：可以直接使用Thread类中的方法，代码简单 弊端：同样也是面向对象中的继承的缺点：如果该具体类已经有了其他的父类，那么就不能多重继承Thread类，就不能使用这种方法。此时面向接口编程的优势脱颖而出。 实现Runnable接口方式 好处：即继承的弊端：即使自己定义的线程类有了其他父类也可以实现该Runnable接口。Java中的接口是多实现的，继承是单继承，比较有局限性。 弊端：不能直接使用Thread类中的方法，需要先把Runnable具体实现类对象传递给Thread类并获取到线程对象后，才能得到Thread类的方法，代码相对复杂 匿名内部类实现线程的两种方式即直接使用匿名内部类的方式简化代码： 继承Thread类方式 123456789//匿名内部类new Thread()&#123; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; System.out.println("t+"+i); &#125; &#125;&#125;.start(); 实现Runnable接口方式 123456789//匿名内部类new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt;1000; i++) &#123; System.out.println("mr"+i); &#125; &#125;&#125;).start(); Runnable接口是一个函数式接口，可以直接用Lambda表达式代替: 123456//Lambda表达式new Thread(()-&gt;&#123; for (int i = 0; i &lt;1000; i++) &#123; System.out.println("mr"+i); &#125;&#125;).start(); 还有一种方式，在Java并发包中实现Callable接口方式，此处先不作表述 线程相关实例方法获取线程ID- getId 在一个Java应用程序中，有一个long型的全局唯一的线程ID生成器threadSeqNumber，每new出来一个线程就会自增一次，从0开始，并且赋值给线程的tid属性。 用户只能获取ID，不能执行一个线程的ID，这是Thread类内部自己完成的。 获取和设置线程的名字 获取线程名 通过getName()方法获取线程对象名 123456new Thread()&#123; @Override public void run() &#123; System.out.println(this.getName());//Thread-0 &#125;&#125;.start(); 设置线程名 通过构造函数传入String类型名 12345678910111213new Thread("线程1")&#123; @Override public void run() &#123; System.out.println(this.getName());//线程1 &#125;&#125;.start();new Thread("线程2")&#123; @Override public void run() &#123; System.out.println(this.getName());//线程2 &#125;&#125;.start(); 12345//Lambda表达式的Runnable方式，Thread的构造函数Thread t2 = new Thread(() -&gt; System.out.println("线程5的执行方法体"),"线程5");t2.start();System.out.println(t2.getName());//线程5 通过setName(String name)方法设置 1234567new Thread()&#123; @Override public void run() &#123; this.setName("线程3"); System.out.println(this.getName());//线程3 &#125;&#125;.start(); 12345678Thread t1 = new Thread() &#123; @Override public void run() &#123; System.out.println(this.getName());//线程4 &#125;&#125;;t1.setName("线程4");t1.start(); 12345678Thread t1 = new Thread(()-&gt; System.out.println("线程4的执行方法体"));t1.setName("线程4");t1.start();System.out.println(t1.getName());//线程4/* 线程4 线程4的执行方法体 */ 线程对象是否处于活动状态 - isAlive t.isAlive() 测试线程t是否处于活动状态，只要线程启动并且没有终止，方法返回值就是true。 start()之前，线程不处于活动状态，之后就处于了活动状态。 获取当前线程的对象 Thread.currentThread() 静态方法，获取当前执行线程， 主线程也可以获取 1234//Runnable接口方式//new Thread(Runnable target,String threadName) 构造方法new Thread(()-&gt; System.out.println(Thread.currentThread().getName()),"线程6") .start();//线程6 在main方法中可以获取主线程对象并设置： 12Thread.currentThread().setName("我是主线程");System.out.println(Thread.currentThread().getName());//我是主线程 休眠线程-sleep Thread.sleep(毫秒) / Thread.sleep(毫秒，纳秒) 控制当前线程休眠若干毫秒 1秒 = 1000毫秒 1秒 = 1000 1000 1000 纳秒 （100,000,000） 12345678910new Thread(()-&gt;&#123; for(int i = 0; i &lt; 10 ;i++)&#123; System.out.println(Thread.currentThread().getName()); try&#123; Thread.sleep(1000); //每个线程休眠1秒（1000毫秒) &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;,"测试线程1").start(); sleep方法不会释放锁，wait方法会释放锁 加入线程-join join() 当前线程暂停，等待指定的线程执行结束后，当前线程才能再继续。即把指定的线程插队处理。 join(int ms) 可以等待指定的毫秒后再继续。 join()方法会使调用该方法的线程处于运行状态，让一开始所在的线程处于无限阻塞状态，直到调用了join方法的线程执行完毕，线程销毁为止。 下面这个例子中，t2线程处于了阻塞状态，直到t1线程的run()方法执行完，线程死亡状态，t2线程才可以运行。 123456789101112131415161718192021222324252627282930public static void main(String[] args) &#123; //Java8中 匿名内部类调用外接方法和变量时，外接变量可以不用final修饰，但是其值还是不能改变 Thread t1 = new Thread() &#123; //此时的t1在Java8之前必须用final修饰，是不可变的 @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + "aaa"); &#125; &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; if (i == 2) &#123; try &#123; //Java8中 匿名内部类调用外接方法和变量时，外接变量可以不用final修饰，但是其值还是不能改变 t1.join();//t1线程对象来插队了，t1执行完之后t2才能继续执行 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(Thread.currentThread().getName() + "bbb"); &#125; &#125; &#125;; t1.start(); t2.start();&#125; 执行结果： 1234567891011121314151617181920Thread-1bbbThread-1bbbThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-0aaaThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbbThread-1bbb 结果显示：当t2线程执行两个后，t1使用join方法来插队，t1执行完之后，t2才继续执行完。 让出线程-yield Thread.yield() 使该线程让出cpu，给其他线程使用cpu执行 yield只会把时间片让给同优先级的线程 使CPU调度到其他线程，让该线程从运行状态回到可运行状态 设置线程优先级 thread.setPriority(int priority) 设置线程的优先级 Thread类源码中有三种优先级：(1,5,10) 1234567891011121314/** * The minimum priority that a thread can have. */public final static int MIN_PRIORITY = 1;/** * The default priority that is assigned to a thread. */public final static int NORM_PRIORITY = 5;/** * The maximum priority that a thread can have. */public final static int MAX_PRIORITY = 10; 优先级值：默认为5，最大为10，最小为1； 不能超过1~10这个范围。 12t1.setPriority(Thread.MIN_PRIORITY);//最小t1.setPriority(Thread.MAX_PRIORITY);//最大 中断线程-Interrupt 中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。 其他线程可以调用该线程的interrupt()方法对其进行中断操作，同时该线程可以调用isInterrupted()来感知其他线程对其是否进行了中断操作，从而做出相应。 也可以调用Thread中的静态方法interrupted()对当前线程进行中断操作，该方法会清除中断标志位。 当抛出InterruptedException时，会清除中断标志位，也就是说在调用isInterrupted会返回false。 如果线程调用了 wait()、sleep()、join()方法而导致的阻塞，可以中断线程，并抛出InterruptedException来唤醒 方法名 作用 备注 public void interrupt() 中断该线程对象 如果线程调用了 wait()、sleep()、join()方法而导致的阻塞，可以中断线程，并抛出InterruptedException来唤醒，并且中断标志位会被清除 public boolean isInterrupted() 测试该线程对象是否被中断 中断标志位不会被清除 public static boolean interrupted() 测试当前线程是否被中断 中断标志位会被清除 守护线程-Deamon setDaemon(boolean on) 设置一个线程作为守护线程。 守护线程为其他线程的运行提供便利的服务，最典型的应用便是GC线程 。 该线程不会单独执行，当其他非守护线程都执行结束后，守护线程就没有可服务的对象了，就会自动退出。 123456789101112131415161718public static void main(String[] args) &#123; Thread t1 = new Thread(()-&gt;&#123; for (int i = 0; i &lt; 3; i++) &#123; System.out.println(Thread.currentThread().getName()+"非守护线程"); &#125; &#125;); Thread t2 = new Thread(()-&gt;&#123; for (int i = 0; i &lt; 30; i++) &#123; System.out.println(Thread.currentThread().getName()+"守护线程"); &#125; &#125;); t2.setDaemon(true);//将t2设置成守护线程 t1.start(); t2.start();&#125; 第一次执行结果： 123Thread-0非守护线程Thread-0非守护线程Thread-0非守护线程 说明：非守护线程直接执行完毕后，守护线程还未开启执行，就自动退出了。 第二次执行结果： 12345678910Thread-0非守护线程Thread-1守护线程Thread-1守护线程Thread-0非守护线程Thread-0非守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程Thread-1守护线程 根据结果发现，守护线程和非守护线程穿插执行，非守护线程执行完之后，守护线程继续执行了，没有立即停止，该现象为线程缓冲，即守护线程正在执行，需要等到非守护线程的执行完毕信号后，才能停止下来，自动退出。 wait()和notify()/notifyAll()Object类中的wait()、notify()、notifyAll()三个方法，每个对象都是有的，结合多线程后可以起到很大的效果。 wait() wait()方法作用是使当前执行的代码的线程进行等待，当前线程会进入等待队列中。 wait()代码处会停止执行，直到接到通知（notify()）或者被中断（Interrupt()）。 在调用wait()之前，线程必须获取该对象的锁，因此wait()方法只能在同步代码中调用执行。 wait()方法可以使调用该线程的方法释放共享资源的锁，然后从运行状态退出，进入等待队列，直到再次被唤醒。 notify() 唤醒等待的线程，如果有多个线程在等待队列中，那么会随机挑选一个等待的线程，对其发出唤醒通知，并且使它等待获取该对象的对象锁。 等待获取对象锁说明了即使收到了通知，wait 的线程也不会马上获取对象锁，会在锁池中进行等待notify方法的线程释放锁才可以，获取了对象锁之后才能从锁池中出去进入可运行状态。 在调用notify()之前，和wait()一样，必须在同步代码中调用。因为有锁的操作。 notify()不释放锁 notifyAll() notifyAll()方法可以使所有正在等待队列中等待同一共享资源的全部线程从等待状态退出，随机进入锁池，等待拿到对象锁，进入可运行状态。 如果wait()方法和notify()/notifyAll()方法不在同步方法/同步代码块中被调用，那么虚拟机会抛出java.lang.IllegalMonitorStateException ☆ sleep()和wait()的区别 方法本质上： wait()方法时Object类中的实例方法。可以传入参数，也可以不传入参数。 而sleep()方法时Thread类中的静态方法。必须传入参数ms值。 使用环境上： wait()方法必须要在同步方法或同步代码块中使用，因为它必须已经获得对象锁。 而sleep()方法没有这个限制，它可以在任何地方使用。 是否释放锁： wait()方法会释放占有的对象锁，使该线程进入等待池中。 而sleep()方法不会释放对象锁，只会让出CPU。 使其继续执行方式上： wait()方法必须等待 notify()/notifyAll()方法的唤醒通知后，才会离开等待池并且如果再次获得CPU时间片才会继续执行。 而sleep()方法在休眠时间到达后，如果再次获得CPU时间片就会继续执行。 Java中用到的线程调度算法 Java中用到的是抢占式的线程调度算法。一个线程用完CPU后，操作系统会根据线程优先级、线程饥饿程度等数据算出一个总的优先级并分配下一个时间片给某个线程。 Thread.sleep(0)的作用？ 平衡CPU控制权的一种操作： 由于Java采用的是抢占式线程调度算法，因此可能就会出现某条线程综合来看常常会获取到CPU的控制权的情况，为了让某些优先级较低的线程也能获得到CPU控制权，可以使用Thread.sleep(0)手动出发一次操作系统分配时间片的操作，来平衡控制权。 线程六大状态根据Thread类中定义的枚举类型State值，可以看出有6中状态： 1234567public enum State &#123; NEW, RUNNABLE, WAITING, TIMED_WAITING, TERMINATED;&#125; 新建状态 NEW 新建了Thread类对象，但是没有启动的线程。new Thread() 可运行状态 RUNNABLE 线程对象新建后，调用start()方法即处于了RUNNABLE状态。 此状态线程可能在Java虚拟机中运行； 可能在等待CPU处理器分配资源。 一个线程只有获取到CPU的资源后，才可以运行其run()方法执行代码，否则就会处于排队等待 阻塞状态 BLOCKED 该线程正在等待同步锁来进入一个同步代码块中来使用CPU资源，此时该线程就处于阻塞状态。 等待状态 WAITING 线程调用以下方法时，会自己进入等待状态： 不带超时的Object类中的wait()方法 不带超时的Thread类中的join()方法 LockSupport类中的park()方法 一直等待，直到手动唤醒 超时等待状态 TIMED_WAITING 线程调用带有正的等待时间参数的下列各方法时，会处于超时等待状态： Object中的wait() Thread中的join() Thread中的sleep() LockSupport中的parkNanos() LockSupport中的parkUntil() 终止状态 TERMINATED 线程执行完毕，或run()方法全部执行结束后，线程进入终止状态。 终止状态的线程不具备继续运行的能力。 线程状态图 锁池队列：当资源被一个线程访问时，上锁后，其他线程就会进入锁池队列，当锁释放后，其他线程获得了锁，就会变成可运行状态。 《Thinking in Java》中线程被阻塞的五种可能原因： 线程调用 sleep(ms) ，使线程睡眠，规定时间内，该线程不会运行。 使用suspend()暂停了线程的执行，除非收到resume()消息，否则不会进入可运行状态 线程正在等待一些IO操作完成 线程试图调用另一个对象的同步方法，但那个对象处于锁状态，暂时无法使用 调用wait()暂停了线程的执行，进入了等待队列。 怎么唤醒一个阻塞的线程 如果线程调用了 wait()、sleep()、join()方法而导致的阻塞，可以中断线程，并抛出InterruptedException来唤醒 如果该线程遇到了IO阻塞，只能等系统IO操作结束后，才能唤醒，Java代码无能为力，无法直接接触到底层操作系统的调度。 怎么检测一个线程是否持有对象监视器 Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true 1public static boolean holdsLock(Object obj) 同步代码需要同步的情况 当多线程并发，有多段代码同时执行时，希望某一段代码执行的过程中，CPU不要切换到其他线程上，此时就需要同步。 如果有两段代码是同步进行的，那么同一时间只能执行其中一段，在一段代码没执行结束之前，不会执行另外一段代码。 同步代码块操作 使用synchronized关键字加上一个锁对象来定义一段代码，这就称为同步代码块。 如果多个同步代码块使用同一个锁对象，那么他们就是同步的 同步代码块是锁机制，同一个锁对象，同步代码块是同步的。 锁对象是任意对象，但不能是匿名对象，因为匿名对象不是同一个对象。 当多个代码块使用了同一个锁对象的 synchronized 锁机制，只有当一个线程把 synchronized 代码块的代码全部执行完之后，才能去执行该同一锁对象的另一段代码。 即该多个代码块是同步的，同一时间只能执行其中一段，执行完之后，才能执行另一段。 若锁对象不一致，即不是同步的，会出现抢占线程执行的情况。 具体操作： 1234567891011121314151617181920212223242526272829303132333435363738394041public class SynchronizeTest &#123; public static void main(String[] args) &#123; Consumer con = new Consumer(); new Thread(()-&gt;&#123; while(true) con.print1(); &#125;).start(); new Thread(()-&gt;&#123; while(true) con.print2(); &#125;).start(); &#125;&#125;class Consumer &#123; //定义一个Object对象，作为锁对象 Object obj = new Object(); public void print1()&#123; //锁机制使用同一个锁对象 synchronized (obj)&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125; &#125; public void print2()&#123; //锁机制使用同一个锁对象，作为同步代码块 synchronized(obj)&#123; System.out.print("多"); System.out.print("线"); System.out.print("程"); System.out.println(); &#125; &#125;&#125; 同步方法 使用synchronized关键字修饰一个方法时，该方法中所有代码都是同步的。 123456789101112//同步方法只需在方法上加 synchronized public synchronized void print1()&#123; //锁机制使用同一个锁对象 synchronized (obj)&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125;&#125; 非静态同步函数的锁是this 1234567891011121314151617181920//同步方法只需在方法上加 synchronized public synchronized void print1()&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125;public void print2()&#123; //非静态的同步方法的锁对象是this synchronized(this)&#123; System.out.print("多"); System.out.print("线"); System.out.print("程"); System.out.println(); &#125;&#125; 此时 这两个方法时 同步的 静态同步函数的锁是字节码对象 静态域随着类的加载而加载，此时会产生该类的字节码对象，所以静态同步方法锁对象不能是this，而是产生的字节码对象 12345678910111213141516171819public static synchronized void print1()&#123; System.out.print("同"); System.out.print("步"); System.out.print("代"); System.out.print("码"); System.out.print("块"); System.out.println(); &#125;public static void print2()&#123; //静态的同步方法的锁对象是随着类加载而产生的类的字节码对象 synchronized(Customer.class)&#123; System.out.print("多"); System.out.print("线"); System.out.print("程"); System.out.println(); &#125;&#125; 同步方法和同步块，哪个是更好的选择 基本原则：同步的范围越小越好。 同步块之外的代码是异步执行的，比同步整个方法更有效率。 线程安全 如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的 线程安全级别 1、不可变 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 2、绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的。不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet 3、相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。 4、 线程非安全 ArrayList、LinkedList、HashMap等都是线程非安全的类 常见的线程安全类 线程安全类 线程不安全类 Vector ArrayList StringBuffer StringBuilder Hashtable HashMap … LinkedList … … StringBuffer 线程安全（其append方法中加了synchronized修饰 vector add、remove方法都是原子操作,加了synchronized修饰 但是Collections集合工具类中提供了静态方法synchronizedXXX(XXX)，分别对应着线程不安全的那些集合类，可以让他们转换成线程安全的集合，所以Vector类淘汰了… 方法摘要 方法说明 static &lt;T&gt; Collection&lt;T&gt; synchronizedCollection(Collection&lt;T&gt; c) 返回指定 collection 支持的同步（线程安全的）collection。 static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) 返回指定列表支持的同步（线程安全的）列表。 static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) 返回由指定映射支持的同步（线程安全的）映射。 static &lt;T&gt; Set&lt;T&gt; synchronizedSet(Set&lt;T&gt; s) 返回指定 set 支持的同步（线程安全的）set。 static &lt;K,V&gt; SortedMap&lt;K,V&gt; synchronizedSortedMap(SortedMap&lt;K,V&gt; m) 返回指定有序映射支持的同步（线程安全的）有序映射。 static &lt;T&gt; SortedSet&lt;T&gt; synchronizedSortedSet(SortedSet&lt;T&gt; s) 返回指定有序 set 支持的同步（线程安全的）有序 set。 多线程中的线程安全问题 多线程并发操作同一共享数据时，就会可能出现线程安全问题。 使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 就不会多个线程同时执行 多窗口卖票问题 如果不开启锁同步 ，就会出现卖出票号为负数的现象 在循环中使用锁同步，让各个线程进入循环之后进行同步，一个线程把ticketNum–后，其他线程再执行 使用Runnable方式实现： 123456789101112131415161718192021222324252627282930313233public class SynchronizeTicketTest &#123; public static void main(String[] args) &#123; new Thread(new TicketSeller()).start(); new Thread(new TicketSeller()).start(); new Thread(new TicketSeller()).start(); new Thread(new TicketSeller()).start(); &#125;&#125;class TicketSeller implements Runnable&#123; private static int tikcetNum = 10000;//总共10000张票，放到静态池中共享 @Override public void run() &#123; while(true)&#123; //在循环中使用锁同步，让各个线程进入循环之后进行同步，一个线程把ticketNum--后，其他线程再执行 synchronized(TicketSeller.class)&#123; if(tikcetNum &lt;= 0) break; try &#123; //让线程睡10ms 如果不开启锁同步 就会出现票号为负数的现象 Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + "...这是第" + tikcetNum-- + "号票"); &#125; &#125; &#125;&#125; 死锁问题 线程A和线程B相互等待对方持有的锁导致程序无限死循环下去 线程A持有锁H并且想获取锁W，此时线程B持有锁W并且想获取锁H，那么这两个线程AB就会永远等待下去，产生最简单的死锁。 一个类可能发生死锁，并不意味着每次都会发生，往往在高并发、高负载的情况下，死锁出现概率高很多。 多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁 写一个死锁程序 哲学家进餐问题，使用同步代码块嵌套，互相先持有对方需要的锁对象 写一个死锁程序步骤： 定义两个对象分别代表两个线程一开始就持有的锁对象 在run方法中使用 synchronized 同步代码块嵌套 外层synchronized锁对象是对方所需求的，自己所持有的，内层synchronized锁对象是对方所持有，自己所需要的 。 当一个线程中的锁对象是自己持有的，还未走出外层代码块，需要对方所持有的锁对象时，cpu调度到了另一个线程，另一个线程正好也是这种情况，此时双方都持有了对方所需要的锁对象，发生了死锁。 1234567891011121314151617181920212223242526272829303132333435public class DeadLockTest &#123; private static String left = "left one"; private static String right = "right one"; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; while(true)&#123; synchronized (right)&#123; System.out.println(Thread.currentThread().getName()+"--持有了right,想得到left"); synchronized(left)&#123; System.out.println(Thread.currentThread().getName()+"--得到了left,可以开吃了"); &#125; &#125; &#125; &#125;).start(); new Thread(() -&gt; &#123; while(true)&#123; synchronized (left)&#123; System.out.println(Thread.currentThread().getName()+"--持有了left,想得到right"); synchronized(right)&#123; System.out.println(Thread.currentThread().getName()+"--得到了right,可以开吃了"); &#125; &#125; &#125; &#125;).start(); /* Thread-1--持有了left,想得到right Thread-0--持有了right,想得到left 执行到此时，就会发现这两个线程的锁对象谁都不想放，就会产生死锁。 */ &#125;&#125; 结果： 123上方结果省略....Thread-1--持有了left,想得到rightThread-0--持有了right,想得到left 执行到此时，就会发现这两个线程的锁对象谁都不想放，就会产生死锁。 避免死锁的方式 注意和减少同步代码块嵌套问题 设计时考虑清楚锁的顺序，尽量减少嵌套加锁交互数量 由于死锁是因为两个或多个线程之间无限时间等待对方持有的锁对象而形成的，那么给同步代码块加个等待时间限制。 synchronized 关键字 不具备这个功能，使用Lock类中的tryLock方法，指定一个超时时限，在等待时，若超过该时限，就返回一个失败信息结束阻塞。 单例模式的线程安全问题单例模式 单例设计模式：保证一个类在内存中只有一个对象，内存唯一。 保证类在内存中只有一个对象： 1、控制类的创建，不让其他类来创建本类的对象，将本类的构造函数私有private 2、在本类中定义一个本类的对象，并且外界无法修改。 3、在本类中提供一个唯一的公共访问方法，可获取本类的对象。 饿汉式 在类中直接创建一个不可修改的对象引用，不管有没有调用，都创建，空间换时间。 饿汉式在多线程环境下是线程安全的。 123456789101112class Singleton &#123; //1.将本类的构造函数私有private private Singleton ()&#123;&#125; //2. 在本类中定义一个本类的对象，并且外界无法修改。 private static Singleton s = new Singleton(); //3. 在本类中提供一个唯一的公共访问方法，可获取本类的对象 //饿汉式 public static Singleton getInstance()&#123; return s ; &#125;&#125; 另一种饿汉式，利用final直接修饰 1234567class Singleton &#123; //1.将本类的构造函数私有private private Singleton ()&#123;&#125; //2. 在本类中定义一个本类的对象，并且外界无法修改。 public final static Singleton s = new Singleton() ;&#125; 懒汉式 在类中获取对象时加以判断，为空时才创建，即用到该类对象时才创建，时间换空间。 懒汉式单例模式在多线程下是非线程安全的。 当线程A判断为null时，正准备new，此时，被另一个线程B抢占了CPU资源，线程B也判断为null，new了之后，第一个线程A又抢回了CPU资源，此时线程A又new了。此时这两个线程就new了两次，就不是唯一的内存引用了。 1234567891011121314class Singleton &#123; //1.将本类的构造函数私有private private Singleton ()&#123;&#125; //2. 在本类中定义一个本类的对象，并且外界无法修改。 private static Singleton s ; //3. 在本类中提供一个唯一的公共访问方法，可获取本类的对象 //懒汉式 对象引用为空 才创建， public static Singleton getInstance()&#123; //用到时创建，用不到时不创建 if(s == null) s = new Singleton() ; return s; &#125;&#125; 饿汉式和懒汉式的区别 线程安全上： 饿汉式线程安全，多线程下也不会创建多个对象 懒汉式非线程安全，多线程下可能会创建多个对象 执行效果： 饿汉式是 空间换时间，执行速度快。 懒汉式是 时间换空间，延迟加载。]]></content>
      <categories>
        <category>JavaSE回顾</category>
      </categories>
      <tags>
        <tag>Java多线程</tag>
        <tag>线程安全</tag>
        <tag>死锁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8-Lambda表达式-函数式接口]]></title>
    <url>%2F2018%2F05%2F13%2FJava%E5%86%85%E7%BD%AE%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1. Java内置的四大核心函数式接口12345678Consumer&lt;T&gt; 消费型接口 消费对象 void accept(T t);Supplier&lt;T&gt; 供给型接口 生成对象 T get();Function&lt;R,T&gt; 函数型接口 指定特定功能 R apply(T t);Predicate&lt;T&gt; 断言型接口 进行条件判断 boolean test(T t); 1.1. 消费型接口 void accept(T t);Consumer 消费型接口 12345678910111213// Consumer&lt;T&gt; 消费型接口 @Test public void testConsumer()&#123; //此时的（d） 小括号里有参数 //原因是因为 Consumer接口有参数 //void accept(T t); consume(1000,(d)-&gt; System.out.println(d)); &#125; public void consume(Integer n , Consumer&lt;Integer&gt; con)&#123; //函数接口接收 消费 形参n con.accept(n); &#125; 1.2. 供给型接口 Supplier 供给型接口 T get(); 小括号无参数 1234567891011121314151617181920// Supplier&lt;T&gt; 供给型接口 @Test public void testSupplier()&#123; //T get(); 小括号无参数 List&lt;Integer&gt; numList = getNumList(10,() -&gt; (int)(Math.random()*101)); for ( Integer i: numList ) &#123; System.out.println(i); &#125; &#125; //调用此方法时，第二个参数提供一个数字集合 public List&lt;Integer&gt; getNumList(int n, Supplier&lt;Integer&gt; sup)&#123; List&lt;Integer&gt; numList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; n; i++)&#123; numList.add(sup.get()); //通过get方法得到数字 存到numList &#125; return numList; &#125; 1.3. 函数型接口 Function&lt;R,T&gt; 函数型接口 特定功能 12345678910111213//Function&lt;R,T&gt; 函数型接口 特定功能 @Test public void testFunction()&#123; //将字符串转成大写 String str1 = strHandler("ghslkajh", (s) -&gt; s.toUpperCase()); System.out.println(str1); &#125; // Function&lt;R,T&gt; 函数型接口 //定义一个处理字符串功能型接口函数 public String strHandler(String str, Function&lt;String,String&gt; fun)&#123; return fun.apply(str); &#125; 1.4. 断言型接口 Predicate boolean test(T t); 返回boolean 123456789101112131415161718192021222324//断言型接口 Predicate&lt;T&gt; // boolean test(T t); 返回boolean @Test public void testPredicate()&#123; //返回长度大于3的字符串 List&lt;String&gt; s1 = strFilter(Arrays.asList("huzhiqi", "adaad", "1231", "414441", "gagsgasg"), (s) -&gt; s.length() &gt; 3); System.out.println(s1); //[huzhiqi, adaad, 1231, 414441, gagsgasg] //返回包含d的字符串 List&lt;String&gt; s2 = strFilter(Arrays.asList("huzhiqi", "adaad", "1231", "414441", "gagsgasg"), (s) -&gt; s.contains("d")); System.out.println(s2); // [adaad] &#125; //使用断言型接口过滤字符串 public List&lt;String&gt; strFilter(List&lt;String&gt; strs, Predicate&lt;String&gt; pred)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); for (String s:strs ) &#123; //利用断言型接口进行指定功能判断 即一个功能性条件判断 if(pred.test(s))&#123; //过滤功能 list.add(s); &#125; &#125; return list; &#125;]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Lambda表达式</tag>
        <tag>函数式接口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8-方法引用和构造器引用]]></title>
    <url>%2F2018%2F05%2F12%2FJava8-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E5%92%8C%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 方法引用 若lambda体中的内容有方法已经实现了，我们可以使用‘方法引用’，可以理解为方法引用是lambda表达式的另外一种表现形式。双冒号形式主要有三种语法格式 使用要求（注意点）： Lambda体中调用方法的参数列表、返回值类型 ，必须要和接口实现方法的参数列表、返回值保持一致 1.1. 对象::实例方法名123456789101112131415//1.1. 对象::实例方法名@Testpublic void test1()&#123; Consumer&lt;String&gt; con = (x) -&gt; System.out.println(x); con.accept("hxh");//hxh Consumer&lt;String&gt; con1 = System.out::println; con1.accept("hxh");//hxh 结果一致 //Consumer&lt;T&gt; 接口中的方法为： void accept(T t); // println()方法实现为： public void println(String x) /** * 此处可以使用方法引用是因为 引用的方法println()的参数列表和返回值的类型 void println(String x) * 与 Consumer&lt;String&gt; 接口实现的方法中的 void accept(String t) 的参数列表和返回值的类型 */&#125; 1.2. 类::静态方法名1234567891011121314@Testpublic void test2()&#123; Supplier&lt;String&gt; sup = () -&gt; new Object().toString(); System.out.println(sup.get()); //java.lang.Object@7d6f77cc Supplier&lt;String&gt; sup1 = new Object()::toString; System.out.println(sup1.get()); // java.lang.Object@6f75e721 Supplier&lt;Double&gt; sup2 = () -&gt; Math.random(); System.out.println(sup2.get()); // 0.3782071825902372 Supplier&lt;Double&gt; sup3 = Math::random; System.out.println(sup3.get()); // 0.1516143754943341&#125; 1.3. 类::实例方法名该类型使用条件： 第一个参数是实例方法的调用者，第二个参数是实例方法的参数 12345678910//类::实例方法名@Testpublic void test3()&#123; //BiPredicate&lt;T,U&gt; 俩参数的断言型接口 BiPredicate&lt;String,String&gt; bp = (x,y) -&gt; x.equals(y); System.out.println(bp.test("hxh","hxh")); //true //(x,y) 括号里俩参数 第一个参数是调用方法对象，第二个参数是方法参数 BiPredicate&lt;String,String&gt; bp1 = String::equals; System.out.println(bp1.test("hxh", "aaj"));//false&#125; 2. 构造器引用 构造器，创建对象，自动匹配类中对应的构造器(参数不定) 需要调用的构造器的参数列表要和函数式接口中的抽象方法参数列表保持一致 语法： ClassName::new; 实体类 Stu1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Stu &#123; private Integer id; private String name; private Integer age; public Stu() &#123; &#125; public Stu(Integer id) &#123; this.id = id; &#125; public Stu(Integer id, Integer age) &#123; this.id = id; this.age = age; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Stu&#123;" + "id=" + id + ", name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 测试用例：123456789101112131415161718192021222324@Testpublic void test4()&#123; //无参构造 Supplier&lt;Stu&gt; stuSupplier = ()-&gt; new Stu(); System.out.println(stuSupplier.get()); //自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（无参构造器） Supplier&lt;Stu&gt; stuSupplier1 = Stu::new; System.out.println(stuSupplier1.get()); //Stu&#123;id=null, name='null', age=null&#125; //有一个参数的构造 Function&lt;Integer,Stu&gt; s1 = (x) -&gt; new Stu(x); System.out.println(s1.apply(1)); //Stu&#123;id=1, name='null', age=null&#125; //自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（单个Integer的构造器） Function&lt;Integer,Stu&gt; s2 = Stu::new; System.out.println(s2.apply(2)); //Stu&#123;id=2, name='null', age=null&#125; //有两个参数的构造 BiFunction&lt;T, U, R&gt; R apply(T t, U u); BiFunction&lt;Integer,Integer,Stu&gt; bf = (x,y) -&gt; new Stu(x,y); System.out.println(bf.apply(3,44)); //Stu&#123;id=3, name='null', age=44&#125; //自动匹配类中和接口实现的抽象方法中参数列表一致的构造器（两个个Integer的构造器） BiFunction&lt;Integer,Integer,Stu&gt; bf1 = Stu::new; System.out.println(bf1.apply(4,55));//Stu&#123;id=4, name='null', age=55&#125;&#125; 3. 数组引用 语法： Type[]::new; 123456789//数组引用 Type[]::new@Testpublic void test5()&#123; //创建指定长度的字符串数组 Function&lt;Integer,String[]&gt; f1 = (x) -&gt; new String[x]; System.out.println(f1.apply(10).length); //10 Function&lt;Integer,String[]&gt; f2 = String[]::new;//数组引用 可以直接代替 System.out.println(f2.apply(20).length); //20&#125;]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>方法引用</tag>
        <tag>构造器引用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8-StreamAPI常用知识]]></title>
    <url>%2F2018%2F05%2F11%2FJava8-StreamAPI%2F</url>
    <content type="text"><![CDATA[流（Stream）1. 流的概念 流是数据渠道，用于操作数据源，所生成一种新的元素序列。集合讲的是数据，流讲的是计算,是操作。 Stream是Java8中处理集合的关键抽象概念，它可以指定希望对集合的操作，可以执行复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合的数据进行操作，类似于SQL执行的数据库查询，也可以用来并行执行操作，其提供了一种高效且易于使用的处理数据方式。 注意点： Stream自身不会存储元素 Stream不会改变数据源对象，相反会返回产生一个持有结果的新Stream Steam操作是延迟执行的，这意味着他们会等到需要结果的时候才执行。 2. 流的操作步骤三步走 2.1. 创建Stream获取一个数据源（集合，数组），从而获取一个流产生方式： 2.1.1 通过Collection 系列集合提供的串行流：stream()、并行流： paralleStream()12List&lt;String&gt; list = new ArrayList&lt;&gt;();Stream&lt;String&gt; stream1 = list.stream(); 2.1.2 通过Arrays中的静态方法stream(T[] array) 获取数组流Arrays.stream(T[] array)的源码: 123public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) &#123; return stream(array, 0, array.length); &#125; 用例： 1234567Stu[] stus = new Stu[10];Stream&lt;Stu&gt; stream2 = Arrays.stream(stus);/* public static &lt;T&gt; Stream&lt;T&gt; stream(T[] array) &#123; return stream(array, 0, array.length); &#125; */ 2.1.3 通过Stream类中的静态方法 of()Stream.of() 源码： 12345678910//1.单参泛型of public static&lt;T&gt; Stream&lt;T&gt; of(T t) &#123; return StreamSupport.stream(new Streams.StreamBuilderImpl&lt;&gt;(t), false);&#125;//2.可变参数@SafeVarargs@SuppressWarnings("varargs") // Creating a stream from an array is safepublic static&lt;T&gt; Stream&lt;T&gt; of(T... values) &#123; return Arrays.stream(values);&#125; 用例：1Stream&lt;String&gt; stream3 = Stream.of("hxh", "aj", "hhh"); 2.1.4 使用Stream类的静态方法 iterate 创建无限流iterate方法： Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) 参数 seed 种子起始值，UnaryOperator 函数式接口 继承Function&lt;T,T&gt; 此时参数类型符合返回值类型一致 用例：12345678910111213//4.使用Stream类的静态方法 iterate 创建无限流//Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) //参数 seed 种子起始值，// UnaryOperator 函数式接口 继承Function&lt;T,T&gt; 此时参数类型符合返回值类型一致Stream&lt;Integer&gt; stream4 = Stream.iterate(0, (x) -&gt; x + 2);//中间操作和终止操作stream4.limit(5).forEach(System.out::println);//0//2//4//6//8 2.1.5 使用Stream类的静态方法 generate创建无限流generate方法参数为Supplier&lt;T&gt; 供给型接口 123456789//5.使用Stream类的静态方法 generate 创建无限流//参数为Supplier&lt;T&gt; 供给型接口Stream&lt;Double&gt; generateStream = Stream.generate(() -&gt; Math.random());generateStream.limit(5).forEach(System.out::println);//0.4762976596937549//0.08577913333772513//0.32149010682857515//0.31059489250233197//0.45181354173159927 2.2. 用Stream中间操作一个中间操作链，用Stream API 对数据源数据进行操作处理 注意点： 若只有中间操作，则不会执行 只有终止操作执行后，所有的中间操作一次执行，此时就称为延迟加载或者惰性求值 验证是否是延迟加载： 1234567891011@Testpublic void test2()&#123; //取age&gt;30的Stu元素 //若只有中间操作，则不会执行 Stream&lt;Stu&gt; stuStream = stuList.stream().filter((i) -&gt; &#123; System.out.println(&quot;验证是否是延迟加载&quot;); return i.getAge() &gt; 40; &#125;); //此时只有中间操作，无终止操作，无结果，控制台无输出 &#125; 此时只有中间操作，无终止操作，无结果，控制台无输出。 此时加上终止操作后： 1234567891011@Testpublic void test2()&#123; //取age&gt;30的Stu元素 //若只有中间操作，则不会执行 Stream&lt;Stu&gt; stuStream = stuList.stream().filter((i) -&gt; &#123; System.out.println("验证是否是延迟加载"); return i.getAge() &gt; 40; &#125;); //终止操作 执行后，所有的中间操作一次执行，此时就称为延迟加载或者惰性求值 stuStream.forEach(System.out::println);&#125; 此时结果为： 1234567验证是否是延迟加载验证是否是延迟加载验证是否是延迟加载验证是否是延迟加载Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;验证是否是延迟加载Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125; 结论：若只有中间操作，则不会执行中间操作。终止操作 执行后，所有的中间操作一次执行。最后流中只有经过操作过滤后的元素。 2.2.1 筛选与切片迭代： 内部迭代：迭代过程操作由Stream API 内部自主完成，无需自行再次编写。 外部迭代：由程序编写人员自己通过一些迭代方法进行的迭代操作。 2.2.1.1 filter-过滤Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)断言型接口参数 即条件判断过滤 用例：先创建一个Stu类List集合1234567List&lt;Stu&gt; stuList = Arrays.asList( new Stu(1,"hh",22), new Stu(2,"aa",22), new Stu(3,"bb",32), new Stu(4,"cc",42), new Stu(5,"dd",52)); filter过滤实现：123456//取age&gt;30的Stu元素//若只有中间操作，则不会执行Stream&lt;Stu&gt; stuStream = stuList.stream() .filter((i) -&gt; i.getAge() &gt; 40);//终止操作 执行后，所有的中间操作一次执行，此时就称为延迟加载或者惰性求值stuStream.forEach(System.out::println); 结果：12Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125; 2.2.1.2 limit-限定元素数量limit(n) 通过截断流，使流中元素个数不超过指定数量 12345stuList.stream() .filter((s) -&gt;&#123; System.out.println("测试迭代几次"); return s.getAge()&gt;40; &#125;).limit(1).forEach(System.out::println); 结果： 12345测试迭代几次测试迭代几次测试迭代几次测试迭代几次Stu&#123;id=4, name='cc', age=42&#125; 结果发现：先通过filter()过滤，迭代到想要的过滤结果后，再根据limit(n)，直接截断流，后续操作不继续，限制其流中元素个数为n，此操作称为短路操作，短路操作也用于提高效率； 所以前3次元素不在结果中，但都进行迭代判断，打印了3次后后面的元素再次进行迭代，发现元素满足过滤条件，但limit限制只要一个，即最后一次迭代后直接截断流，结果为第一个满足过滤条件的元素。 2.2.1.3 skip-跳过元素skip(n) 返回一个跳过前n个元素的流，若流中元素不足n个，则返回一个空流。其与limit(n)互补 12345678910//skip(n) 跳过前n个元素stuList.stream() .skip(2).forEach(System.out::println);/* 结果： Stu&#123;id=3, name='bb', age=32&#125; Stu&#123;id=4, name='cc', age=42&#125; Stu&#123;id=5, name='dd', age=52&#125; */stuList.stream().skip(6).forEach(System.out::println);//流中元素个数总数为5，小于6，则返回空流，没有结果值 2.2.1.4 distinct-去重 通过流所生成元素的hashCode()和equals()来去除重复元素 先在stuList中添加几个重复元素用于测试：12345678910List&lt;Stu&gt; stuList = Arrays.asList( new Stu(1,"hh",22), new Stu(2,"aa",22), new Stu(3,"bb",32), new Stu(4,"cc",42), new Stu(4,"cc",42), new Stu(4,"cc",42), new Stu(4,"cc",42), new Stu(5,"dd",52)); 此时的Stu类中没有生成重写hashCode()和equals()方法，测试:12//distinct 去重stuList.stream().distinct().forEach(System.out::println); 但是结果发现，并没有去重:12345678Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125; 此时，在Stu类中生成重写hashCode()和equals()方法： 123456789101112131415@Overridepublic boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Stu stu = (Stu) o; return Objects.equals(id, stu.id) &amp;&amp; Objects.equals(name, stu.name) &amp;&amp; Objects.equals(age, stu.age);&#125;@Overridepublic int hashCode() &#123; return Objects.hash(id, name, age);&#125; 再次测试用例后，发现结果已经去重：12345Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125; 结论： distinct()去重原理为通过流所生成元素的hashCode()和equals()来去除重复元素 2.2.2 映射2.2.2.1 map映射&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) 接收Lambda，将元素转换成其他形式或提取信息。 接收一个Function&lt;? super T, ? extends R&gt; mapper函数作为参数，该函数会被应用到每个元素上，并将其映射到一个新的元素。 123456//map映射List&lt;String&gt; stringList = Arrays.asList("aa", "bb", "cc", "dd");stringList.stream() .map((x)-&gt;x.length()).forEach(System.out::println);stringList.stream() .map((x)-&gt;x.toUpperCase()).forEach(System.out::println); 结果:123456782222AABBCCDD 从结果看出，流中的每个元素都应用了map()里的参数中的Function函数，并返回经过Function处理的元素。 map映射的重要应用为：即类似SQL中的映射，获取对象中的某些属性（即数据库中的某些字段） 例如：获取Stu中的name属性1stuList.stream().map(Stu::getName).forEach(System.out::println); 测试结果：12345678hhaabbccccccccdd 2.2.2.2 flatMap映射 接收一个函数作为参数，将流中的每个值都转换成另一个流，然后把所有流连接成一个流。每个部分流中的每个值成单独小流，再串成一个整体流。 对比map映射： map映射是将集合中的部分流添加到整体流中，而flatMap映射是将集合中的部分流中的每个元素单独一个个地添加到整体流中。 map映射: Stream&lt;Stream&lt;Character&gt;&gt; , flatMap映射：Stream&lt;Character&gt; 测试用例： 写一个函数用于flatMap映射 12345678910111213/** * 字符串拆分成字符后组成一个字符类型的流 * @param str * @return */public static Stream&lt;Character&gt; filterCharacter(String str)&#123; List&lt;Character&gt; characterList = new ArrayList&lt;&gt;(); for (Character ch: str.toCharArray() ) &#123; characterList.add(ch); &#125; return characterList.stream();&#125; 用该函数分别测试map映射类型和flatMap映射类型 12345678910111213141516171819202122232425262728List&lt;String&gt; stringList = Arrays.asList("aa", "bb", "cc", "dd");Stream&lt;Stream&lt;Character&gt;&gt; st1 = stringList.stream() .map(TestStream::filterCharacter);//此时流的内容为 &#123;&#123;"aa"&#125;,&#123;"bb"&#125;,&#123;"cc"&#125;,&#123;"dd"&#125;&#125; 4个单独的字符流对象组成的流st1.forEach(System.out::println);/* 再次遍历后 结果：4个流对象 即 Stream&lt;Character&gt; &#123;&#123;"aa"&#125;,&#123;"bb"&#125;,&#123;"cc"&#125;,&#123;"dd"&#125;&#125; java.util.stream.ReferencePipeline$Head@470e2030 java.util.stream.ReferencePipeline$Head@3fb4f649 java.util.stream.ReferencePipeline$Head@33833882 java.util.stream.ReferencePipeline$Head@200a570f */System.out.println("----------------");Stream&lt;Character&gt; st2 = stringList.stream().flatMap(TestStream::filterCharacter);//此时流的内容为&#123;"a","a","b","b","c","c","d","d"&#125;st2.forEach(System.out::println);/* 再次遍历后 结果直接返回了单个的字符流 a a b b c c d d */ 2.2.3 排序2.2.3.1 自然排序sorted() 自然排序(Comparable方式)，按照字典顺序进行排序 按照实现的Comparable中的compare to()方法 1234List&lt;String&gt; stringList = Arrays.asList("ee", "bb", "ff", "dd","哈哈","啊");//根据String类中Comparable方式进行默认排序，即compare to()方法stringList.stream() .sorted().forEach(System.out::println); 结果：123456bbddeeff哈哈啊 2.2.3.2 指定排序sorted(Comparator com) 根据实现Comparator接口的指定方法进行排序 123456789stuList.stream().sorted( (a,b) -&gt;&#123; if (a.getAge().equals(b.getAge()))&#123; return a.getName().compareTo(b.getName()); &#125;else&#123; return a.getAge().compareTo(b.getAge()); &#125; &#125; ).forEach(System.out::println); 2.3. 终止Stream操作终止操作，执行中间链操作，并产生结果 2.3.1. 查找与匹配 匹配 match 利用断言型函数接口，返回boolean值 是否匹配 查找返回容器类 Optional类型 避免空指针异常 2.3.1.1 allMatch-检查是否匹配所有元素返回结果： true 匹配到了所有的元素 注意：和noneMatch()的false 结果代表集合不同 false 没有匹配到所有的元素 说明匹配到条件集合中的真子集 1234567891011boolean b = stuList.stream() .allMatch((e) -&gt; e.getAge() &gt; 20);System.out.println(b);//trueboolean b1 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 20);System.out.println(b1);//flaseboolean b2 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 40);System.out.println(b2);//flase 2.3.1.2 anyMatch-检查是否至少匹配一个元素返回结果： true 匹配到了条件集合中的真子集元素，一个或者多个 false 一个元素都没有匹配到，空集1234567boolean hhh = stuList.stream() .anyMatch((e) -&gt; e.getName().equals("hhh"));System.out.println(hhh);//falseboolean hh = stuList.stream() .anyMatch((e) -&gt; e.getName().equals("hh"));System.out.println(hhh);//true 2.3.1.3 noneMatch-检查是否所有元素都没有匹配到返回结果： true 所有元素都没有匹配到，空集 false 不是所有的元素都没有匹配到 即匹配到了元素,有匹配到的元素即返回false，真子集123456789101112131415boolean b1 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 20);System.out.println(b1);//flaseboolean b2 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 40);System.out.println(b2);//flaseboolean b3 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 50);System.out.println(b3);//此时集合中只有一个元素能匹配到，返回了falseboolean b4 = stuList.stream() .noneMatch((e) -&gt; e.getAge() &gt; 60);System.out.println(b3);//所有的元素都没有匹配到 返回了true 2.3.1.4 findFirst-返回第一个元素Optional&lt;T&gt; findFirst(); 12Optional&lt;Stu&gt; first = stuList.stream().findFirst();System.out.println(first.get());// Stu&#123;id=1, name='hh', age=22&#125; 返回第一个元素，用Optional集合类来封装，避免了空指针异常 2.3.1.5 findAny-返回当前流中的任意一个元素Optional&lt;T&gt; findAny(); 1234567//从集合中随便找个age&gt;30的Stu对象 可以使用串行流stream,也可以使用parallelStream 并行流Optional&lt;Stu&gt; any = stuList.parallelStream() .filter((e) -&gt; e.getAge() &gt; 30).findAny();System.out.println(any.get());//Stu&#123;id=4, name='cc', age=42&#125;Optional&lt;Stu&gt; any1 = stuList.stream() .filter((e) -&gt; e.getAge() &gt; 30).findAny();System.out.println(any1.get());//Stu&#123;id=3, name='bb', age=32&#125; 2.3.1.6 count-返回流中元素总个数long count(); 12long count = stuList.stream().count();System.out.println(count);//8 2.3.1.7 max-返回流中的最大值Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator); 123456789//根据年龄大小进行正序排序找出最大值Optional&lt;Stu&gt; max = stuList.parallelStream() .max((a, b) -&gt; Integer.compare(a.getAge(), b.getAge()));System.out.println(max.get()); //Stu&#123;id=5, name='dd', age=52&#125;//根据年龄大小进行倒序排序找出最大值Optional&lt;Stu&gt; max1 = stuList.parallelStream() .max((a, b) -&gt; Integer.compare(b.getAge(), a.getAge()));System.out.println(max1.get()); //Stu&#123;id=1, name='hh', age=22&#125; 12345//提取最大年龄 先映射提取集合中每个对象的年龄 再直接进行max方法比较 最后返回一个年龄值Optional&lt;Integer&gt; maxAge = stuList.parallelStream() .map(Stu::getAge) .max(Integer::compare);System.out.println(maxAge.get()); //52 2.3.1.8 min-返回流中的最小值Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator); 123456789//根据年龄大小进行正序排序找出最小值Optional&lt;Stu&gt; min = stuList.parallelStream() .min((a, b) -&gt; Integer.compare(a.getAge(), b.getAge()));System.out.println(min.get());//Stu&#123;id=1, name='hh', age=22&#125;//根据年龄大小进行倒序排序找出最小值Optional&lt;Stu&gt; min1 = stuList.parallelStream() .min((a, b) -&gt; Integer.compare(b.getAge(), a.getAge()));System.out.println(min1.get()); //Stu&#123;id=5, name='dd', age=52&#125; 2.3.2. 归约与收集2.3.2.1 reduce-将流中元素反复结合起来，得到一个值12345List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);//利用reduce归约函数，可以指定归约规则，将集合中的元素数值进行求和操作等//以0为起始值，对集合中的各个值进行相加Integer sum = list.stream().reduce(0, (x, y) -&gt; x + y);System.out.println(sum);//45 12345678//求出stuList集合中的年龄总和//此时利用Integer类中的静态方法sum求和 无起始值，有可能为空，// 则返回值自动变为Optional容器类封装过后的值Optional&lt;Integer&gt; ageSumOp = stuList.stream() .map(Stu::getAge) .reduce(Integer::sum);System.out.println(ageSumOp.get());//296 此时利用Integer类中的静态方法sum求和 无起始值,有可能为空，则返回值自动变为Optional容器类封装过后的值 2.3.2.2 collect-将流转换为其他形式 接收一个Collector接口的实现，用于Stream中元素做汇总的方法 利用Collectors实用工具类中提供的很多静态实现Collector接口的方法，进行相应的转换收集操作。 1234567891011121314151617181920212223242526//收集stuList集合中的所有name值，转换为list集合List&lt;String&gt; nameList = stuList.stream().map(Stu::getName) .collect(Collectors.toList());nameList.forEach(System.out::println);/* 结果： hh aa bb cc cc cc cc dd *///获取年龄转化成set集合 去掉了重复值Set&lt;Integer&gt; ageSet = stuList.stream().map(Stu::getAge) .collect(Collectors.toSet());ageSet.forEach(System.out::println);/* 结果： 32 52 22 42 */ 如果想转换成其他没有的现成静态方法的数据结构集合，就使用Collectors.toCollection()方法，该方法具体参数和返回值为：Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory) 使用Collectors.toCollection(HashSet::new)方法 转换成HashSet集合,该方法参数为Supplier供给型函数接口，传给一个构造函数， 用例如下： 123456789101112//使用`Collectors.toCollection()`方法 转换成`其他没有的现成静态方法`的数据结构集合 比如HashSetHashSet&lt;String&gt; nameHashSet = stuList.stream().map(Stu::getName) .collect(Collectors.toCollection(HashSet::new));nameHashSet.forEach(System.out::println);/* result: hh aa bb cc dd */ 2.3.3. Collectors类中的常用方法2.3.3.1 counting-统计数量Long count() 统计元素个数123Long count = stuList.stream() .collect(Collectors.counting());System.out.println(count);//8 2.3.3.2 averagingDouble-求平均值并转换成Double类型&lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? super T&gt; mapper) &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? super T&gt; mapper) &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? super T&gt; mapper) 测试用例：求年龄的平均值123Double ageAve = stuList.stream() .collect(Collectors.averagingDouble(Stu::getAge));System.out.println(ageAve);//37.0 2.3.3.3 summingDouble-求和并转换成Double类型&lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? super T&gt; mapper) &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? super T&gt; mapper) &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? super T&gt; mapper) 测试用例：求年龄之和123Double ageSum = stuList.stream() .collect(Collectors.summingDouble(Stu::getAge));System.out.println(ageSum);//296.0 2.3.3.4 maxBy-根据函数条件求最大值&lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? super T&gt; comparator) 测试用例：根据年龄找出最大年龄值的stu对象1234//根据年龄找出最大年龄值的stu对象Optional&lt;Stu&gt; stuOptional = stuList.stream() .collect(Collectors.maxBy((a, b) -&gt; Double.compare(a.getAge(), b.getAge())));System.out.println(stuOptional.get());//Stu&#123;id=5, name='dd', age=52&#125; 2.3.3.5 groupingBy-分组 单级分组 &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier) 测试用例：根据年龄分组1234//根据年龄分组Map&lt;Integer, List&lt;Stu&gt;&gt; ageGroup = stuList.stream() .collect(Collectors.groupingBy(Stu::getAge));System.out.println(ageGroup); 结果：1234&#123;32=[Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;],52=[Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125;],22=[Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;, Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;],42=[Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;]&#125; 多级分组 两个参数，第二个参数为Collector，即实现无限分组&lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier, Collector&lt;? super T, A, D&gt; downstream) 先根据name分组，再根据年龄分组123456789101112//先根据name分组，再根据年龄分组Map&lt;String, Map&lt;String, List&lt;Stu&gt;&gt;&gt; groupmap = stuList.stream() .collect(Collectors.groupingBy(Stu::getName, Collectors.groupingBy((e) -&gt; &#123; if (e.getAge() &lt;= 20) &#123; return "年轻人"; &#125; else if (e.getAge() &lt;= 50) &#123; return "中年人"; &#125; else &#123; return "老年人"; &#125; &#125;)));System.out.println(groupmap); 结果：12345&#123;dd=&#123;老年人=[Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125;]&#125;, cc=&#123;中年人=[Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;]&#125;, bb=&#123;中年人=[Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125;]&#125;, aa=&#123;中年人=[Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;]&#125;, hh=&#123;中年人=[Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;]&#125;&#125; 2.3.3.6 partitioningBy-分区满足条件的分到一个区，不满足条件分到另一个区 true , false Map&lt;Boolean,List&lt;&gt;&gt; 测试用例：是否年龄大于40，分两个区123Map&lt;Boolean, List&lt;Stu&gt;&gt; booleamGroup = stuList.stream() .collect(Collectors.partitioningBy((e) -&gt; e.getAge() &gt; 40));System.out.println(booleamGroup); 结果：1234567891011121314&#123; false=[ Stu&#123;id=1, name=&apos;hh&apos;, age=22&#125;, Stu&#123;id=2, name=&apos;aa&apos;, age=22&#125;, Stu&#123;id=3, name=&apos;bb&apos;, age=32&#125; ], true=[ Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=4, name=&apos;cc&apos;, age=42&#125;, Stu&#123;id=5, name=&apos;dd&apos;, age=52&#125; ]&#125; 2.3.3.7 summarizingDouble-计算方法总括函数&lt;T&gt; Collector&lt;T, ?, DoubleSummaryStatistics&gt; summarizingDouble(ToDoubleFunction&lt;? super T&gt; mapper) summarizingDouble返回 DoubleSummaryStatistics 类型 可以直接调用各种计算方法 summarizingInt summarizingLong 实例：1234567DoubleSummaryStatistics ageSummaryStatis = stuList.stream() .collect(Collectors.summarizingDouble(Stu::getAge));ageSummaryStatis.getAverage();ageSummaryStatis.getCount();ageSummaryStatis.getMax();ageSummaryStatis.getMin();ageSummaryStatis.getSum(); 2.3.3.7 joining-连接字符串Collector&lt;CharSequence, ?, String&gt; joining() 测试用例：将stuList集合中所有的名字连接在一起1234//将集合中所有的名字连接在一起String allNameStr = stuList.stream().map(Stu::getName) .collect(Collectors.joining());System.out.println(allNameStr);//hhaabbccccccccdd 测试用例：将stuList集合中所有的名字连接在一起，并使用逗号分割 12345 //将集合中所有的名字连接在一起,并逗号分割String allNameStr1 = stuList.stream().map(Stu::getName) .collect(Collectors.joining(","));System.out.println(allNameStr1);//hh,aa,bb,cc,cc,cc,cc,dd 2.3.3.8 toList- 返回集合1List kcResList = kcResInKkxyList.stream().filter((e) -&gt; kssj.equals(e.getKssj())).collect(Collectors.toList());]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>StreamAPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8-Lambda表达式基础知识]]></title>
    <url>%2F2018%2F05%2F11%2FLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Lambda表达式 Lambda是一个匿名函数，我们可以把Lambda表达式理解为是一段可以传递的代码（将代码像数据一样进行传递），其可以代替实现接口中的抽象方法时的书写匿名内部类的繁琐代码。 举个栗子： Java中有个Runnable接口，直接使用该接口，需要重写实现其接口内部中的抽象方法。如下： 1234567Runnable run = new Runnable() &#123; @Override public void run() &#123; System.out.println("old run"); &#125;&#125;;run.run(); 该代码可以使用lambda表达式简化为：12Runnable run1 = () -&gt; System.out.println("lambda run");run1.run(); 1. 基础语法 java8中引入了一个新的操作符”-&gt;”，该操作符称为箭头操作符或Lambda操作符，该箭头符号将整个Lambda表达式拆分成两部分： 左侧：Lambda表达式的参数列表，即接口中对应抽象方法的参数列表。 右侧：Lambda表达式中所需要执行的功能，即Lambda表达式体。即需要实现的抽象方法的功能体。 1.1. 语法格式一 无参数,无返回值 对应格式为: () -&gt; 方法体… 括号内无参数 例如:() -&gt; Sysout… 12345678910111213141516171819@Testpublic void test1 ()&#123; //无参数 , 无返回值 对应格式为: () -&gt; 方法体... 括号内无参数 Runnable run = new Runnable() &#123; @Override public void run() &#123; System.out.println("old run"); &#125; &#125;; run.run(); System.out.println("-----------"); Runnable run1 = () -&gt; System.out.println("lambda run"); run1.run();&#125;/*result: old run ----------- lambda run*/ 1.2. 语法格式二 有一个参数,无返回值 对应语法格式为 (x) -&gt; 无返回值的方法体 例如: (x) -&gt; System.out.println(x) 若有且只有一个参数,左侧的小括号可以省略不写 例如: x -&gt; System.out.println(x) 12345678910111213141516// 有一个参数 , 无返回值@Testpublic void test2()&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); Consumer&lt;String&gt; consumer = (s) -&gt; list.add(s);//将consumer接收到的对象进行具体的功能的消费 consumer.accept("ddd"); consumer.accept("aaa"); consumer.accept("ccc"); list.forEach(System.out::println); /* Result: ddd aaa ccc */&#125; 1.3. 语法格式三 有两个或两个以上参数,有返回值 有两个或两个以上参数,有返回值,并且 lambda 体中有多条语句 12345678910111213语法为: (x,y) -&gt; &#123; 方法体 return 返回值&#125;多条语句必须使用大括号包括在内,有返回值,需要使用return 返回返回值. Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123; System.out.println(&quot;x为&quot;+x); System.out.println(&quot;y为&quot;+y); return Integer.compare(x,y); &#125;; 123456789101112如果lambda体中只有一条语句,那么大括号&#123;&#125;可以省略,return关键字也可以省略例如: Comparator&lt;Integer&gt; com = (x,y) -&gt; &#123; return Integer.compare(x,y);&#125;就可以简写成:Comparator&lt;Integer&gt; com = (x,y) -&gt; Integer.compare(x,y); 12345678 Lambda表达式的参数列表的 数据类型可以省略不写,因为JVM编译器可以通过上下文推断出数据类型,即&apos;类型推断&apos;.即: (Integer x,Integer y) -&gt; Integer.compare(x,y);简化成:(x,y) -&gt; Integer.compare(x,y); 123456789101112@Testpublic void test3()&#123; Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123; System.out.println("x为"+x); System.out.println("y为"+y); return Integer.compare(x,y); &#125;; System.out.println(com.compare(1111,111)); // x为1111 // y为111 // 1&#125; 利用用Java内置的Comparator接口（比较器）比较两个字符串的长度，可用lambda表达式表示为： 使用Lambda表达式直接进行该接口的核心方法体的重写 1234567891011121314//使用Lambda表达式直接进行该接口的核心方法体的重写Comparator&lt;String&gt; com1 = (x,y) -&gt; &#123; if(x.length() == y.length())&#123; return 0; &#125;else&#123; if(x.length() &gt; y.length())&#123; return 1; &#125;else return -1; &#125;&#125;;System.out.println(com1.compare("aa","aaaaa"));// -1 2. 函数式接口 Lambda表达式需要函数式接口的支持 函数式接口定义: 接口中只有一个抽象方法的接口,称为函数式接口。 可以使用注解 @FuncitonalInterface 修饰，其修饰作用为：限定该接口必须为函数式接口,即该接口中有且只有一个抽象方法。否则无法通过编译。即可以检查是否为函数式接口。 2.1. 自定义一个函数式接口：1234@FunctionalInterfacepublic interface Operation&lt;T,R&gt; &#123; public R operation(T t1, T t2);&#125; 2.1.1 方案一：写具体实现方法再直接使用12345678public void op (Long l1, Long l2, Operation&lt;Long,Long&gt; operation)&#123; System.out.println(operation.operation(l1,l2)); &#125;@Testpublic void testMyOperation()&#123; op(10l,10l,(x,y) -&gt; x*y);//100 op(100l,200l,(x,y)-&gt; x+y);//300&#125; 2.1.2 方案二： 先使用lambda表示具体实现方法体，再进行接口中的方法调用，传入具体值：12345@Testpublic void testMyOperation()&#123; Operation&lt;Integer,Integer&gt; op = (x,y) -&gt; x*y; System.out.println(op.operation(10,10)); //100&#125; 实际使用时，大多数情况下直接使用Java8内置四大函数式接口，并不要进行自己写函数式接口。]]></content>
      <categories>
        <category>Java8</category>
      </categories>
      <tags>
        <tag>Java8</tag>
        <tag>Lambda表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git基础知识]]></title>
    <url>%2F2018%2F04%2F03%2FGit%2F</url>
    <content type="text"><![CDATA[一、Git1. Git的常用操作1.1 本地库初始化 进入自己创建的git仓库目录下，使用命令git init 123hxhaaj@DESKTOP-CP80SC0 MINGW64 /d/code/GitSpace/testGit (master)$ git initInitialized empty Git repository in D:/code/GitSpace/testGit/.git/ 此时就会提示在该目录下初始化了一个空的Git仓库 Initialized empty Git repository in D:/code/GitSpace/testGit/.git/ 使用命令ll -la 显示所有含有隐藏目录.git 查看.git/目录下的目录结构： 123456789$ lltotal 7-rw-r--r-- 1 hxhaaj 197121 130 6月 22 17:12 config-rw-r--r-- 1 hxhaaj 197121 73 6月 22 17:12 description-rw-r--r-- 1 hxhaaj 197121 23 6月 22 17:12 HEADdrwxr-xr-x 1 hxhaaj 197121 0 6月 22 17:12 hooks/drwxr-xr-x 1 hxhaaj 197121 0 6月 22 17:12 info/drwxr-xr-x 1 hxhaaj 197121 0 6月 22 17:12 objects/drwxr-xr-x 1 hxhaaj 197121 0 6月 22 17:12 refs/ 1.2 设置签名1.2.1 项目级/仓库级别签名 仅仅在当前本地库范围内有效 命令：git config user.name xxx 设置项目级用户名称 命令：git config user.email xxx 设置项目级用户email 信息保存在 .git/config文件中 1.2.2 系统用户级签名 登录当前操作系统的用户范围 命令：git config --global user.name xxx 设置系统用户级用户名称 命令：git config --global user.email xxx 设置系统用户级用户email 签名信息保存在 系统用户目录下的 ~/.gitconfig文件中 1234$ cat .gitconfig[user] name = hxhaaj_glb email = hxhaaj_glb@163.com 1.2.3 级别优先级 项目级别优先于系统用户级别，二者都有时采用项目级别的签名 如果只有系统用户级别的签名，就以系统用户级别的签名为准 二者都没有不允许这种情况 1.3 基本操作 1.3.1 状态查看操作命令： git status 查看工作区、暂存区状态1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) t1.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 1.3.2 添加操作git add [file name]将工作区的新建或者修改后的文件添加到暂存区1$ git add t1.txt 执行后，查看状态：123456789$ git statusOn branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: t1.txt 1.3.3 暂存区删除操作git rm --cache [filename]将暂存区中的文件，移除暂存区，避免误添加操作12$ git rm --cached t1.txtrm &apos;t1.txt&apos; 删除后，回到原状态：查看状态：1234567891011$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) t1.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 1.3.4 提交操作命令： git commit 将暂存区的内容提交到本地库 提交并直接写入本次提交提示信息 git commit -m &quot;xxx提交提示信息&quot; [文件名] 12345$ git commit -m &quot;new file t1 and insert some ..&quot; t1.txtwarning: LF will be replaced by CRLF in t1.txt.The file will have its original line endings in your working directory.[master b4b7b3e] new file t1 and insert some .. 1 file changed, 3 insertions(+) 1.3.5 查看日志git log 最完整的形式123456789101112$ git logcommit b4b7b3ecb73218f06a882363ea8982e78aea59b6 (HEAD -&gt; master)Author: hxhaaj &lt;hxhaaj@163.com&gt;Date: Fri Jun 22 22:33:57 2018 +0800 new file t1 and insert some ..commit 55afec262bc7db58f8307f788dc57f3118e0d3d1Author: hxhaaj &lt;hxhaaj@163.com&gt;Date: Fri Jun 22 22:28:49 2018 +0800 new t1` git log --pretty=oneline 以一条信息一行的简洁状态显示日志123$ git log --pretty=onelineb4b7b3ecb73218f06a882363ea8982e78aea59b6 (HEAD -&gt; master) new file t1 and insert some ..55afec262bc7db58f8307f788dc57f3118e0d3d1 new t1` git log --oneline 哈希值简短显示的简洁状态 更简洁 只显示过去版本123$ git log --onelineb4b7b3e (HEAD -&gt; master) new file t1 and insert some ..55afec2 new t1` git reflog 增加了头指针移动次数信息 HEAD@{x} x为移动到当前版本需要的次数 常用，新老版本都能全部显示123$ git reflogb4b7b3e (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: new file t1 and insert some ..55afec2 HEAD@&#123;1&#125;: commit (initial): new t1` 多屏显示控制方式： 空格向下翻页 b向上翻页 q退出 1.3.6 前进后退 本质：根据最新版本为HEAD指针，即HEAD指针到旧版本所需要移动的次数,如下HEAD@{0}为最新版本 12b4b7b3e (HEAD -&gt; master) HEAD@&#123;0&#125;: commit: new file t1 and insert some ..55afec2 HEAD@&#123;1&#125;: commit (initial): new t1` 基于索引值操作（推荐）git reset --hard [局部索引值(55afec2)]回到或者前进到索引值代表的那个版本 12$ git reset --hard 55afec2HEAD is now at 55afec2 new t1` 此时回到了55afec2这个版本，再使用 git reflog 查看日志1234$ git reflog55afec2 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 55afec2b4b7b3e HEAD@&#123;1&#125;: commit: new file t1 and insert some ..55afec2 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): new t1` 使用 ^ 符号形式 只能后退git reset --hard HEAD[^]一个^符号，退一个版本，n个^符号，退n个版本 12$ git reset --hard HEAD^HEAD is now at 55afec2 new t1` 使用 ~ 符号形式git reset --hard HEAD~n n代表后退多少步，同样也只能后退 1.3.7 reset命令的三个参数对比 --soft 参数仅仅在本地库移动HEAD指针 --mixed 参数在本地库移动HEAD指针，重置暂存区 --hard 参数在本地库移动HEAD指针，重置暂存区，重置工作区 1.3.7 删除文件并找回 前提：删除前，文件存在时的状态提交到了本地库。 命令：git reset --hard [指针位置]删除操作已经提交到本地库：指针位置指向历史记录删除操作没有提交到本地库：指针位置使用HEAD 1.3.8 比较文件差异 git diff [文件名]不带参数，将工作区中的文件和暂存区进行比较 git diff[本地库中历史版本] [文件名]将工作区中的文件和本地库历史记录进行比较git diff HEAD t1.txtgit diff HEAD^ t1.txt 不指定文件名，比较多个文件 1.4 分支1.4.1 分支的好处 同时并行推进多个功能开发，提高开发效率 各个分支在开发过程中，如果某个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。 1.4.2 分支操作 创建分支git branch [分支名] 查看分支git branch -v 切换分支git checkout [分支名] 合并分支第一步：切换到接受修改的分支（被合并的，增加新内容的分支）上git checkout [被合并分支名]第二步：执行merge命令git merge [有新内容的分支名] 解决冲突 合并后有冲突的分支的表现： 解决方式： 第一步：编辑文件，删除特殊符号 第二步：把文件修改到满意的程序，去掉冲突，保存退出 第三步：git add [文件名] 第四步：git commit -m &quot;日志信息&quot; 注意点：此时commit 一定不能带具体文件名 2. Git的基本原理2.1 哈希哈希是一系列的加密算法，各个不同的哈希算法虽然加密强度不同，但是有以下几个共同点： 不管输入数据的数据量有多大，输入同一个哈希算法，得到加密结果长度固定。 哈希算法确定，输入数据确定，输出数据能够保证不变。 哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大 哈希算法是不可逆的 Git底层采用的是SHA-1算法。 哈希算法常常被用来验证文件的完整性，确定性。 Git底层就是根据这种验证机制保证了数据的完整性。 2.2 Git保存版本的机制2.2.1 集中式版本控制工具的文件管理机制 以文件变更列表的方式存储信息。这类系统将他们保存的信息看做是一组基本文件和每个文件随时间逐步累积的差异。 2.2.2 Git的文件管理机制 Git把数据看做是小型文件系统的一组快照。每次提交更新时Git都会对当前的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git不再重新存储该文件，而是只保留一个链指向之前存储的文件。所以Git的工作方式可以称之为快照流。 2.2.3 Git文件管理机制细节 Git的“提交对象“ 提交对象及其父对象所形成的链条 2.3 Git分支管理机制2.3.1 分支的创建 2.3.1 分支的切换实质上是指针指向的对象变了，改变指针的指向，快速做到切换。 仅仅移动了指针，切换了版本 此时开始有了分支，都基于f30ab版本 所有操作都是基于链条指针的移动和切换。 3. Git的远程操作3.1 在本地初始化本地仓库，将文件提交到本地库3.2 在远程代码托管中心创建好仓库3.3 在git上给远程仓库地址起个别名 起别名：git remote add [别名] [仓库地址] 1$ git remote add git_note https://github.com/hxhaaj/Git_note.git 查看远程仓库信息以及别名：git remote -v 123$ git remote -vgit_note https://github.com/hxhaaj/Git_note.git (fetch)git_note https://github.com/hxhaaj/Git_note.git (push) 3.4 推送到远程库git push [仓库地址别名] [创建的分支名] 测试后，弹出登陆窗口，登陆后显示提交进度。 12345678$ git push git_note masterCounting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (19/19), done.Writing objects: 100% (20/20), 829.22 KiB | 12.02 MiB/s, done.Total 20 (delta 0), reused 0 (delta 0)To https://github.com/hxhaaj/Git_note.git* [new branch] master -&gt; master 3.5 克隆远程库git clone [远程库地址] 123456$ git clone https://github.com/hxhaaj/Git_note.gitCloning into &apos;Git_note&apos;...remote: Counting objects: 23, done.remote: Compressing objects: 100% (22/22), done.remote: Total 23 (delta 1), reused 19 (delta 0), pack-reused 0Unpacking objects: 100% (23/23), done. 克隆的效果 完整的把远程库下载到了本地 创建了远程地址别名 初始化了本地库，一条龙解决3.6 邀请他人加入团队后，其才可以进行推送写入仓库 3.7 pull拉取操作 pull = fetch + merge 即为pull操作是fetch操作和merge操作的组合，仅仅是fetch操作，不改变本地库，merge操作之后改变本地库里的文件 git fetch [远程库地址别名][远程分支名] 12345678$ git fetch git_note masterremote: Counting objects: 6, done.remote: Compressing objects: 100% (5/5), done.remote: Total 6 (delta 2), reused 3 (delta 1), pack-reused 0Unpacking objects: 100% (6/6), done.From https://github.com/hxhaaj/Git_note * branch master -&gt; FETCH_HEAD 8228eff..aeda745 master -&gt; git_note/master git merge [远程库地址别名]/[远程分支名] 12345$ git merge git_note/masterUpdating 8228eff..aeda745Fast-forward Git.md | 79 +++++++++++++++++++++++++++++++++++++++++++++++++++++------------- 1 file changed, 64 insertions(+), 15 deletions(-) pull 操作可以直接更新本地库,是fetch和merge的一次性操作git pull [远程库地址别名] [远程分支名] 3.8 冲突解决注意点： 如果不是基于GitHub远程库的最新版本所做的修改，不能进行push推送，必须先进行pull操作拉取下来。 拉取下来后如果进入冲突状态，则先解决冲突，去掉冲突标记，选用合适的内容，冲突解决后才能push操作。 3.9 跨团队协作 在他人的远程库地址上点击fork，就可以fork到自己的远程库上 在自己的远程库上，使用git中的git clone [远程库地址]操作，克隆到自己的本地库 自己在本地进行修改，push推送到远程库中 在远程库的项目中找到 并点击 pull requests -&gt; new pull requests -&gt; create pull request,然后发送该pull request的信息 ，此时在被fork的原始项目中的 pull requests一栏中就可以看到pull request的信息，并可以进行对话。 合并代码，在对话框中就可以点击 merge pull request进行合并，点击之后填写合并信息 被fork的用户就可以将已经更新修改的远程库就可以拉取到本地 3.10 SSH连接方式 ssh-keygen -t rsa -C [将要的登陆用户的邮箱] 执行后会生成SSH目录 .ssh/ 在.ssh/目录下 ，cat id_rsa.pub 获取该id的SSH-RSA的公钥复制到GitHub上的SSH Keys中 在GitHub上添加SSH key 新建使用SSH连接的远程地址别名git remote add [别名] [ssh方式的连接地址] 使用ssh连接进行push操作 4. Git在eclipse中的应用4.1 忽略推送配置文件 在网址https://github.com/github/gitignore/blob/master/Java.gitignore 找到Java.gitignore文件，此文件为GitHub已经整理好的忽略配置文件。 在自己的用户目录，把Java.gitignore文件和.gitconfig文件放在一块。 在Java.gitignore文件中加入以下内容：添加过滤项 1234.classpath.project.settingstarget Java.gitignore文件内容信息为： 12345678910111213141516171819202122232425262728# Compiled class file*.class# Log file*.log# BlueJ files*.ctxt# Mobile Tools for Java (J2ME).mtj.tmp/# Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar# virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid*.classpath.project.settingstarget 在.gitconfig配置文件中加入以下内容： 12[core] excludesfile = C:/Users/hxhaaj/Java.gitignore 此时注意，该路径内容为Java.gitignore文件路径信息，同时，路径分割符必须为正斜线&#39;/&#39;，不能为反斜线&#39;\&#39;。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git基础</tag>
        <tag>GitHub使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaNIO]]></title>
    <url>%2F2018%2F03%2F10%2FJava-NIO%2F</url>
    <content type="text"><![CDATA[Java NIO1. Java NIO 概念 Java NIO（New IO） 是从Java 1.4版本开始引入的一个新的IO API，可以替代标准的Java IO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作。 2. NIO与IO的主要区别 IO NIO 面向流 面向缓冲区 阻塞IO 非阻塞IO 无 选择器 NIO面向缓冲区数据流通图 通道负责连通，搭建缓冲区流通路径 缓冲区用于来回运送数据 NIO核心在于：通道（Channel）和缓冲区（Buffer）。通道表示打开到IO设备（例如：文件、套接字）的连接。若需要使用NIO系统，需要获取用于连接IO设备的通道以及用于容纳数据的缓冲区。然后操作缓冲区，对数据进行处理。 3. 缓冲区 （Buffer） 缓冲区就是数组，用于存储不同数据类型的数据。 3.1 缓冲区的类型根据数据类型不同（除了boolean类型）,提供了相应类型的缓冲区：1234567ByteBufferCharBufferShortBufferIntBufferLongBufferFloatBufferDoubleBuffer 上述各类型缓冲区管理方式几乎一致，通过allocate()获取缓冲区1ByteBuffer buf = ByteBuffer.allocate(1024); 3.2 缓冲区存取数据的两个核心方法 put() 存入数据到缓冲区中 get() 获取缓冲区中的数据 3.3 缓冲区中的四个核心属性 capacity 容量，表示缓冲区中最大存储数据的容量。一旦声明不能改变，即为数组长度。 limit 界限，表示缓冲区中可以操作数据的大小。limit值后面的数据不能进行读写。 position 位置，表示缓冲区中正在操作数据的位置。 mark 标记 ， 表示记录当前position的位置，可以通过reset()恢复到mark的位置。 0 &lt;= mark &lt;= position &lt;= limit &lt;= capacity 3.3.1 position、limit、capacity 值的关系 当allocate(10)分配10个字节大小的缓冲区后，position的位置为0，capacity(容量)的值为10，limit（界限）值为10。 当使用put(5)方法进入写数据模式时，position指针的位置在填入数据后的第一个空闲位置，此时位置为5，capacity总容量值不变，依然为10，limit界限值还是为10。 当使用方法flip()后进入读数据模式，此时的position指针的位置为使用区的开始位置，即为0。limit界限的值则为5，因为在读取模式中，读取的应为使用区，所以界限为5，超过5就是空闲区了，最多取到5。capacity总容量的值依然为10变。 3.4 缓冲区Buffer类中的常用方法 Modifier and Type Method and Description abstract Object array()返回支持此缓冲区的数组 （可选操作） 。 abstract int arrayOffset()返回该缓冲区的缓冲区的第一个元素的背衬数组中的偏移量 （可选操作） 。 int capacity()返回此缓冲区的容量。 Buffer clear()清除此缓冲区。但是其中的元素并没有消失，只是处于在 被遗忘状态,因为position、limit 值全部归零，和刚刚分配时一致。 Buffer flip()翻转这个缓冲区。 abstract boolean hasArray()告诉这个缓冲区是否由可访问的数组支持。 boolean hasRemaining()告诉当前位置和极限之间是否存在任何元素。 abstract boolean isDirect()告诉这个缓冲区是否为 direct 。 abstract boolean isReadOnly()告知这个缓冲区是否是只读的。 int limit()返回此缓冲区的限制。 Buffer limit(int newLimit)设置此缓冲区的限制。 Buffer mark()将此缓冲区的标记设置在其位置。 int position()返回此缓冲区的位置。 Buffer position(int newPosition)设置这个缓冲区的位置。 int remaining()返回当前位置和限制之间的元素数。 Buffer reset()将此缓冲区的位置重置为先前标记的位置。 Buffer rewind()倒带这个缓冲区。 测试： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556String str = "hxh";//定义缓冲区，指定缓冲区类型和大小ByteBuffer bf = ByteBuffer.allocate(1024);System.out.println("--allocate()---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());/*--allocate()---capacity---1024limit---1024position---0*///利用put() 装入缓冲区,进去写模式bf.put(str.getBytes());System.out.println("--put()---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());/*--put()---capacity---1024limit---1024position---3*///使用flip()进入读数据模式bf.flip();System.out.println("--flip()---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());/*--flip()---capacity---1024limit---3position---0*///使用get(byte []) 读取缓冲区中的数据byte[] dst = new byte[bf.limit()];bf.get(dst);//此方法将字节从此缓冲区传输到给定的目标数组System.out.println(new String(dst,0,dst.length));//打印字节数组中的数据System.out.println("--get()---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());/* hxh --get()--- capacity---1024 limit---3 position---3 */ 测试结果：如上图一致 123456789101112131415161718--allocate()---capacity---1024limit---1024position---0--put()---capacity---1024limit---1024position---3--flip()---capacity---1024limit---3position---0 hxh--get()---capacity---1024limit---3position---3 rewind()，实现可重复读 123456789101112131415//使用rewind方法，实现可重复读bf.rewind();System.out.println("--rewind() 重复读取，指针归0---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());/* --rewind() 重复读取，指针归0--- capacity---1024 limit---3 position---0 */ clear()清除此缓冲区1234567891011121314151617181920//clear()清除此缓冲区。但是其中的元素并没有消失，// 只是处于在 被遗忘状态,// 因为position、limit 值全部归零，和刚刚分配时一致。bf.clear();System.out.println("--clear()---");System.out.println("capacity---"+bf.capacity());System.out.println("limit---"+bf.limit());System.out.println("position---"+bf.position());System.out.println("依然可以取到值，测试："+(char) bf.get());/* --clear()--- capacity---1024 limit---1024 position---0 依然可以取到值，测试：h */ 注意点：clear()清除此缓冲区。但是其中的元素并没有消失，只是处于在 被遗忘状态,因为position、limit、capacity 值全部归零，和刚刚分配时一致。如果直接bf.get()取值，当然也是可以取到。 mark()和 reset() 12345678910111213141516171819String str = "abcdefg";ByteBuffer bf = ByteBuffer.allocate(1024);bf.put(str.getBytes());bf.flip();byte[] dst = new byte[bf.limit()];bf.get(dst,0,2);System.out.println(new String(dst,0,2)); // abSystem.out.println("position---"+bf.position()); //2//此时标记一下position的位置bf.mark();System.out.println("此时mark一下");bf.get(dst,2,2);System.out.println(new String(dst,2,2)); //cdSystem.out.println("position---"+bf.position()); //4bf.reset(); //重置到标记位置System.out.println("reset 重置后---");System.out.println("position---"+bf.position()); //2 又回到了mark标记的位置 结果： 1234567abposition---2此时mark一下cdposition---4reset 重置后---position---2 hasRemainin 和 remaining 12345//hasRemaining 当前位置和极限位置之间是否还有元素if(bf.hasRemaining())&#123; //有元素， 返回当前位置和极限位置之间的元素数量 System.out.println(bf.remaining());&#125; 3.5 继承Buffer类的各具体类型缓冲区中的常用方法(以ByteBuffer类为例)3.5.1 allocate 分配缓冲区1public static ByteBuffer allocate(int capacity) 分配一个新的字节缓冲区 新缓冲区的位置将为零，其限制将为其容量，其标记将不定义，并且其每个元素将被初始化为零。 它将有一个backing array ，其array offset将为零。 参数 capacity - 新的缓冲区的容量，以字节为单位 结果 新的字节缓冲区 3.5.2 put 存入 ，写入缓冲区 1public abstract ByteBuffer put(byte b) 相对放置法（可选操作） 。 将给定字节写入当前位置的缓冲区，然后增加位置。 参数 b - 要写入的字节 结果 这个缓冲区 12public abstract ByteBuffer put(int index, byte b) 绝对put方法（可选操作） 。 将给定字节写入给定索引的缓冲区。 参数 index - 要写入字节的索引 b - 要写入的字节值 结果 这个缓冲区 123public ByteBuffer put(byte[] src, int offset, int length) 相对大容量put方法（可选操作） 。 此方法将字节从给定的源数组传输到此缓冲区。 如果要从数组中复制的字节多于保留在此缓冲区中的字节数，也就是说，如果length &gt; remaining() ，则不会传输任何字节，并抛出BufferOverflowException 。 否则，该方法将给定数组中的length个字节复制到此缓冲区中，从阵列中的给定偏移量和该缓冲区的当前位置开始。 此缓冲区的位置然后增加length 。 换言之，所述表格dst.put(src, off, len)的这种方法的调用具有完全一样的环相同的效果 1for (int i = off; i &lt; off + len; i++) dst.put(a[i]); 除了它首先检查这个缓冲区中是否有足够的空间，并且它可能更有效率。 参数 src - 要读取字节的数组 offset - 要读取的第一个字节的数组内的偏移量; 必须是非负数，不得大于array.length length - 要从给定数组读取的字节数; 必须是非负数，不得大于array.length - offset 结果 这个缓冲区 1public ByteBuffer put(ByteBuffer src) 相对大容量put方法（可选操作） 。 此方法将给定源缓冲区中剩余的字节传输到此缓冲区。 如果源缓冲区中剩余的字节多于此缓冲区，即src.remaining() &gt; remaining() ，则不会传输任何字节，并抛出BufferOverflowException 。 否则，该方法将n = src.remaining()个字节从给定缓冲区复制到此缓冲区中，从每个缓冲区的当前位置开始。 然后将两个缓冲器的位置递增n 。 换句话说，调用此方法的形式dst.put(src)具有与循环完全相同的效果 12while (src.hasRemaining()) dst.put(src.get()); 除了它首先检查这个缓冲区中是否有足够的空间，并且它可能更有效率。 参数 src - 读取字节的源缓冲区; 不能是这个缓冲区 结果 这个缓冲区 3.5.3 get 获取 ，读取缓冲区 1public abstract byte get() 相对获取方法。 读取该缓冲区当前位置的字节，然后增加位置。 结果 缓冲区当前位置的字节 1public abstract byte get(int index) 绝对获取方法。 读取给定索引处的字节。 参数 index - 读取字节的索引 结果 给定索引的字节 1public ByteBuffer get(byte[] dst) 相对批量获取方法。 此方法将字节从此缓冲区传输到给定的目标数组。 调用此方法的形式为src.get(a)的行为方式与调用完全相同 1src.get(a, 0, a.length) 参数 dst - 目的地阵列 结果 这个缓冲区 ​ 123public ByteBuffer get(byte[] dst, int offset, int length) 相对批量获取方法。 此方法将字节从此缓冲区传输到给定的目标数组。 如果缓冲区中剩余的字节比满足请求所需的字节少，也就是说，如果length &gt; remaining() ， 则不 传输任何字节并抛出BufferUnderflowException 。 否则，该方法将length字节从该缓冲区复制到给定的数组中，从该缓冲区的当前位置开始，并在数组中给定的偏移量。 然后将该缓冲区的位置增加length 。 换句话说，调用此方法的形式src.get(dst, off, len)具有与循环完全相同的效果 1for (int i = off; i &lt; off + len; i++) dst[i] = src.get(): 除了它首先检查这个缓冲区中是否有足够的字节，并且它可能更有效率。 参数 dst - 要写入字节的数组 offset - 要写入的第一个字节的数组中的偏移量; 必须是非负数，不得大于dst.length length - 要写入给定数组的最大字节数; 必须是非负数，不得大于dst.length - offset 结果 这个缓冲区 4. 非直接缓冲区和直接缓冲区4.1 概念区分 非直接缓冲区：通过allocate()方法分配缓冲区，将缓冲区建立在JVM的内存中. 直接缓冲区：通过allocateDirect()方法分配直接缓冲区，将缓冲区建立在物理内存中。操作系统的内存中，可以提升效率。 4.2 直接缓冲区的相对优缺点 直接缓冲区利用了操作系统中直接映射方式，在物理内存中初始化一个物理内存映射文件，省去了非直接缓冲区的中间多余的内容复制步骤，让应用程序和物理磁盘直接面对。 优点：简化步骤，直接映射，提升效率。 缺点： 初始化物理内存映射文件时，耗费较大物理内存，并且不会直接用完释放，必须通过垃圾回收机制进行释放。 直接操作物理内存和磁盘，不安全，不易控制。 适合：数据长时间在内存中操作，大量数据直接在物理内存中存放，不存放在jvm中。 直接缓冲区，Java虚拟机会尽量避免将缓冲区的内容复制到中间缓冲区中（或从中间缓冲区中复制内容），即省去了中间内容复制操作。而是直接在此缓冲区上执行本机IO操作。 直接缓冲区，通过Buffer类中的allocateDirect()工厂方法来创建。此方法返回的缓冲区进行分配和取消分配所需成本通常高于非直接缓冲区。 5. 通道（Channel）5.1 通道概念 用于源节点和目标节点的连接。NIO中负责缓冲区中数据的传输。Channel类似于传统的“流”。但是Channel本身不存储数据，因此需要配合缓冲区进行传输。 5.2 Channel的主要实现类12345java.nio.channels.Channel 接口 |-- FileChannel |-- SocketChannel |-- ServletSocketChannel |-- DatagramChannel 5.3 Channel的获取 Java对于支持通道的类都提供了getChannel()方法。 本地IO： FileInputStream FileOutputStream RandomAccessFile 网路IO： Socket ServerSocket DatagramSocket Java7中的NIO 2 对于各个通道提供了静态方法open() Java7中的NIO 2 的Files工具类提供的方法 newByteChannel()]]></content>
      <categories>
        <category>JavaSE回顾</category>
      </categories>
      <tags>
        <tag>JavaNIO</tag>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaSE回顾-基础语法]]></title>
    <url>%2F2018%2F01%2F12%2FJavaSE%E5%9B%9E%E9%A1%BE-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[JavaSE 回顾-基础语法1. Java语言的特性1.1 简单性 java剔除了C++中许多很少使用、难以理解、易混淆的特性。尽可能的简单化。 1.2 面向对象 java是基于面向对象的程序设计技术设计的，将重点放在数据（即对象）和对象的接口上。 1.3 分布式 java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。 java 应用能通过URL打开和访问网络上的对象，其便捷程度就行访问本地文件一样。 1.4 健壮性 java程序具有多方面的可靠性，Java编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题。 1.5 安全性 Java适用于网络/分布式环境，为了达到这个目标，安全方面投入很大。使用java可以构建防病毒、防篡改的系统。 不可信的代码在一个沙箱环境中执行，在这里不会影响主系统。Java代码不论来自哪里，都不会脱离沙箱。 1.6 体系结构中立 编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要Java运行时系统，这些编译后的代码可以在许多处理器上运行。 Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。 字节码文件可以容易的在任何机器上解释执行，而且还可以动态翻译成本地机器码。 Java虚拟机可以将执行最频繁的字节码序列翻译成机器吗，该过程为即时编译。 Java虚拟机可以检测指令序列，增强其安全性。 1.7 可移植性 数据类型规定具有固定的大小。例如：Java中的int类型永远为32为的整数，不会随着操作系统或编译器不同而改变。 二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。 字符串是用标准的Unicode格式存储的。 作为系统组成部分的类库，定义了可移植的接口。例如：有一个抽象的Window类，并给出了在UNIX、Windows和Macintosh环境下的不同实现。 除了用户界面有关的部分外，所有其他Java库都能很好的支持平台独立性，不用操心底层的操作系统。 不仅程序是可移植的，Java API 往往也比原生的API质量更高。 1.8 解释型 Java解释器可以在任何移植了解释器的机器上执行Java字节码。 1.9 高性能 字节码可以在运行时动态翻译成对应运行这个应用的特定CPU的机器码。 即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。 1.10 多线程 Java支持多线程和并发性,可以带来更好的交互响应和实时行为。 1.11 动态性 适应不断发展的环境，在类库中可以自由的添加新方法和实例变量，而对客户端不产生任何影响。 2. Java 基本语法注意点2.1 类名 关键字class 后面紧跟类名。 类名命名规则： 必须以字母或下划线开头，后面可以跟字母和数字的任意组合。 注意：Java中的字母和数字的范围更大。字母包括&#39;A&#39;~&#39;Z&#39;、&#39;a&#39;~&#39;z&#39;、&#39;_&#39;、&#39;$&#39;或者在某种语言中表示字母的任何Unicode字符。 长度基本上没限制。 不能使用Java保留字作为类名。 12345678public class $Test1 &#123; //类名还可以是 _Test 以下划线开头 public static void main(String[] args) &#123; int _a = 1; int $a = 1; System.err.println(_a); System.out.println($a); &#125;&#125; 源代码的文件名必须与公共类名相同，并用.java作为拓展名。 类名命名规范： 类名以大写字母开头名词 骆驼命名法。 2.2 main方法 Java语言规范，main 方法 必须声明为 public。 Java SE 1.4及以后版本强制 main 方法一定是public修饰的。 main 方法 必须为 public static void main(String[] args) ，缺少public 、static、以及String[] args 参数，都不能成为class 的入口，运行不了。 2.3 注释 Java一共3种注释方式： // xxxxx 单行注释 多行注释 ，形成一个注释块 1234/* xxxx xxx */ 注意： /* xxx*/ 注释不能嵌套使用。 文档注释 可以用来自动地生成文档。 1234/** * @version * @author hxh */ 2.4 数据类型Java是强类型语言。每一个变量声明一种类型。一共有8种基本类型。 4种整型 int short long byte 2种浮点类型 float double 1种用于表示Unicode编码的字符单元类型 char 1种用于表示真值 类型 boolean 注意： Java 有一个能够表示任意精度的算术包，通常被称为“大数值” (big number)。它只是一个Java对象，不是一个数据类型。 2.4.1 整型 整型用于表示没有小数部分的数值，它可以是负数据。 类型 字节数 int 4 short 2 long 8 byte 1 整型的范围与运行Java代码的机器无关。 长整型数值有一个后缀L或l,如：1111L 十六进制数值有一个前缀0x或0X，如 0xCAFE 八进制有一个前缀0 Java7开始，加上前缀0b或0B就可以写二进制数。如：0b1001就是9。 Java7开始，还可以为数字字面量加下划线。如 1_000_00（0b1111_0100_0010_0100_0000）表示一百万。注意：这些下划线只是为了让人易读，Java编译器会自动去除这些下划线。 2.4.2 浮点类型 浮点类型用于表示有小数部分的数值。 类型 字节数 float 4 double 8 double类型数值精度是float类型的两倍，称为双精度数值。 float类型数值有一个后缀F或f（3.14f），没有后缀F的浮点数值（3.14）默认为double类型。 所有浮点数值计算都遵循IEEE 754规范。用于表示溢出或出错情况的三个特殊浮点数值： 正无穷大 负无穷大 NaN(不是一个数字) 例如： 一个正整数除以0的结果为正无穷大。 计算0/0或者负数的平方根结果为NaN。 浮点数值不适用于无法接受舍入误差的金融计算中。 例如： System.out.println(2.0-1.1); 结果为 0.8999999999999999 而不是正确结果0.9。 这种舍入误差原因是 浮点数值采用二进制系统表示，二进制系统中无法精确地表示分数1/10。就像十进制无法精确表示分数1/3一样。 如果数值计算中不允许出现这种舍入误差，就应该采用BigDecimal类。 2.4.3 char类型 char占2字节，16位。可在存放汉字，只能放单个字符。 12345char a='h'; //任意单个字符，加单引号。char a='中'; //任意单个中文字char a = 111; //整数。0~65535。十进制、八进制、十六进制均可。输出字符编码表中对应的字符。 char 类型原本用于表示单个字符。但是现在有所改变，有些Unicode字符可以用一个char值描述，另一些Unicode字符则需要两个char值。 char类型字面量值要用单引号括起来。 例如：’A’是编码值为65所对应的字符常量。它和 “A” 不同，”A” 是包含一个字符A的字符串。 对char类型字符运行时，直接当做ASCII表对应的整数来对待。 12345678910111213141516171819202122232425char m='a'; //a。char m='a'+'b'; // Ã。 //char类型相加，提升为int类型，输出对应的字符。int m='a'+'b'; //195没有超出int范围，直接输出195。char m='a'+b; //报错。 因为b是一个赋值的变量。char m=197; //输出字符编码表中对应的字符。 ——Ã。char m='197; //因为有单引号，表示是字符，只允许放单个字符。 ——报错。char m='a'+1; //提升为int，计算结果98对应的字符是b。——b。char m='中'+'国'; // 42282。char m='中'+'国'+'国'+'国'; // 报错。int转char有损失。因为结果已经超出char类型的范围。int m='中'+'国'+'国'+'国'; //86820char m='中'+1; //1是int，结果提升为int，输出对应的字符。 ——丮。char m='中'+"国"; // 报错。String无法转换为char。System.out.println('中'+"国"); //没有变量附值的过程。String与任何字符用“+”相连，转换为String。——中国。 char+char，char+int ， 类型均提升为int，赋值给char变量后，输出字符编码表中对应的字符(char h = 97 a)。 char类型的值可以表示为十六进制值，范围从\u0000到 \uffff。 除了转义序列\u之外，还有其他用于表示特殊字符的转义序列。 所有转义序列都可以出现在加引号的字符字面量或字符串中。例如： &#39;\u2122&#39; &quot;hello\n&quot; 转义序列\u还可以出现在加引号的字符常量或者字符串之外。其他转义序列不可以。 Unicode转义序列会在解析代码之前得到处理。 例如： &quot;\u0022+\u0022&quot;并不是一个由引号包围加号构成的字符串。实际上，\u0022会在解析之前转换为&quot;，这样就会得到&quot;&quot;+&quot;&quot;，也就是一个空串。 当心注释中的\u。 // Look inside C:\users 会产生一个语法错误，因为\u后面并未跟着4个十六进制数。 12345public class Test1 &#123; public static void main(String[] args) &#123; System.err.println("1");// Look inside C:\users &#125;&#125; 语法出错： 编译都通不过: 12Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: Invalid unicode 在Java中，char类型描述了UTF-16编码中的一个代码单元。建议不要在程序中使用char类型，除非缺失需要处理UTF-16代码单元。最好将字符串作为抽象画数据类型处理。 2.4.4 boolean类型 只有两个值： flase 和 true 用来判断逻辑条件 整型值和布尔值之间无法相互转换 2.5 变量2.5.1 变量命名规定 变量名必须是一个以字母、下划线、$符号开头并由字母或数字构成的序列。一般来说，在Java中，下划线和$均属于字母。π 、 其他国家的字母 也可以。 不能出现 其他符号 例如 + 、 @ 这样的符号 以及 空格 不能出现在变量名中。 大小写敏感 长度基本没有限制 尽管$是一个合法的Java字符，但是最好不要出现在自己的代码中使用这个字符。它只用在Java编译器或者其他工具生成的名字中。 不能使用Java保留字 1234int _a = 1;int $a = 1;System.err.println(_a);System.out.println($a); 2.5.2 变量初始化 声明后的一个变量，不能直接使用未初始化的变量。必须使用赋值语句对变量进行显式初始化。 2.6 常量 利用关键字final 指示常量。 final修饰的变量只能被赋值一次，一旦赋值一次后，不能再更改。 习惯上常量名使用全大写 若某个常量经常被一个类中的多个方法中使用，通常称该常量为类常量。可以使用static final 设置一个类常量。定义在main方法的外部。 2.7 运算符 当参与/运算的两个操作数都是整数时，表示整数除法；否则表示浮点除法。 例如 ： 15.0/2 等于 7.5 而 15/2 等于 7 整数被0除将会产生一个异常，而浮点数被0除将会得到一个无穷大或NaN结果。 2.8 数值类型之间的转换 小字节类型转换成大字节类型无信息丢失转换，相反，可能会有精度损失。 下图中，6个实心箭头表示无信息丢失的转化，3个虚线箭头表示可能有精度损失。 二元运算时，注意：先将两个操作数转换为同一种类型，然后再进行计算。 若 两个中有一个是double类型，另一个将会转换为double类型； 否则，若 两个中有一个是float类型，另一个将会转换成float类型； 否则，若 两个中有一个是long类型，另一个将会转换成long类型； 否则，两个都将会转换成int类型。 2.9 强制类型转换 强制类型转换通过截断小数部分将浮点值转换成整型。 如果想对浮点数进行舍入运算，就需要用Math.round()方法，该方法返回值为long类型，所以只有使用显式的强制转换才能将long类型转换成int类型。 12345678double x = 9.999;System.err.println((int)x);//9Long hh = Math.round(x);System.err.println(hh);//10int h = (int) Math.round(x);System.err.println(h); //10 需要注意目标类型的表示范围： 如果试图将一个数值从一种类型强制转换成为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值。例如：(byte)300 实际值 却只为 44。 12int a = 300;System.out.println((byte)a); //44 2.10 空串与Null串 空串是长度为0的字符串，是一个Java对象，有自己的串长度（0）和内容 （空）。 String h = null; 表示一个Null串，目前没有任何对象与该变量关联，无引用。 检查一个字符串，要检查它既不是null也不为空串：if(str != null &amp;&amp; str.length() != 0) 2.11 switch语句 switch语句将会从与选项值相匹配的case标签处开始执行直到遇到break语句，或者执行到switch语句的结束处为止。 如果没有匹配case分支，而有default子句，就执行default子句。 很有可能触发多个分支： 如果在case分支语句的末尾没有break语句，那么就会接着执行下一个case分支语句。 case标签可以是： 类型为 char 、byte 、short 、 int 的常量表达式 枚举常量 Java SE 7开始，case标签还可以是字符串字面量。 2.12 大数值 如果基本的整数和浮点值精度不够，那么可以使用java.math包中的两个类：BigInteger和BigDecimal。这两个类可以处理包含任意长度数字序列的数值。 BigInteger类实现了任意精度的整型运算。 BigDecimal类实现了任意精度的浮点数运算。 使用静态的valueOf()方法可以将普通的数值转换成大数值。 2.12.1 BigDecimal 浮点数值不适用于无法接受舍入误差的金融计算中。 例如： System.out.println(2.0-1.1); 结果为 0.8999999999999999 而不是正确结果0.9。 12System.out.println(1.01 + 2.02);//3.0300000000000002System.out.println(3.0 - 2.1);//0.8999999999999999 这种舍入误差原因是 浮点数值采用二进制系统表示，二进制系统中无法精确地表示分数1/10。就像十进制无法精确表示分数1/3一样。 如果数值计算中不允许出现这种舍入误差，就应该采用BigDecimal类。用来对超过16位有效位的数进行精确的运算。 双精度浮点型变量double可以处理16位有效数。在实际应用中，需要对更大或者更小的数进行运算和处理。float和double只能用来做科学计算或者是工程计算，在商业计算中要用java.math.BigDecimal。 创建BigDecimal对象主要有两种: 12BigDecimal b1= new BigDecimal("3.0");//new BigDecimal(Double.toString(3.0))BigDecimal b2 = BigDecimal.valueOf(2.1); b1也可以写成new BigDecimal(Double.toString(3.0))，直接用new BigDecimal(3.0)，就会出现精度问题。 12BigDecimal x1 = new BigDecimal(1.34);//1.3400000000000000799360577730112709105014801025390625BigDecimal x2 = new BigDecimal("1.34");//1.34 除了这两种外，特殊的像0、1、10可以这样写 123BigDecimal zero = BigDecimal.ZERO;BigDecimal one = BigDecimal.ONE;BigDecimal ten = BigDecimal.TEN; BigDecimal所创建的是对象，不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。 1234public BigDecimal add(BigDecimal value);//加法public BigDecimal subtract(BigDecimal value);//减法 public BigDecimal multiply(BigDecimal value);//乘法public BigDecimal divide(BigDecimal value);//除法 BigDecimal的运算不对原值进行操作，而是返回一个新的BigDecimal对象。 BigDecimal的比较用的是BigDecimal的compareTo方法，将此 BigDecimal 与指定的 BigDecimal 比较。 注意：值相等但具有不同标度的两个BigDecimal对象（如，2.0 和 2.00）被认为是相等的。 BigDecimal 在数字上小于、等于或大于比较对象时，返回 -1、0 或 1。 123456BigDecimal a = BigDecimal.valueOf(1);BigDecimal b = BigDecimal.valueOf(20);BigDecimal c = a.add(b);int i1 = a.compareTo(b);//-1int i2 = b.compareTo(b);//0int i3 = c.compareTo(b);//1]]></content>
      <categories>
        <category>JavaSE回顾</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
</search>
